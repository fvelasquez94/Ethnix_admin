"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/qrcode.react";
exports.ids = ["vendor-chunks/qrcode.react"];
exports.modules = {

/***/ "(ssr)/./node_modules/qrcode.react/lib/esm/index.js":
/*!****************************************************!*\
  !*** ./node_modules/qrcode.react/lib/esm/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QRCodeCanvas: () => (/* binding */ QRCodeCanvas),\n/* harmony export */   QRCodeSVG: () => (/* binding */ QRCodeSVG),\n/* harmony export */   \"default\": () => (/* binding */ QRCode)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __spreadValues = (a, b)=>{\n    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n};\nvar __objRest = (source, exclude)=>{\n    var target = {};\n    for(var prop in source)if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n    if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)){\n        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n    }\n    return target;\n};\n// src/index.tsx\n\n// src/third-party/qrcodegen/index.ts\n/**\n * @license QR Code generator library (TypeScript)\n * Copyright (c) Project Nayuki.\n * SPDX-License-Identifier: MIT\n */ var qrcodegen;\n((qrcodegen2)=>{\n    const _QrCode = class {\n        constructor(version, errorCorrectionLevel, dataCodewords, msk){\n            this.version = version;\n            this.errorCorrectionLevel = errorCorrectionLevel;\n            this.modules = [];\n            this.isFunction = [];\n            if (version < _QrCode.MIN_VERSION || version > _QrCode.MAX_VERSION) throw new RangeError(\"Version value out of range\");\n            if (msk < -1 || msk > 7) throw new RangeError(\"Mask value out of range\");\n            this.size = version * 4 + 17;\n            let row = [];\n            for(let i = 0; i < this.size; i++)row.push(false);\n            for(let i = 0; i < this.size; i++){\n                this.modules.push(row.slice());\n                this.isFunction.push(row.slice());\n            }\n            this.drawFunctionPatterns();\n            const allCodewords = this.addEccAndInterleave(dataCodewords);\n            this.drawCodewords(allCodewords);\n            if (msk == -1) {\n                let minPenalty = 1e9;\n                for(let i = 0; i < 8; i++){\n                    this.applyMask(i);\n                    this.drawFormatBits(i);\n                    const penalty = this.getPenaltyScore();\n                    if (penalty < minPenalty) {\n                        msk = i;\n                        minPenalty = penalty;\n                    }\n                    this.applyMask(i);\n                }\n            }\n            assert(0 <= msk && msk <= 7);\n            this.mask = msk;\n            this.applyMask(msk);\n            this.drawFormatBits(msk);\n            this.isFunction = [];\n        }\n        static encodeText(text, ecl) {\n            const segs = qrcodegen2.QrSegment.makeSegments(text);\n            return _QrCode.encodeSegments(segs, ecl);\n        }\n        static encodeBinary(data, ecl) {\n            const seg = qrcodegen2.QrSegment.makeBytes(data);\n            return _QrCode.encodeSegments([\n                seg\n            ], ecl);\n        }\n        static encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {\n            if (!(_QrCode.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= _QrCode.MAX_VERSION) || mask < -1 || mask > 7) throw new RangeError(\"Invalid value\");\n            let version;\n            let dataUsedBits;\n            for(version = minVersion;; version++){\n                const dataCapacityBits2 = _QrCode.getNumDataCodewords(version, ecl) * 8;\n                const usedBits = QrSegment.getTotalBits(segs, version);\n                if (usedBits <= dataCapacityBits2) {\n                    dataUsedBits = usedBits;\n                    break;\n                }\n                if (version >= maxVersion) throw new RangeError(\"Data too long\");\n            }\n            for (const newEcl of [\n                _QrCode.Ecc.MEDIUM,\n                _QrCode.Ecc.QUARTILE,\n                _QrCode.Ecc.HIGH\n            ]){\n                if (boostEcl && dataUsedBits <= _QrCode.getNumDataCodewords(version, newEcl) * 8) ecl = newEcl;\n            }\n            let bb = [];\n            for (const seg of segs){\n                appendBits(seg.mode.modeBits, 4, bb);\n                appendBits(seg.numChars, seg.mode.numCharCountBits(version), bb);\n                for (const b of seg.getData())bb.push(b);\n            }\n            assert(bb.length == dataUsedBits);\n            const dataCapacityBits = _QrCode.getNumDataCodewords(version, ecl) * 8;\n            assert(bb.length <= dataCapacityBits);\n            appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);\n            appendBits(0, (8 - bb.length % 8) % 8, bb);\n            assert(bb.length % 8 == 0);\n            for(let padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17)appendBits(padByte, 8, bb);\n            let dataCodewords = [];\n            while(dataCodewords.length * 8 < bb.length)dataCodewords.push(0);\n            bb.forEach((b, i)=>dataCodewords[i >>> 3] |= b << 7 - (i & 7));\n            return new _QrCode(version, ecl, dataCodewords, mask);\n        }\n        getModule(x, y) {\n            return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x];\n        }\n        getModules() {\n            return this.modules;\n        }\n        drawFunctionPatterns() {\n            for(let i = 0; i < this.size; i++){\n                this.setFunctionModule(6, i, i % 2 == 0);\n                this.setFunctionModule(i, 6, i % 2 == 0);\n            }\n            this.drawFinderPattern(3, 3);\n            this.drawFinderPattern(this.size - 4, 3);\n            this.drawFinderPattern(3, this.size - 4);\n            const alignPatPos = this.getAlignmentPatternPositions();\n            const numAlign = alignPatPos.length;\n            for(let i = 0; i < numAlign; i++){\n                for(let j = 0; j < numAlign; j++){\n                    if (!(i == 0 && j == 0 || i == 0 && j == numAlign - 1 || i == numAlign - 1 && j == 0)) this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);\n                }\n            }\n            this.drawFormatBits(0);\n            this.drawVersion();\n        }\n        drawFormatBits(mask) {\n            const data = this.errorCorrectionLevel.formatBits << 3 | mask;\n            let rem = data;\n            for(let i = 0; i < 10; i++)rem = rem << 1 ^ (rem >>> 9) * 1335;\n            const bits = (data << 10 | rem) ^ 21522;\n            assert(bits >>> 15 == 0);\n            for(let i = 0; i <= 5; i++)this.setFunctionModule(8, i, getBit(bits, i));\n            this.setFunctionModule(8, 7, getBit(bits, 6));\n            this.setFunctionModule(8, 8, getBit(bits, 7));\n            this.setFunctionModule(7, 8, getBit(bits, 8));\n            for(let i = 9; i < 15; i++)this.setFunctionModule(14 - i, 8, getBit(bits, i));\n            for(let i = 0; i < 8; i++)this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));\n            for(let i = 8; i < 15; i++)this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));\n            this.setFunctionModule(8, this.size - 8, true);\n        }\n        drawVersion() {\n            if (this.version < 7) return;\n            let rem = this.version;\n            for(let i = 0; i < 12; i++)rem = rem << 1 ^ (rem >>> 11) * 7973;\n            const bits = this.version << 12 | rem;\n            assert(bits >>> 18 == 0);\n            for(let i = 0; i < 18; i++){\n                const color = getBit(bits, i);\n                const a = this.size - 11 + i % 3;\n                const b = Math.floor(i / 3);\n                this.setFunctionModule(a, b, color);\n                this.setFunctionModule(b, a, color);\n            }\n        }\n        drawFinderPattern(x, y) {\n            for(let dy = -4; dy <= 4; dy++){\n                for(let dx = -4; dx <= 4; dx++){\n                    const dist = Math.max(Math.abs(dx), Math.abs(dy));\n                    const xx = x + dx;\n                    const yy = y + dy;\n                    if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size) this.setFunctionModule(xx, yy, dist != 2 && dist != 4);\n                }\n            }\n        }\n        drawAlignmentPattern(x, y) {\n            for(let dy = -2; dy <= 2; dy++){\n                for(let dx = -2; dx <= 2; dx++)this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);\n            }\n        }\n        setFunctionModule(x, y, isDark) {\n            this.modules[y][x] = isDark;\n            this.isFunction[y][x] = true;\n        }\n        addEccAndInterleave(data) {\n            const ver = this.version;\n            const ecl = this.errorCorrectionLevel;\n            if (data.length != _QrCode.getNumDataCodewords(ver, ecl)) throw new RangeError(\"Invalid argument\");\n            const numBlocks = _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];\n            const blockEccLen = _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];\n            const rawCodewords = Math.floor(_QrCode.getNumRawDataModules(ver) / 8);\n            const numShortBlocks = numBlocks - rawCodewords % numBlocks;\n            const shortBlockLen = Math.floor(rawCodewords / numBlocks);\n            let blocks = [];\n            const rsDiv = _QrCode.reedSolomonComputeDivisor(blockEccLen);\n            for(let i = 0, k = 0; i < numBlocks; i++){\n                let dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));\n                k += dat.length;\n                const ecc = _QrCode.reedSolomonComputeRemainder(dat, rsDiv);\n                if (i < numShortBlocks) dat.push(0);\n                blocks.push(dat.concat(ecc));\n            }\n            let result = [];\n            for(let i = 0; i < blocks[0].length; i++){\n                blocks.forEach((block, j)=>{\n                    if (i != shortBlockLen - blockEccLen || j >= numShortBlocks) result.push(block[i]);\n                });\n            }\n            assert(result.length == rawCodewords);\n            return result;\n        }\n        drawCodewords(data) {\n            if (data.length != Math.floor(_QrCode.getNumRawDataModules(this.version) / 8)) throw new RangeError(\"Invalid argument\");\n            let i = 0;\n            for(let right = this.size - 1; right >= 1; right -= 2){\n                if (right == 6) right = 5;\n                for(let vert = 0; vert < this.size; vert++){\n                    for(let j = 0; j < 2; j++){\n                        const x = right - j;\n                        const upward = (right + 1 & 2) == 0;\n                        const y = upward ? this.size - 1 - vert : vert;\n                        if (!this.isFunction[y][x] && i < data.length * 8) {\n                            this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));\n                            i++;\n                        }\n                    }\n                }\n            }\n            assert(i == data.length * 8);\n        }\n        applyMask(mask) {\n            if (mask < 0 || mask > 7) throw new RangeError(\"Mask value out of range\");\n            for(let y = 0; y < this.size; y++){\n                for(let x = 0; x < this.size; x++){\n                    let invert;\n                    switch(mask){\n                        case 0:\n                            invert = (x + y) % 2 == 0;\n                            break;\n                        case 1:\n                            invert = y % 2 == 0;\n                            break;\n                        case 2:\n                            invert = x % 3 == 0;\n                            break;\n                        case 3:\n                            invert = (x + y) % 3 == 0;\n                            break;\n                        case 4:\n                            invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;\n                            break;\n                        case 5:\n                            invert = x * y % 2 + x * y % 3 == 0;\n                            break;\n                        case 6:\n                            invert = (x * y % 2 + x * y % 3) % 2 == 0;\n                            break;\n                        case 7:\n                            invert = ((x + y) % 2 + x * y % 3) % 2 == 0;\n                            break;\n                        default:\n                            throw new Error(\"Unreachable\");\n                    }\n                    if (!this.isFunction[y][x] && invert) this.modules[y][x] = !this.modules[y][x];\n                }\n            }\n        }\n        getPenaltyScore() {\n            let result = 0;\n            for(let y = 0; y < this.size; y++){\n                let runColor = false;\n                let runX = 0;\n                let runHistory = [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n                for(let x = 0; x < this.size; x++){\n                    if (this.modules[y][x] == runColor) {\n                        runX++;\n                        if (runX == 5) result += _QrCode.PENALTY_N1;\n                        else if (runX > 5) result++;\n                    } else {\n                        this.finderPenaltyAddHistory(runX, runHistory);\n                        if (!runColor) result += this.finderPenaltyCountPatterns(runHistory) * _QrCode.PENALTY_N3;\n                        runColor = this.modules[y][x];\n                        runX = 1;\n                    }\n                }\n                result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * _QrCode.PENALTY_N3;\n            }\n            for(let x = 0; x < this.size; x++){\n                let runColor = false;\n                let runY = 0;\n                let runHistory = [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n                for(let y = 0; y < this.size; y++){\n                    if (this.modules[y][x] == runColor) {\n                        runY++;\n                        if (runY == 5) result += _QrCode.PENALTY_N1;\n                        else if (runY > 5) result++;\n                    } else {\n                        this.finderPenaltyAddHistory(runY, runHistory);\n                        if (!runColor) result += this.finderPenaltyCountPatterns(runHistory) * _QrCode.PENALTY_N3;\n                        runColor = this.modules[y][x];\n                        runY = 1;\n                    }\n                }\n                result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * _QrCode.PENALTY_N3;\n            }\n            for(let y = 0; y < this.size - 1; y++){\n                for(let x = 0; x < this.size - 1; x++){\n                    const color = this.modules[y][x];\n                    if (color == this.modules[y][x + 1] && color == this.modules[y + 1][x] && color == this.modules[y + 1][x + 1]) result += _QrCode.PENALTY_N2;\n                }\n            }\n            let dark = 0;\n            for (const row of this.modules)dark = row.reduce((sum, color)=>sum + (color ? 1 : 0), dark);\n            const total = this.size * this.size;\n            const k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;\n            assert(0 <= k && k <= 9);\n            result += k * _QrCode.PENALTY_N4;\n            assert(0 <= result && result <= 2568888);\n            return result;\n        }\n        getAlignmentPatternPositions() {\n            if (this.version == 1) return [];\n            else {\n                const numAlign = Math.floor(this.version / 7) + 2;\n                const step = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;\n                let result = [\n                    6\n                ];\n                for(let pos = this.size - 7; result.length < numAlign; pos -= step)result.splice(1, 0, pos);\n                return result;\n            }\n        }\n        static getNumRawDataModules(ver) {\n            if (ver < _QrCode.MIN_VERSION || ver > _QrCode.MAX_VERSION) throw new RangeError(\"Version number out of range\");\n            let result = (16 * ver + 128) * ver + 64;\n            if (ver >= 2) {\n                const numAlign = Math.floor(ver / 7) + 2;\n                result -= (25 * numAlign - 10) * numAlign - 55;\n                if (ver >= 7) result -= 36;\n            }\n            assert(208 <= result && result <= 29648);\n            return result;\n        }\n        static getNumDataCodewords(ver, ecl) {\n            return Math.floor(_QrCode.getNumRawDataModules(ver) / 8) - _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];\n        }\n        static reedSolomonComputeDivisor(degree) {\n            if (degree < 1 || degree > 255) throw new RangeError(\"Degree out of range\");\n            let result = [];\n            for(let i = 0; i < degree - 1; i++)result.push(0);\n            result.push(1);\n            let root = 1;\n            for(let i = 0; i < degree; i++){\n                for(let j = 0; j < result.length; j++){\n                    result[j] = _QrCode.reedSolomonMultiply(result[j], root);\n                    if (j + 1 < result.length) result[j] ^= result[j + 1];\n                }\n                root = _QrCode.reedSolomonMultiply(root, 2);\n            }\n            return result;\n        }\n        static reedSolomonComputeRemainder(data, divisor) {\n            let result = divisor.map((_)=>0);\n            for (const b of data){\n                const factor = b ^ result.shift();\n                result.push(0);\n                divisor.forEach((coef, i)=>result[i] ^= _QrCode.reedSolomonMultiply(coef, factor));\n            }\n            return result;\n        }\n        static reedSolomonMultiply(x, y) {\n            if (x >>> 8 != 0 || y >>> 8 != 0) throw new RangeError(\"Byte out of range\");\n            let z = 0;\n            for(let i = 7; i >= 0; i--){\n                z = z << 1 ^ (z >>> 7) * 285;\n                z ^= (y >>> i & 1) * x;\n            }\n            assert(z >>> 8 == 0);\n            return z;\n        }\n        finderPenaltyCountPatterns(runHistory) {\n            const n = runHistory[1];\n            assert(n <= this.size * 3);\n            const core = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n;\n            return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);\n        }\n        finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {\n            if (currentRunColor) {\n                this.finderPenaltyAddHistory(currentRunLength, runHistory);\n                currentRunLength = 0;\n            }\n            currentRunLength += this.size;\n            this.finderPenaltyAddHistory(currentRunLength, runHistory);\n            return this.finderPenaltyCountPatterns(runHistory);\n        }\n        finderPenaltyAddHistory(currentRunLength, runHistory) {\n            if (runHistory[0] == 0) currentRunLength += this.size;\n            runHistory.pop();\n            runHistory.unshift(currentRunLength);\n        }\n    };\n    let QrCode = _QrCode;\n    QrCode.MIN_VERSION = 1;\n    QrCode.MAX_VERSION = 40;\n    QrCode.PENALTY_N1 = 3;\n    QrCode.PENALTY_N2 = 3;\n    QrCode.PENALTY_N3 = 40;\n    QrCode.PENALTY_N4 = 10;\n    QrCode.ECC_CODEWORDS_PER_BLOCK = [\n        [\n            -1,\n            7,\n            10,\n            15,\n            20,\n            26,\n            18,\n            20,\n            24,\n            30,\n            18,\n            20,\n            24,\n            26,\n            30,\n            22,\n            24,\n            28,\n            30,\n            28,\n            28,\n            28,\n            28,\n            30,\n            30,\n            26,\n            28,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30\n        ],\n        [\n            -1,\n            10,\n            16,\n            26,\n            18,\n            24,\n            16,\n            18,\n            22,\n            22,\n            26,\n            30,\n            22,\n            22,\n            24,\n            24,\n            28,\n            28,\n            26,\n            26,\n            26,\n            26,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28\n        ],\n        [\n            -1,\n            13,\n            22,\n            18,\n            26,\n            18,\n            24,\n            18,\n            22,\n            20,\n            24,\n            28,\n            26,\n            24,\n            20,\n            30,\n            24,\n            28,\n            28,\n            26,\n            30,\n            28,\n            30,\n            30,\n            30,\n            30,\n            28,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30\n        ],\n        [\n            -1,\n            17,\n            28,\n            22,\n            16,\n            22,\n            28,\n            26,\n            26,\n            24,\n            28,\n            24,\n            28,\n            22,\n            24,\n            24,\n            30,\n            28,\n            28,\n            26,\n            28,\n            30,\n            24,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30\n        ]\n    ];\n    QrCode.NUM_ERROR_CORRECTION_BLOCKS = [\n        [\n            -1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            2,\n            2,\n            2,\n            2,\n            4,\n            4,\n            4,\n            4,\n            4,\n            6,\n            6,\n            6,\n            6,\n            7,\n            8,\n            8,\n            9,\n            9,\n            10,\n            12,\n            12,\n            12,\n            13,\n            14,\n            15,\n            16,\n            17,\n            18,\n            19,\n            19,\n            20,\n            21,\n            22,\n            24,\n            25\n        ],\n        [\n            -1,\n            1,\n            1,\n            1,\n            2,\n            2,\n            4,\n            4,\n            4,\n            5,\n            5,\n            5,\n            8,\n            9,\n            9,\n            10,\n            10,\n            11,\n            13,\n            14,\n            16,\n            17,\n            17,\n            18,\n            20,\n            21,\n            23,\n            25,\n            26,\n            28,\n            29,\n            31,\n            33,\n            35,\n            37,\n            38,\n            40,\n            43,\n            45,\n            47,\n            49\n        ],\n        [\n            -1,\n            1,\n            1,\n            2,\n            2,\n            4,\n            4,\n            6,\n            6,\n            8,\n            8,\n            8,\n            10,\n            12,\n            16,\n            12,\n            17,\n            16,\n            18,\n            21,\n            20,\n            23,\n            23,\n            25,\n            27,\n            29,\n            34,\n            34,\n            35,\n            38,\n            40,\n            43,\n            45,\n            48,\n            51,\n            53,\n            56,\n            59,\n            62,\n            65,\n            68\n        ],\n        [\n            -1,\n            1,\n            1,\n            2,\n            4,\n            4,\n            4,\n            5,\n            6,\n            8,\n            8,\n            11,\n            11,\n            16,\n            16,\n            18,\n            16,\n            19,\n            21,\n            25,\n            25,\n            25,\n            34,\n            30,\n            32,\n            35,\n            37,\n            40,\n            42,\n            45,\n            48,\n            51,\n            54,\n            57,\n            60,\n            63,\n            66,\n            70,\n            74,\n            77,\n            81\n        ]\n    ];\n    qrcodegen2.QrCode = QrCode;\n    function appendBits(val, len, bb) {\n        if (len < 0 || len > 31 || val >>> len != 0) throw new RangeError(\"Value out of range\");\n        for(let i = len - 1; i >= 0; i--)bb.push(val >>> i & 1);\n    }\n    function getBit(x, i) {\n        return (x >>> i & 1) != 0;\n    }\n    function assert(cond) {\n        if (!cond) throw new Error(\"Assertion error\");\n    }\n    const _QrSegment = class {\n        constructor(mode, numChars, bitData){\n            this.mode = mode;\n            this.numChars = numChars;\n            this.bitData = bitData;\n            if (numChars < 0) throw new RangeError(\"Invalid argument\");\n            this.bitData = bitData.slice();\n        }\n        static makeBytes(data) {\n            let bb = [];\n            for (const b of data)appendBits(b, 8, bb);\n            return new _QrSegment(_QrSegment.Mode.BYTE, data.length, bb);\n        }\n        static makeNumeric(digits) {\n            if (!_QrSegment.isNumeric(digits)) throw new RangeError(\"String contains non-numeric characters\");\n            let bb = [];\n            for(let i = 0; i < digits.length;){\n                const n = Math.min(digits.length - i, 3);\n                appendBits(parseInt(digits.substr(i, n), 10), n * 3 + 1, bb);\n                i += n;\n            }\n            return new _QrSegment(_QrSegment.Mode.NUMERIC, digits.length, bb);\n        }\n        static makeAlphanumeric(text) {\n            if (!_QrSegment.isAlphanumeric(text)) throw new RangeError(\"String contains unencodable characters in alphanumeric mode\");\n            let bb = [];\n            let i;\n            for(i = 0; i + 2 <= text.length; i += 2){\n                let temp = _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;\n                temp += _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));\n                appendBits(temp, 11, bb);\n            }\n            if (i < text.length) appendBits(_QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);\n            return new _QrSegment(_QrSegment.Mode.ALPHANUMERIC, text.length, bb);\n        }\n        static makeSegments(text) {\n            if (text == \"\") return [];\n            else if (_QrSegment.isNumeric(text)) return [\n                _QrSegment.makeNumeric(text)\n            ];\n            else if (_QrSegment.isAlphanumeric(text)) return [\n                _QrSegment.makeAlphanumeric(text)\n            ];\n            else return [\n                _QrSegment.makeBytes(_QrSegment.toUtf8ByteArray(text))\n            ];\n        }\n        static makeEci(assignVal) {\n            let bb = [];\n            if (assignVal < 0) throw new RangeError(\"ECI assignment value out of range\");\n            else if (assignVal < 1 << 7) appendBits(assignVal, 8, bb);\n            else if (assignVal < 1 << 14) {\n                appendBits(2, 2, bb);\n                appendBits(assignVal, 14, bb);\n            } else if (assignVal < 1e6) {\n                appendBits(6, 3, bb);\n                appendBits(assignVal, 21, bb);\n            } else throw new RangeError(\"ECI assignment value out of range\");\n            return new _QrSegment(_QrSegment.Mode.ECI, 0, bb);\n        }\n        static isNumeric(text) {\n            return _QrSegment.NUMERIC_REGEX.test(text);\n        }\n        static isAlphanumeric(text) {\n            return _QrSegment.ALPHANUMERIC_REGEX.test(text);\n        }\n        getData() {\n            return this.bitData.slice();\n        }\n        static getTotalBits(segs, version) {\n            let result = 0;\n            for (const seg of segs){\n                const ccbits = seg.mode.numCharCountBits(version);\n                if (seg.numChars >= 1 << ccbits) return Infinity;\n                result += 4 + ccbits + seg.bitData.length;\n            }\n            return result;\n        }\n        static toUtf8ByteArray(str) {\n            str = encodeURI(str);\n            let result = [];\n            for(let i = 0; i < str.length; i++){\n                if (str.charAt(i) != \"%\") result.push(str.charCodeAt(i));\n                else {\n                    result.push(parseInt(str.substr(i + 1, 2), 16));\n                    i += 2;\n                }\n            }\n            return result;\n        }\n    };\n    let QrSegment = _QrSegment;\n    QrSegment.NUMERIC_REGEX = /^[0-9]*$/;\n    QrSegment.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\\/:-]*$/;\n    QrSegment.ALPHANUMERIC_CHARSET = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:\";\n    qrcodegen2.QrSegment = QrSegment;\n})(qrcodegen || (qrcodegen = {}));\n((qrcodegen2)=>{\n    let QrCode;\n    ((QrCode2)=>{\n        const _Ecc = class {\n            constructor(ordinal, formatBits){\n                this.ordinal = ordinal;\n                this.formatBits = formatBits;\n            }\n        };\n        let Ecc = _Ecc;\n        Ecc.LOW = new _Ecc(0, 1);\n        Ecc.MEDIUM = new _Ecc(1, 0);\n        Ecc.QUARTILE = new _Ecc(2, 3);\n        Ecc.HIGH = new _Ecc(3, 2);\n        QrCode2.Ecc = Ecc;\n    })(QrCode = qrcodegen2.QrCode || (qrcodegen2.QrCode = {}));\n})(qrcodegen || (qrcodegen = {}));\n((qrcodegen2)=>{\n    let QrSegment;\n    ((QrSegment2)=>{\n        const _Mode = class {\n            constructor(modeBits, numBitsCharCount){\n                this.modeBits = modeBits;\n                this.numBitsCharCount = numBitsCharCount;\n            }\n            numCharCountBits(ver) {\n                return this.numBitsCharCount[Math.floor((ver + 7) / 17)];\n            }\n        };\n        let Mode = _Mode;\n        Mode.NUMERIC = new _Mode(1, [\n            10,\n            12,\n            14\n        ]);\n        Mode.ALPHANUMERIC = new _Mode(2, [\n            9,\n            11,\n            13\n        ]);\n        Mode.BYTE = new _Mode(4, [\n            8,\n            16,\n            16\n        ]);\n        Mode.KANJI = new _Mode(8, [\n            8,\n            10,\n            12\n        ]);\n        Mode.ECI = new _Mode(7, [\n            0,\n            0,\n            0\n        ]);\n        QrSegment2.Mode = Mode;\n    })(QrSegment = qrcodegen2.QrSegment || (qrcodegen2.QrSegment = {}));\n})(qrcodegen || (qrcodegen = {}));\nvar qrcodegen_default = qrcodegen;\n// src/index.tsx\n/**\n * @license qrcode.react\n * Copyright (c) Paul O'Shannessy\n * SPDX-License-Identifier: ISC\n */ var ERROR_LEVEL_MAP = {\n    L: qrcodegen_default.QrCode.Ecc.LOW,\n    M: qrcodegen_default.QrCode.Ecc.MEDIUM,\n    Q: qrcodegen_default.QrCode.Ecc.QUARTILE,\n    H: qrcodegen_default.QrCode.Ecc.HIGH\n};\nvar DEFAULT_SIZE = 128;\nvar DEFAULT_LEVEL = \"L\";\nvar DEFAULT_BGCOLOR = \"#FFFFFF\";\nvar DEFAULT_FGCOLOR = \"#000000\";\nvar DEFAULT_INCLUDEMARGIN = false;\nvar MARGIN_SIZE = 4;\nvar DEFAULT_IMG_SCALE = 0.1;\nfunction generatePath(modules, margin = 0) {\n    const ops = [];\n    modules.forEach(function(row, y) {\n        let start = null;\n        row.forEach(function(cell, x) {\n            if (!cell && start !== null) {\n                ops.push(`M${start + margin} ${y + margin}h${x - start}v1H${start + margin}z`);\n                start = null;\n                return;\n            }\n            if (x === row.length - 1) {\n                if (!cell) {\n                    return;\n                }\n                if (start === null) {\n                    ops.push(`M${x + margin},${y + margin} h1v1H${x + margin}z`);\n                } else {\n                    ops.push(`M${start + margin},${y + margin} h${x + 1 - start}v1H${start + margin}z`);\n                }\n                return;\n            }\n            if (cell && start === null) {\n                start = x;\n            }\n        });\n    });\n    return ops.join(\"\");\n}\nfunction excavateModules(modules, excavation) {\n    return modules.slice().map((row, y)=>{\n        if (y < excavation.y || y >= excavation.y + excavation.h) {\n            return row;\n        }\n        return row.map((cell, x)=>{\n            if (x < excavation.x || x >= excavation.x + excavation.w) {\n                return cell;\n            }\n            return false;\n        });\n    });\n}\nfunction getImageSettings(cells, size, includeMargin, imageSettings) {\n    if (imageSettings == null) {\n        return null;\n    }\n    const margin = includeMargin ? MARGIN_SIZE : 0;\n    const numCells = cells.length + margin * 2;\n    const defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);\n    const scale = numCells / size;\n    const w = (imageSettings.width || defaultSize) * scale;\n    const h = (imageSettings.height || defaultSize) * scale;\n    const x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;\n    const y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;\n    let excavation = null;\n    if (imageSettings.excavate) {\n        let floorX = Math.floor(x);\n        let floorY = Math.floor(y);\n        let ceilW = Math.ceil(w + x - floorX);\n        let ceilH = Math.ceil(h + y - floorY);\n        excavation = {\n            x: floorX,\n            y: floorY,\n            w: ceilW,\n            h: ceilH\n        };\n    }\n    return {\n        x,\n        y,\n        h,\n        w,\n        excavation\n    };\n}\nvar SUPPORTS_PATH2D = function() {\n    try {\n        new Path2D().addPath(new Path2D());\n    } catch (e) {\n        return false;\n    }\n    return true;\n}();\nfunction QRCodeCanvas(props) {\n    const _a = props, { value, size = DEFAULT_SIZE, level = DEFAULT_LEVEL, bgColor = DEFAULT_BGCOLOR, fgColor = DEFAULT_FGCOLOR, includeMargin = DEFAULT_INCLUDEMARGIN, style, imageSettings } = _a, otherProps = __objRest(_a, [\n        \"value\",\n        \"size\",\n        \"level\",\n        \"bgColor\",\n        \"fgColor\",\n        \"includeMargin\",\n        \"style\",\n        \"imageSettings\"\n    ]);\n    const imgSrc = imageSettings == null ? void 0 : imageSettings.src;\n    const _canvas = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const _image = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [isImgLoaded, setIsImageLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (_canvas.current != null) {\n            const canvas = _canvas.current;\n            const ctx = canvas.getContext(\"2d\");\n            if (!ctx) {\n                return;\n            }\n            let cells = qrcodegen_default.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();\n            const margin = includeMargin ? MARGIN_SIZE : 0;\n            const numCells = cells.length + margin * 2;\n            const calculatedImageSettings = getImageSettings(cells, size, includeMargin, imageSettings);\n            const image = _image.current;\n            const haveImageToRender = calculatedImageSettings != null && image !== null && image.complete && image.naturalHeight !== 0 && image.naturalWidth !== 0;\n            if (haveImageToRender) {\n                if (calculatedImageSettings.excavation != null) {\n                    cells = excavateModules(cells, calculatedImageSettings.excavation);\n                }\n            }\n            const pixelRatio = window.devicePixelRatio || 1;\n            canvas.height = canvas.width = size * pixelRatio;\n            const scale = size / numCells * pixelRatio;\n            ctx.scale(scale, scale);\n            ctx.fillStyle = bgColor;\n            ctx.fillRect(0, 0, numCells, numCells);\n            ctx.fillStyle = fgColor;\n            if (SUPPORTS_PATH2D) {\n                ctx.fill(new Path2D(generatePath(cells, margin)));\n            } else {\n                cells.forEach(function(row, rdx) {\n                    row.forEach(function(cell, cdx) {\n                        if (cell) {\n                            ctx.fillRect(cdx + margin, rdx + margin, 1, 1);\n                        }\n                    });\n                });\n            }\n            if (haveImageToRender) {\n                ctx.drawImage(image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);\n            }\n        }\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        setIsImageLoaded(false);\n    }, [\n        imgSrc\n    ]);\n    const canvasStyle = __spreadValues({\n        height: size,\n        width: size\n    }, style);\n    let img = null;\n    if (imgSrc != null) {\n        img = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"img\", {\n            src: imgSrc,\n            key: imgSrc,\n            style: {\n                display: \"none\"\n            },\n            onLoad: ()=>{\n                setIsImageLoaded(true);\n            },\n            ref: _image\n        });\n    }\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"canvas\", __spreadValues({\n        style: canvasStyle,\n        height: size,\n        width: size,\n        ref: _canvas\n    }, otherProps)), img);\n}\nfunction QRCodeSVG(props) {\n    const _a = props, { value, size = DEFAULT_SIZE, level = DEFAULT_LEVEL, bgColor = DEFAULT_BGCOLOR, fgColor = DEFAULT_FGCOLOR, includeMargin = DEFAULT_INCLUDEMARGIN, imageSettings } = _a, otherProps = __objRest(_a, [\n        \"value\",\n        \"size\",\n        \"level\",\n        \"bgColor\",\n        \"fgColor\",\n        \"includeMargin\",\n        \"imageSettings\"\n    ]);\n    let cells = qrcodegen_default.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();\n    const margin = includeMargin ? MARGIN_SIZE : 0;\n    const numCells = cells.length + margin * 2;\n    const calculatedImageSettings = getImageSettings(cells, size, includeMargin, imageSettings);\n    let image = null;\n    if (imageSettings != null && calculatedImageSettings != null) {\n        if (calculatedImageSettings.excavation != null) {\n            cells = excavateModules(cells, calculatedImageSettings.excavation);\n        }\n        image = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"image\", {\n            xlinkHref: imageSettings.src,\n            height: calculatedImageSettings.h,\n            width: calculatedImageSettings.w,\n            x: calculatedImageSettings.x + margin,\n            y: calculatedImageSettings.y + margin,\n            preserveAspectRatio: \"none\"\n        });\n    }\n    const fgPath = generatePath(cells, margin);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", __spreadValues({\n        height: size,\n        width: size,\n        viewBox: `0 0 ${numCells} ${numCells}`\n    }, otherProps), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n        fill: bgColor,\n        d: `M0,0 h${numCells}v${numCells}H0z`,\n        shapeRendering: \"crispEdges\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n        fill: fgColor,\n        d: fgPath,\n        shapeRendering: \"crispEdges\"\n    }), image);\n}\nvar QRCode = (props)=>{\n    const _a = props, { renderAs } = _a, otherProps = __objRest(_a, [\n        \"renderAs\"\n    ]);\n    if (renderAs === \"svg\") {\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(QRCodeSVG, __spreadValues({}, otherProps));\n    }\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(QRCodeCanvas, __spreadValues({}, otherProps));\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcXJjb2RlLnJlYWN0L2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxJQUFJQSxZQUFZQyxPQUFPQyxjQUFjO0FBQ3JDLElBQUlDLHNCQUFzQkYsT0FBT0cscUJBQXFCO0FBQ3RELElBQUlDLGVBQWVKLE9BQU9LLFNBQVMsQ0FBQ0MsY0FBYztBQUNsRCxJQUFJQyxlQUFlUCxPQUFPSyxTQUFTLENBQUNHLG9CQUFvQjtBQUN4RCxJQUFJQyxrQkFBa0IsQ0FBQ0MsS0FBS0MsS0FBS0MsUUFBVUQsT0FBT0QsTUFBTVgsVUFBVVcsS0FBS0MsS0FBSztRQUFFRSxZQUFZO1FBQU1DLGNBQWM7UUFBTUMsVUFBVTtRQUFNSDtJQUFNLEtBQUtGLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHQztBQUMxSixJQUFJSSxpQkFBaUIsQ0FBQ0MsR0FBR0M7SUFDdkIsSUFBSyxJQUFJQyxRQUFRRCxLQUFNQSxDQUFBQSxJQUFJLENBQUMsR0FDMUIsSUFBSWQsYUFBYWdCLElBQUksQ0FBQ0YsR0FBR0MsT0FDdkJWLGdCQUFnQlEsR0FBR0UsTUFBTUQsQ0FBQyxDQUFDQyxLQUFLO0lBQ3BDLElBQUlqQixxQkFDRixLQUFLLElBQUlpQixRQUFRakIsb0JBQW9CZ0IsR0FBSTtRQUN2QyxJQUFJWCxhQUFhYSxJQUFJLENBQUNGLEdBQUdDLE9BQ3ZCVixnQkFBZ0JRLEdBQUdFLE1BQU1ELENBQUMsQ0FBQ0MsS0FBSztJQUNwQztJQUNGLE9BQU9GO0FBQ1Q7QUFDQSxJQUFJSSxZQUFZLENBQUNDLFFBQVFDO0lBQ3ZCLElBQUlDLFNBQVMsQ0FBQztJQUNkLElBQUssSUFBSUwsUUFBUUcsT0FDZixJQUFJbEIsYUFBYWdCLElBQUksQ0FBQ0UsUUFBUUgsU0FBU0ksUUFBUUUsT0FBTyxDQUFDTixRQUFRLEdBQzdESyxNQUFNLENBQUNMLEtBQUssR0FBR0csTUFBTSxDQUFDSCxLQUFLO0lBQy9CLElBQUlHLFVBQVUsUUFBUXBCLHFCQUNwQixLQUFLLElBQUlpQixRQUFRakIsb0JBQW9Cb0IsUUFBUztRQUM1QyxJQUFJQyxRQUFRRSxPQUFPLENBQUNOLFFBQVEsS0FBS1osYUFBYWEsSUFBSSxDQUFDRSxRQUFRSCxPQUN6REssTUFBTSxDQUFDTCxLQUFLLEdBQUdHLE1BQU0sQ0FBQ0gsS0FBSztJQUMvQjtJQUNGLE9BQU9LO0FBQ1Q7QUFFQSxnQkFBZ0I7QUFDMkM7QUFFM0QscUNBQXFDO0FBQ3JDOzs7O0NBSUMsR0FDRCxJQUFJTTtBQUNILEVBQUNDO0lBQ0EsTUFBTUMsVUFBVTtRQUNkQyxZQUFZQyxPQUFPLEVBQUVDLG9CQUFvQixFQUFFQyxhQUFhLEVBQUVDLEdBQUcsQ0FBRTtZQUM3RCxJQUFJLENBQUNILE9BQU8sR0FBR0E7WUFDZixJQUFJLENBQUNDLG9CQUFvQixHQUFHQTtZQUM1QixJQUFJLENBQUNHLE9BQU8sR0FBRyxFQUFFO1lBQ2pCLElBQUksQ0FBQ0MsVUFBVSxHQUFHLEVBQUU7WUFDcEIsSUFBSUwsVUFBVUYsUUFBUVEsV0FBVyxJQUFJTixVQUFVRixRQUFRUyxXQUFXLEVBQ2hFLE1BQU0sSUFBSUMsV0FBVztZQUN2QixJQUFJTCxNQUFNLENBQUMsS0FBS0EsTUFBTSxHQUNwQixNQUFNLElBQUlLLFdBQVc7WUFDdkIsSUFBSSxDQUFDQyxJQUFJLEdBQUdULFVBQVUsSUFBSTtZQUMxQixJQUFJVSxNQUFNLEVBQUU7WUFDWixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNGLElBQUksRUFBRUUsSUFDN0JELElBQUlFLElBQUksQ0FBQztZQUNYLElBQUssSUFBSUQsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ0YsSUFBSSxFQUFFRSxJQUFLO2dCQUNsQyxJQUFJLENBQUNQLE9BQU8sQ0FBQ1EsSUFBSSxDQUFDRixJQUFJRyxLQUFLO2dCQUMzQixJQUFJLENBQUNSLFVBQVUsQ0FBQ08sSUFBSSxDQUFDRixJQUFJRyxLQUFLO1lBQ2hDO1lBQ0EsSUFBSSxDQUFDQyxvQkFBb0I7WUFDekIsTUFBTUMsZUFBZSxJQUFJLENBQUNDLG1CQUFtQixDQUFDZDtZQUM5QyxJQUFJLENBQUNlLGFBQWEsQ0FBQ0Y7WUFDbkIsSUFBSVosT0FBTyxDQUFDLEdBQUc7Z0JBQ2IsSUFBSWUsYUFBYTtnQkFDakIsSUFBSyxJQUFJUCxJQUFJLEdBQUdBLElBQUksR0FBR0EsSUFBSztvQkFDMUIsSUFBSSxDQUFDUSxTQUFTLENBQUNSO29CQUNmLElBQUksQ0FBQ1MsY0FBYyxDQUFDVDtvQkFDcEIsTUFBTVUsVUFBVSxJQUFJLENBQUNDLGVBQWU7b0JBQ3BDLElBQUlELFVBQVVILFlBQVk7d0JBQ3hCZixNQUFNUTt3QkFDTk8sYUFBYUc7b0JBQ2Y7b0JBQ0EsSUFBSSxDQUFDRixTQUFTLENBQUNSO2dCQUNqQjtZQUNGO1lBQ0FZLE9BQU8sS0FBS3BCLE9BQU9BLE9BQU87WUFDMUIsSUFBSSxDQUFDcUIsSUFBSSxHQUFHckI7WUFDWixJQUFJLENBQUNnQixTQUFTLENBQUNoQjtZQUNmLElBQUksQ0FBQ2lCLGNBQWMsQ0FBQ2pCO1lBQ3BCLElBQUksQ0FBQ0UsVUFBVSxHQUFHLEVBQUU7UUFDdEI7UUFDQSxPQUFPb0IsV0FBV0MsSUFBSSxFQUFFQyxHQUFHLEVBQUU7WUFDM0IsTUFBTUMsT0FBTy9CLFdBQVdnQyxTQUFTLENBQUNDLFlBQVksQ0FBQ0o7WUFDL0MsT0FBTzVCLFFBQVFpQyxjQUFjLENBQUNILE1BQU1EO1FBQ3RDO1FBQ0EsT0FBT0ssYUFBYUMsSUFBSSxFQUFFTixHQUFHLEVBQUU7WUFDN0IsTUFBTU8sTUFBTXJDLFdBQVdnQyxTQUFTLENBQUNNLFNBQVMsQ0FBQ0Y7WUFDM0MsT0FBT25DLFFBQVFpQyxjQUFjLENBQUM7Z0JBQUNHO2FBQUksRUFBRVA7UUFDdkM7UUFDQSxPQUFPSSxlQUFlSCxJQUFJLEVBQUVELEdBQUcsRUFBRVMsYUFBYSxDQUFDLEVBQUVDLGFBQWEsRUFBRSxFQUFFYixPQUFPLENBQUMsQ0FBQyxFQUFFYyxXQUFXLElBQUksRUFBRTtZQUM1RixJQUFJLENBQUV4QyxDQUFBQSxRQUFRUSxXQUFXLElBQUk4QixjQUFjQSxjQUFjQyxjQUFjQSxjQUFjdkMsUUFBUVMsV0FBVyxLQUFLaUIsT0FBTyxDQUFDLEtBQUtBLE9BQU8sR0FDL0gsTUFBTSxJQUFJaEIsV0FBVztZQUN2QixJQUFJUjtZQUNKLElBQUl1QztZQUNKLElBQUt2QyxVQUFVb0MsYUFBY3BDLFVBQVc7Z0JBQ3RDLE1BQU13QyxvQkFBb0IxQyxRQUFRMkMsbUJBQW1CLENBQUN6QyxTQUFTMkIsT0FBTztnQkFDdEUsTUFBTWUsV0FBV2IsVUFBVWMsWUFBWSxDQUFDZixNQUFNNUI7Z0JBQzlDLElBQUkwQyxZQUFZRixtQkFBbUI7b0JBQ2pDRCxlQUFlRztvQkFDZjtnQkFDRjtnQkFDQSxJQUFJMUMsV0FBV3FDLFlBQ2IsTUFBTSxJQUFJN0IsV0FBVztZQUN6QjtZQUNBLEtBQUssTUFBTW9DLFVBQVU7Z0JBQUM5QyxRQUFRK0MsR0FBRyxDQUFDQyxNQUFNO2dCQUFFaEQsUUFBUStDLEdBQUcsQ0FBQ0UsUUFBUTtnQkFBRWpELFFBQVErQyxHQUFHLENBQUNHLElBQUk7YUFBQyxDQUFFO2dCQUNqRixJQUFJVixZQUFZQyxnQkFBZ0J6QyxRQUFRMkMsbUJBQW1CLENBQUN6QyxTQUFTNEMsVUFBVSxHQUM3RWpCLE1BQU1pQjtZQUNWO1lBQ0EsSUFBSUssS0FBSyxFQUFFO1lBQ1gsS0FBSyxNQUFNZixPQUFPTixLQUFNO2dCQUN0QnNCLFdBQVdoQixJQUFJaUIsSUFBSSxDQUFDQyxRQUFRLEVBQUUsR0FBR0g7Z0JBQ2pDQyxXQUFXaEIsSUFBSW1CLFFBQVEsRUFBRW5CLElBQUlpQixJQUFJLENBQUNHLGdCQUFnQixDQUFDdEQsVUFBVWlEO2dCQUM3RCxLQUFLLE1BQU1qRSxLQUFLa0QsSUFBSXFCLE9BQU8sR0FDekJOLEdBQUdyQyxJQUFJLENBQUM1QjtZQUNaO1lBQ0F1QyxPQUFPMEIsR0FBR08sTUFBTSxJQUFJakI7WUFDcEIsTUFBTWtCLG1CQUFtQjNELFFBQVEyQyxtQkFBbUIsQ0FBQ3pDLFNBQVMyQixPQUFPO1lBQ3JFSixPQUFPMEIsR0FBR08sTUFBTSxJQUFJQztZQUNwQlAsV0FBVyxHQUFHUSxLQUFLQyxHQUFHLENBQUMsR0FBR0YsbUJBQW1CUixHQUFHTyxNQUFNLEdBQUdQO1lBQ3pEQyxXQUFXLEdBQUcsQ0FBQyxJQUFJRCxHQUFHTyxNQUFNLEdBQUcsS0FBSyxHQUFHUDtZQUN2QzFCLE9BQU8wQixHQUFHTyxNQUFNLEdBQUcsS0FBSztZQUN4QixJQUFLLElBQUlJLFVBQVUsS0FBS1gsR0FBR08sTUFBTSxHQUFHQyxrQkFBa0JHLFdBQVcsTUFBTSxHQUNyRVYsV0FBV1UsU0FBUyxHQUFHWDtZQUN6QixJQUFJL0MsZ0JBQWdCLEVBQUU7WUFDdEIsTUFBT0EsY0FBY3NELE1BQU0sR0FBRyxJQUFJUCxHQUFHTyxNQUFNLENBQ3pDdEQsY0FBY1UsSUFBSSxDQUFDO1lBQ3JCcUMsR0FBR1ksT0FBTyxDQUFDLENBQUM3RSxHQUFHMkIsSUFBTVQsYUFBYSxDQUFDUyxNQUFNLEVBQUUsSUFBSTNCLEtBQUssSUFBSzJCLENBQUFBLElBQUk7WUFDN0QsT0FBTyxJQUFJYixRQUFRRSxTQUFTMkIsS0FBS3pCLGVBQWVzQjtRQUNsRDtRQUNBc0MsVUFBVUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7WUFDZCxPQUFPLEtBQUtELEtBQUtBLElBQUksSUFBSSxDQUFDdEQsSUFBSSxJQUFJLEtBQUt1RCxLQUFLQSxJQUFJLElBQUksQ0FBQ3ZELElBQUksSUFBSSxJQUFJLENBQUNMLE9BQU8sQ0FBQzRELEVBQUUsQ0FBQ0QsRUFBRTtRQUNqRjtRQUNBRSxhQUFhO1lBQ1gsT0FBTyxJQUFJLENBQUM3RCxPQUFPO1FBQ3JCO1FBQ0FVLHVCQUF1QjtZQUNyQixJQUFLLElBQUlILElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNGLElBQUksRUFBRUUsSUFBSztnQkFDbEMsSUFBSSxDQUFDdUQsaUJBQWlCLENBQUMsR0FBR3ZELEdBQUdBLElBQUksS0FBSztnQkFDdEMsSUFBSSxDQUFDdUQsaUJBQWlCLENBQUN2RCxHQUFHLEdBQUdBLElBQUksS0FBSztZQUN4QztZQUNBLElBQUksQ0FBQ3dELGlCQUFpQixDQUFDLEdBQUc7WUFDMUIsSUFBSSxDQUFDQSxpQkFBaUIsQ0FBQyxJQUFJLENBQUMxRCxJQUFJLEdBQUcsR0FBRztZQUN0QyxJQUFJLENBQUMwRCxpQkFBaUIsQ0FBQyxHQUFHLElBQUksQ0FBQzFELElBQUksR0FBRztZQUN0QyxNQUFNMkQsY0FBYyxJQUFJLENBQUNDLDRCQUE0QjtZQUNyRCxNQUFNQyxXQUFXRixZQUFZWixNQUFNO1lBQ25DLElBQUssSUFBSTdDLElBQUksR0FBR0EsSUFBSTJELFVBQVUzRCxJQUFLO2dCQUNqQyxJQUFLLElBQUk0RCxJQUFJLEdBQUdBLElBQUlELFVBQVVDLElBQUs7b0JBQ2pDLElBQUksQ0FBRTVELENBQUFBLEtBQUssS0FBSzRELEtBQUssS0FBSzVELEtBQUssS0FBSzRELEtBQUtELFdBQVcsS0FBSzNELEtBQUsyRCxXQUFXLEtBQUtDLEtBQUssSUFDakYsSUFBSSxDQUFDQyxvQkFBb0IsQ0FBQ0osV0FBVyxDQUFDekQsRUFBRSxFQUFFeUQsV0FBVyxDQUFDRyxFQUFFO2dCQUM1RDtZQUNGO1lBQ0EsSUFBSSxDQUFDbkQsY0FBYyxDQUFDO1lBQ3BCLElBQUksQ0FBQ3FELFdBQVc7UUFDbEI7UUFDQXJELGVBQWVJLElBQUksRUFBRTtZQUNuQixNQUFNUyxPQUFPLElBQUksQ0FBQ2hDLG9CQUFvQixDQUFDeUUsVUFBVSxJQUFJLElBQUlsRDtZQUN6RCxJQUFJbUQsTUFBTTFDO1lBQ1YsSUFBSyxJQUFJdEIsSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQ3RCZ0UsTUFBTUEsT0FBTyxJQUFJLENBQUNBLFFBQVEsS0FBSztZQUNqQyxNQUFNQyxPQUFPLENBQUMzQyxRQUFRLEtBQUswQyxHQUFFLElBQUs7WUFDbENwRCxPQUFPcUQsU0FBUyxNQUFNO1lBQ3RCLElBQUssSUFBSWpFLElBQUksR0FBR0EsS0FBSyxHQUFHQSxJQUN0QixJQUFJLENBQUN1RCxpQkFBaUIsQ0FBQyxHQUFHdkQsR0FBR2tFLE9BQU9ELE1BQU1qRTtZQUM1QyxJQUFJLENBQUN1RCxpQkFBaUIsQ0FBQyxHQUFHLEdBQUdXLE9BQU9ELE1BQU07WUFDMUMsSUFBSSxDQUFDVixpQkFBaUIsQ0FBQyxHQUFHLEdBQUdXLE9BQU9ELE1BQU07WUFDMUMsSUFBSSxDQUFDVixpQkFBaUIsQ0FBQyxHQUFHLEdBQUdXLE9BQU9ELE1BQU07WUFDMUMsSUFBSyxJQUFJakUsSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQ3RCLElBQUksQ0FBQ3VELGlCQUFpQixDQUFDLEtBQUt2RCxHQUFHLEdBQUdrRSxPQUFPRCxNQUFNakU7WUFDakQsSUFBSyxJQUFJQSxJQUFJLEdBQUdBLElBQUksR0FBR0EsSUFDckIsSUFBSSxDQUFDdUQsaUJBQWlCLENBQUMsSUFBSSxDQUFDekQsSUFBSSxHQUFHLElBQUlFLEdBQUcsR0FBR2tFLE9BQU9ELE1BQU1qRTtZQUM1RCxJQUFLLElBQUlBLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUN0QixJQUFJLENBQUN1RCxpQkFBaUIsQ0FBQyxHQUFHLElBQUksQ0FBQ3pELElBQUksR0FBRyxLQUFLRSxHQUFHa0UsT0FBT0QsTUFBTWpFO1lBQzdELElBQUksQ0FBQ3VELGlCQUFpQixDQUFDLEdBQUcsSUFBSSxDQUFDekQsSUFBSSxHQUFHLEdBQUc7UUFDM0M7UUFDQWdFLGNBQWM7WUFDWixJQUFJLElBQUksQ0FBQ3pFLE9BQU8sR0FBRyxHQUNqQjtZQUNGLElBQUkyRSxNQUFNLElBQUksQ0FBQzNFLE9BQU87WUFDdEIsSUFBSyxJQUFJVyxJQUFJLEdBQUdBLElBQUksSUFBSUEsSUFDdEJnRSxNQUFNQSxPQUFPLElBQUksQ0FBQ0EsUUFBUSxFQUFDLElBQUs7WUFDbEMsTUFBTUMsT0FBTyxJQUFJLENBQUM1RSxPQUFPLElBQUksS0FBSzJFO1lBQ2xDcEQsT0FBT3FELFNBQVMsTUFBTTtZQUN0QixJQUFLLElBQUlqRSxJQUFJLEdBQUdBLElBQUksSUFBSUEsSUFBSztnQkFDM0IsTUFBTW1FLFFBQVFELE9BQU9ELE1BQU1qRTtnQkFDM0IsTUFBTTVCLElBQUksSUFBSSxDQUFDMEIsSUFBSSxHQUFHLEtBQUtFLElBQUk7Z0JBQy9CLE1BQU0zQixJQUFJMEUsS0FBS3FCLEtBQUssQ0FBQ3BFLElBQUk7Z0JBQ3pCLElBQUksQ0FBQ3VELGlCQUFpQixDQUFDbkYsR0FBR0MsR0FBRzhGO2dCQUM3QixJQUFJLENBQUNaLGlCQUFpQixDQUFDbEYsR0FBR0QsR0FBRytGO1lBQy9CO1FBQ0Y7UUFDQVgsa0JBQWtCSixDQUFDLEVBQUVDLENBQUMsRUFBRTtZQUN0QixJQUFLLElBQUlnQixLQUFLLENBQUMsR0FBR0EsTUFBTSxHQUFHQSxLQUFNO2dCQUMvQixJQUFLLElBQUlDLEtBQUssQ0FBQyxHQUFHQSxNQUFNLEdBQUdBLEtBQU07b0JBQy9CLE1BQU1DLE9BQU94QixLQUFLeUIsR0FBRyxDQUFDekIsS0FBSzBCLEdBQUcsQ0FBQ0gsS0FBS3ZCLEtBQUswQixHQUFHLENBQUNKO29CQUM3QyxNQUFNSyxLQUFLdEIsSUFBSWtCO29CQUNmLE1BQU1LLEtBQUt0QixJQUFJZ0I7b0JBQ2YsSUFBSSxLQUFLSyxNQUFNQSxLQUFLLElBQUksQ0FBQzVFLElBQUksSUFBSSxLQUFLNkUsTUFBTUEsS0FBSyxJQUFJLENBQUM3RSxJQUFJLEVBQ3hELElBQUksQ0FBQ3lELGlCQUFpQixDQUFDbUIsSUFBSUMsSUFBSUosUUFBUSxLQUFLQSxRQUFRO2dCQUN4RDtZQUNGO1FBQ0Y7UUFDQVYscUJBQXFCVCxDQUFDLEVBQUVDLENBQUMsRUFBRTtZQUN6QixJQUFLLElBQUlnQixLQUFLLENBQUMsR0FBR0EsTUFBTSxHQUFHQSxLQUFNO2dCQUMvQixJQUFLLElBQUlDLEtBQUssQ0FBQyxHQUFHQSxNQUFNLEdBQUdBLEtBQ3pCLElBQUksQ0FBQ2YsaUJBQWlCLENBQUNILElBQUlrQixJQUFJakIsSUFBSWdCLElBQUl0QixLQUFLeUIsR0FBRyxDQUFDekIsS0FBSzBCLEdBQUcsQ0FBQ0gsS0FBS3ZCLEtBQUswQixHQUFHLENBQUNKLFFBQVE7WUFDbkY7UUFDRjtRQUNBZCxrQkFBa0JILENBQUMsRUFBRUMsQ0FBQyxFQUFFdUIsTUFBTSxFQUFFO1lBQzlCLElBQUksQ0FBQ25GLE9BQU8sQ0FBQzRELEVBQUUsQ0FBQ0QsRUFBRSxHQUFHd0I7WUFDckIsSUFBSSxDQUFDbEYsVUFBVSxDQUFDMkQsRUFBRSxDQUFDRCxFQUFFLEdBQUc7UUFDMUI7UUFDQS9DLG9CQUFvQmlCLElBQUksRUFBRTtZQUN4QixNQUFNdUQsTUFBTSxJQUFJLENBQUN4RixPQUFPO1lBQ3hCLE1BQU0yQixNQUFNLElBQUksQ0FBQzFCLG9CQUFvQjtZQUNyQyxJQUFJZ0MsS0FBS3VCLE1BQU0sSUFBSTFELFFBQVEyQyxtQkFBbUIsQ0FBQytDLEtBQUs3RCxNQUNsRCxNQUFNLElBQUluQixXQUFXO1lBQ3ZCLE1BQU1pRixZQUFZM0YsUUFBUTRGLDJCQUEyQixDQUFDL0QsSUFBSWdFLE9BQU8sQ0FBQyxDQUFDSCxJQUFJO1lBQ3ZFLE1BQU1JLGNBQWM5RixRQUFRK0YsdUJBQXVCLENBQUNsRSxJQUFJZ0UsT0FBTyxDQUFDLENBQUNILElBQUk7WUFDckUsTUFBTU0sZUFBZXBDLEtBQUtxQixLQUFLLENBQUNqRixRQUFRaUcsb0JBQW9CLENBQUNQLE9BQU87WUFDcEUsTUFBTVEsaUJBQWlCUCxZQUFZSyxlQUFlTDtZQUNsRCxNQUFNUSxnQkFBZ0J2QyxLQUFLcUIsS0FBSyxDQUFDZSxlQUFlTDtZQUNoRCxJQUFJUyxTQUFTLEVBQUU7WUFDZixNQUFNQyxRQUFRckcsUUFBUXNHLHlCQUF5QixDQUFDUjtZQUNoRCxJQUFLLElBQUlqRixJQUFJLEdBQUcwRixJQUFJLEdBQUcxRixJQUFJOEUsV0FBVzlFLElBQUs7Z0JBQ3pDLElBQUkyRixNQUFNckUsS0FBS3BCLEtBQUssQ0FBQ3dGLEdBQUdBLElBQUlKLGdCQUFnQkwsY0FBZWpGLENBQUFBLElBQUlxRixpQkFBaUIsSUFBSTtnQkFDcEZLLEtBQUtDLElBQUk5QyxNQUFNO2dCQUNmLE1BQU0rQyxNQUFNekcsUUFBUTBHLDJCQUEyQixDQUFDRixLQUFLSDtnQkFDckQsSUFBSXhGLElBQUlxRixnQkFDTk0sSUFBSTFGLElBQUksQ0FBQztnQkFDWHNGLE9BQU90RixJQUFJLENBQUMwRixJQUFJRyxNQUFNLENBQUNGO1lBQ3pCO1lBQ0EsSUFBSUcsU0FBUyxFQUFFO1lBQ2YsSUFBSyxJQUFJL0YsSUFBSSxHQUFHQSxJQUFJdUYsTUFBTSxDQUFDLEVBQUUsQ0FBQzFDLE1BQU0sRUFBRTdDLElBQUs7Z0JBQ3pDdUYsT0FBT3JDLE9BQU8sQ0FBQyxDQUFDOEMsT0FBT3BDO29CQUNyQixJQUFJNUQsS0FBS3NGLGdCQUFnQkwsZUFBZXJCLEtBQUt5QixnQkFDM0NVLE9BQU85RixJQUFJLENBQUMrRixLQUFLLENBQUNoRyxFQUFFO2dCQUN4QjtZQUNGO1lBQ0FZLE9BQU9tRixPQUFPbEQsTUFBTSxJQUFJc0M7WUFDeEIsT0FBT1k7UUFDVDtRQUNBekYsY0FBY2dCLElBQUksRUFBRTtZQUNsQixJQUFJQSxLQUFLdUIsTUFBTSxJQUFJRSxLQUFLcUIsS0FBSyxDQUFDakYsUUFBUWlHLG9CQUFvQixDQUFDLElBQUksQ0FBQy9GLE9BQU8sSUFBSSxJQUN6RSxNQUFNLElBQUlRLFdBQVc7WUFDdkIsSUFBSUcsSUFBSTtZQUNSLElBQUssSUFBSWlHLFFBQVEsSUFBSSxDQUFDbkcsSUFBSSxHQUFHLEdBQUdtRyxTQUFTLEdBQUdBLFNBQVMsRUFBRztnQkFDdEQsSUFBSUEsU0FBUyxHQUNYQSxRQUFRO2dCQUNWLElBQUssSUFBSUMsT0FBTyxHQUFHQSxPQUFPLElBQUksQ0FBQ3BHLElBQUksRUFBRW9HLE9BQVE7b0JBQzNDLElBQUssSUFBSXRDLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO3dCQUMxQixNQUFNUixJQUFJNkMsUUFBUXJDO3dCQUNsQixNQUFNdUMsU0FBUyxDQUFDRixRQUFRLElBQUksTUFBTTt3QkFDbEMsTUFBTTVDLElBQUk4QyxTQUFTLElBQUksQ0FBQ3JHLElBQUksR0FBRyxJQUFJb0csT0FBT0E7d0JBQzFDLElBQUksQ0FBQyxJQUFJLENBQUN4RyxVQUFVLENBQUMyRCxFQUFFLENBQUNELEVBQUUsSUFBSXBELElBQUlzQixLQUFLdUIsTUFBTSxHQUFHLEdBQUc7NEJBQ2pELElBQUksQ0FBQ3BELE9BQU8sQ0FBQzRELEVBQUUsQ0FBQ0QsRUFBRSxHQUFHYyxPQUFPNUMsSUFBSSxDQUFDdEIsTUFBTSxFQUFFLEVBQUUsSUFBS0EsQ0FBQUEsSUFBSTs0QkFDcERBO3dCQUNGO29CQUNGO2dCQUNGO1lBQ0Y7WUFDQVksT0FBT1osS0FBS3NCLEtBQUt1QixNQUFNLEdBQUc7UUFDNUI7UUFDQXJDLFVBQVVLLElBQUksRUFBRTtZQUNkLElBQUlBLE9BQU8sS0FBS0EsT0FBTyxHQUNyQixNQUFNLElBQUloQixXQUFXO1lBQ3ZCLElBQUssSUFBSXdELElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUN2RCxJQUFJLEVBQUV1RCxJQUFLO2dCQUNsQyxJQUFLLElBQUlELElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUN0RCxJQUFJLEVBQUVzRCxJQUFLO29CQUNsQyxJQUFJZ0Q7b0JBQ0osT0FBUXZGO3dCQUNOLEtBQUs7NEJBQ0h1RixTQUFTLENBQUNoRCxJQUFJQyxDQUFBQSxJQUFLLEtBQUs7NEJBQ3hCO3dCQUNGLEtBQUs7NEJBQ0grQyxTQUFTL0MsSUFBSSxLQUFLOzRCQUNsQjt3QkFDRixLQUFLOzRCQUNIK0MsU0FBU2hELElBQUksS0FBSzs0QkFDbEI7d0JBQ0YsS0FBSzs0QkFDSGdELFNBQVMsQ0FBQ2hELElBQUlDLENBQUFBLElBQUssS0FBSzs0QkFDeEI7d0JBQ0YsS0FBSzs0QkFDSCtDLFNBQVMsQ0FBQ3JELEtBQUtxQixLQUFLLENBQUNoQixJQUFJLEtBQUtMLEtBQUtxQixLQUFLLENBQUNmLElBQUksRUFBQyxJQUFLLEtBQUs7NEJBQ3hEO3dCQUNGLEtBQUs7NEJBQ0grQyxTQUFTaEQsSUFBSUMsSUFBSSxJQUFJRCxJQUFJQyxJQUFJLEtBQUs7NEJBQ2xDO3dCQUNGLEtBQUs7NEJBQ0grQyxTQUFTLENBQUNoRCxJQUFJQyxJQUFJLElBQUlELElBQUlDLElBQUksS0FBSyxLQUFLOzRCQUN4Qzt3QkFDRixLQUFLOzRCQUNIK0MsU0FBUyxDQUFDLENBQUNoRCxJQUFJQyxDQUFBQSxJQUFLLElBQUlELElBQUlDLElBQUksS0FBSyxLQUFLOzRCQUMxQzt3QkFDRjs0QkFDRSxNQUFNLElBQUlnRCxNQUFNO29CQUNwQjtvQkFDQSxJQUFJLENBQUMsSUFBSSxDQUFDM0csVUFBVSxDQUFDMkQsRUFBRSxDQUFDRCxFQUFFLElBQUlnRCxRQUM1QixJQUFJLENBQUMzRyxPQUFPLENBQUM0RCxFQUFFLENBQUNELEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQzNELE9BQU8sQ0FBQzRELEVBQUUsQ0FBQ0QsRUFBRTtnQkFDNUM7WUFDRjtRQUNGO1FBQ0F6QyxrQkFBa0I7WUFDaEIsSUFBSW9GLFNBQVM7WUFDYixJQUFLLElBQUkxQyxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDdkQsSUFBSSxFQUFFdUQsSUFBSztnQkFDbEMsSUFBSWlELFdBQVc7Z0JBQ2YsSUFBSUMsT0FBTztnQkFDWCxJQUFJQyxhQUFhO29CQUFDO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO2lCQUFFO2dCQUN0QyxJQUFLLElBQUlwRCxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDdEQsSUFBSSxFQUFFc0QsSUFBSztvQkFDbEMsSUFBSSxJQUFJLENBQUMzRCxPQUFPLENBQUM0RCxFQUFFLENBQUNELEVBQUUsSUFBSWtELFVBQVU7d0JBQ2xDQzt3QkFDQSxJQUFJQSxRQUFRLEdBQ1ZSLFVBQVU1RyxRQUFRc0gsVUFBVTs2QkFDekIsSUFBSUYsT0FBTyxHQUNkUjtvQkFDSixPQUFPO3dCQUNMLElBQUksQ0FBQ1csdUJBQXVCLENBQUNILE1BQU1DO3dCQUNuQyxJQUFJLENBQUNGLFVBQ0hQLFVBQVUsSUFBSSxDQUFDWSwwQkFBMEIsQ0FBQ0gsY0FBY3JILFFBQVF5SCxVQUFVO3dCQUM1RU4sV0FBVyxJQUFJLENBQUM3RyxPQUFPLENBQUM0RCxFQUFFLENBQUNELEVBQUU7d0JBQzdCbUQsT0FBTztvQkFDVDtnQkFDRjtnQkFDQVIsVUFBVSxJQUFJLENBQUNjLDhCQUE4QixDQUFDUCxVQUFVQyxNQUFNQyxjQUFjckgsUUFBUXlILFVBQVU7WUFDaEc7WUFDQSxJQUFLLElBQUl4RCxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDdEQsSUFBSSxFQUFFc0QsSUFBSztnQkFDbEMsSUFBSWtELFdBQVc7Z0JBQ2YsSUFBSVEsT0FBTztnQkFDWCxJQUFJTixhQUFhO29CQUFDO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO2lCQUFFO2dCQUN0QyxJQUFLLElBQUluRCxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDdkQsSUFBSSxFQUFFdUQsSUFBSztvQkFDbEMsSUFBSSxJQUFJLENBQUM1RCxPQUFPLENBQUM0RCxFQUFFLENBQUNELEVBQUUsSUFBSWtELFVBQVU7d0JBQ2xDUTt3QkFDQSxJQUFJQSxRQUFRLEdBQ1ZmLFVBQVU1RyxRQUFRc0gsVUFBVTs2QkFDekIsSUFBSUssT0FBTyxHQUNkZjtvQkFDSixPQUFPO3dCQUNMLElBQUksQ0FBQ1csdUJBQXVCLENBQUNJLE1BQU1OO3dCQUNuQyxJQUFJLENBQUNGLFVBQ0hQLFVBQVUsSUFBSSxDQUFDWSwwQkFBMEIsQ0FBQ0gsY0FBY3JILFFBQVF5SCxVQUFVO3dCQUM1RU4sV0FBVyxJQUFJLENBQUM3RyxPQUFPLENBQUM0RCxFQUFFLENBQUNELEVBQUU7d0JBQzdCMEQsT0FBTztvQkFDVDtnQkFDRjtnQkFDQWYsVUFBVSxJQUFJLENBQUNjLDhCQUE4QixDQUFDUCxVQUFVUSxNQUFNTixjQUFjckgsUUFBUXlILFVBQVU7WUFDaEc7WUFDQSxJQUFLLElBQUl2RCxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDdkQsSUFBSSxHQUFHLEdBQUd1RCxJQUFLO2dCQUN0QyxJQUFLLElBQUlELElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUN0RCxJQUFJLEdBQUcsR0FBR3NELElBQUs7b0JBQ3RDLE1BQU1lLFFBQVEsSUFBSSxDQUFDMUUsT0FBTyxDQUFDNEQsRUFBRSxDQUFDRCxFQUFFO29CQUNoQyxJQUFJZSxTQUFTLElBQUksQ0FBQzFFLE9BQU8sQ0FBQzRELEVBQUUsQ0FBQ0QsSUFBSSxFQUFFLElBQUllLFNBQVMsSUFBSSxDQUFDMUUsT0FBTyxDQUFDNEQsSUFBSSxFQUFFLENBQUNELEVBQUUsSUFBSWUsU0FBUyxJQUFJLENBQUMxRSxPQUFPLENBQUM0RCxJQUFJLEVBQUUsQ0FBQ0QsSUFBSSxFQUFFLEVBQzNHMkMsVUFBVTVHLFFBQVE0SCxVQUFVO2dCQUNoQztZQUNGO1lBQ0EsSUFBSUMsT0FBTztZQUNYLEtBQUssTUFBTWpILE9BQU8sSUFBSSxDQUFDTixPQUFPLENBQzVCdUgsT0FBT2pILElBQUlrSCxNQUFNLENBQUMsQ0FBQ0MsS0FBSy9DLFFBQVUrQyxNQUFPL0MsQ0FBQUEsUUFBUSxJQUFJLElBQUk2QztZQUMzRCxNQUFNRyxRQUFRLElBQUksQ0FBQ3JILElBQUksR0FBRyxJQUFJLENBQUNBLElBQUk7WUFDbkMsTUFBTTRGLElBQUkzQyxLQUFLcUUsSUFBSSxDQUFDckUsS0FBSzBCLEdBQUcsQ0FBQ3VDLE9BQU8sS0FBS0csUUFBUSxNQUFNQSxTQUFTO1lBQ2hFdkcsT0FBTyxLQUFLOEUsS0FBS0EsS0FBSztZQUN0QkssVUFBVUwsSUFBSXZHLFFBQVFrSSxVQUFVO1lBQ2hDekcsT0FBTyxLQUFLbUYsVUFBVUEsVUFBVTtZQUNoQyxPQUFPQTtRQUNUO1FBQ0FyQywrQkFBK0I7WUFDN0IsSUFBSSxJQUFJLENBQUNyRSxPQUFPLElBQUksR0FDbEIsT0FBTyxFQUFFO2lCQUNOO2dCQUNILE1BQU1zRSxXQUFXWixLQUFLcUIsS0FBSyxDQUFDLElBQUksQ0FBQy9FLE9BQU8sR0FBRyxLQUFLO2dCQUNoRCxNQUFNaUksT0FBTyxJQUFJLENBQUNqSSxPQUFPLElBQUksS0FBSyxLQUFLMEQsS0FBS3FFLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQy9ILE9BQU8sR0FBRyxJQUFJLEtBQU1zRSxDQUFBQSxXQUFXLElBQUksTUFBTTtnQkFDaEcsSUFBSW9DLFNBQVM7b0JBQUM7aUJBQUU7Z0JBQ2hCLElBQUssSUFBSXdCLE1BQU0sSUFBSSxDQUFDekgsSUFBSSxHQUFHLEdBQUdpRyxPQUFPbEQsTUFBTSxHQUFHYyxVQUFVNEQsT0FBT0QsS0FDN0R2QixPQUFPeUIsTUFBTSxDQUFDLEdBQUcsR0FBR0Q7Z0JBQ3RCLE9BQU94QjtZQUNUO1FBQ0Y7UUFDQSxPQUFPWCxxQkFBcUJQLEdBQUcsRUFBRTtZQUMvQixJQUFJQSxNQUFNMUYsUUFBUVEsV0FBVyxJQUFJa0YsTUFBTTFGLFFBQVFTLFdBQVcsRUFDeEQsTUFBTSxJQUFJQyxXQUFXO1lBQ3ZCLElBQUlrRyxTQUFTLENBQUMsS0FBS2xCLE1BQU0sR0FBRSxJQUFLQSxNQUFNO1lBQ3RDLElBQUlBLE9BQU8sR0FBRztnQkFDWixNQUFNbEIsV0FBV1osS0FBS3FCLEtBQUssQ0FBQ1MsTUFBTSxLQUFLO2dCQUN2Q2tCLFVBQVUsQ0FBQyxLQUFLcEMsV0FBVyxFQUFDLElBQUtBLFdBQVc7Z0JBQzVDLElBQUlrQixPQUFPLEdBQ1RrQixVQUFVO1lBQ2Q7WUFDQW5GLE9BQU8sT0FBT21GLFVBQVVBLFVBQVU7WUFDbEMsT0FBT0E7UUFDVDtRQUNBLE9BQU9qRSxvQkFBb0IrQyxHQUFHLEVBQUU3RCxHQUFHLEVBQUU7WUFDbkMsT0FBTytCLEtBQUtxQixLQUFLLENBQUNqRixRQUFRaUcsb0JBQW9CLENBQUNQLE9BQU8sS0FBSzFGLFFBQVErRix1QkFBdUIsQ0FBQ2xFLElBQUlnRSxPQUFPLENBQUMsQ0FBQ0gsSUFBSSxHQUFHMUYsUUFBUTRGLDJCQUEyQixDQUFDL0QsSUFBSWdFLE9BQU8sQ0FBQyxDQUFDSCxJQUFJO1FBQ3RLO1FBQ0EsT0FBT1ksMEJBQTBCZ0MsTUFBTSxFQUFFO1lBQ3ZDLElBQUlBLFNBQVMsS0FBS0EsU0FBUyxLQUN6QixNQUFNLElBQUk1SCxXQUFXO1lBQ3ZCLElBQUlrRyxTQUFTLEVBQUU7WUFDZixJQUFLLElBQUkvRixJQUFJLEdBQUdBLElBQUl5SCxTQUFTLEdBQUd6SCxJQUM5QitGLE9BQU85RixJQUFJLENBQUM7WUFDZDhGLE9BQU85RixJQUFJLENBQUM7WUFDWixJQUFJeUgsT0FBTztZQUNYLElBQUssSUFBSTFILElBQUksR0FBR0EsSUFBSXlILFFBQVF6SCxJQUFLO2dCQUMvQixJQUFLLElBQUk0RCxJQUFJLEdBQUdBLElBQUltQyxPQUFPbEQsTUFBTSxFQUFFZSxJQUFLO29CQUN0Q21DLE1BQU0sQ0FBQ25DLEVBQUUsR0FBR3pFLFFBQVF3SSxtQkFBbUIsQ0FBQzVCLE1BQU0sQ0FBQ25DLEVBQUUsRUFBRThEO29CQUNuRCxJQUFJOUQsSUFBSSxJQUFJbUMsT0FBT2xELE1BQU0sRUFDdkJrRCxNQUFNLENBQUNuQyxFQUFFLElBQUltQyxNQUFNLENBQUNuQyxJQUFJLEVBQUU7Z0JBQzlCO2dCQUNBOEQsT0FBT3ZJLFFBQVF3SSxtQkFBbUIsQ0FBQ0QsTUFBTTtZQUMzQztZQUNBLE9BQU8zQjtRQUNUO1FBQ0EsT0FBT0YsNEJBQTRCdkUsSUFBSSxFQUFFc0csT0FBTyxFQUFFO1lBQ2hELElBQUk3QixTQUFTNkIsUUFBUUMsR0FBRyxDQUFDLENBQUNDLElBQU07WUFDaEMsS0FBSyxNQUFNekosS0FBS2lELEtBQU07Z0JBQ3BCLE1BQU15RyxTQUFTMUosSUFBSTBILE9BQU9pQyxLQUFLO2dCQUMvQmpDLE9BQU85RixJQUFJLENBQUM7Z0JBQ1oySCxRQUFRMUUsT0FBTyxDQUFDLENBQUMrRSxNQUFNakksSUFBTStGLE1BQU0sQ0FBQy9GLEVBQUUsSUFBSWIsUUFBUXdJLG1CQUFtQixDQUFDTSxNQUFNRjtZQUM5RTtZQUNBLE9BQU9oQztRQUNUO1FBQ0EsT0FBTzRCLG9CQUFvQnZFLENBQUMsRUFBRUMsQ0FBQyxFQUFFO1lBQy9CLElBQUlELE1BQU0sS0FBSyxLQUFLQyxNQUFNLEtBQUssR0FDN0IsTUFBTSxJQUFJeEQsV0FBVztZQUN2QixJQUFJcUksSUFBSTtZQUNSLElBQUssSUFBSWxJLElBQUksR0FBR0EsS0FBSyxHQUFHQSxJQUFLO2dCQUMzQmtJLElBQUlBLEtBQUssSUFBSSxDQUFDQSxNQUFNLEtBQUs7Z0JBQ3pCQSxLQUFLLENBQUM3RSxNQUFNckQsSUFBSSxLQUFLb0Q7WUFDdkI7WUFDQXhDLE9BQU9zSCxNQUFNLEtBQUs7WUFDbEIsT0FBT0E7UUFDVDtRQUNBdkIsMkJBQTJCSCxVQUFVLEVBQUU7WUFDckMsTUFBTTJCLElBQUkzQixVQUFVLENBQUMsRUFBRTtZQUN2QjVGLE9BQU91SCxLQUFLLElBQUksQ0FBQ3JJLElBQUksR0FBRztZQUN4QixNQUFNc0ksT0FBT0QsSUFBSSxLQUFLM0IsVUFBVSxDQUFDLEVBQUUsSUFBSTJCLEtBQUszQixVQUFVLENBQUMsRUFBRSxJQUFJMkIsSUFBSSxLQUFLM0IsVUFBVSxDQUFDLEVBQUUsSUFBSTJCLEtBQUszQixVQUFVLENBQUMsRUFBRSxJQUFJMkI7WUFDN0csT0FBTyxDQUFDQyxRQUFRNUIsVUFBVSxDQUFDLEVBQUUsSUFBSTJCLElBQUksS0FBSzNCLFVBQVUsQ0FBQyxFQUFFLElBQUkyQixJQUFJLElBQUksS0FBTUMsQ0FBQUEsUUFBUTVCLFVBQVUsQ0FBQyxFQUFFLElBQUkyQixJQUFJLEtBQUszQixVQUFVLENBQUMsRUFBRSxJQUFJMkIsSUFBSSxJQUFJO1FBQ3RJO1FBQ0F0QiwrQkFBK0J3QixlQUFlLEVBQUVDLGdCQUFnQixFQUFFOUIsVUFBVSxFQUFFO1lBQzVFLElBQUk2QixpQkFBaUI7Z0JBQ25CLElBQUksQ0FBQzNCLHVCQUF1QixDQUFDNEIsa0JBQWtCOUI7Z0JBQy9DOEIsbUJBQW1CO1lBQ3JCO1lBQ0FBLG9CQUFvQixJQUFJLENBQUN4SSxJQUFJO1lBQzdCLElBQUksQ0FBQzRHLHVCQUF1QixDQUFDNEIsa0JBQWtCOUI7WUFDL0MsT0FBTyxJQUFJLENBQUNHLDBCQUEwQixDQUFDSDtRQUN6QztRQUNBRSx3QkFBd0I0QixnQkFBZ0IsRUFBRTlCLFVBQVUsRUFBRTtZQUNwRCxJQUFJQSxVQUFVLENBQUMsRUFBRSxJQUFJLEdBQ25COEIsb0JBQW9CLElBQUksQ0FBQ3hJLElBQUk7WUFDL0IwRyxXQUFXK0IsR0FBRztZQUNkL0IsV0FBV2dDLE9BQU8sQ0FBQ0Y7UUFDckI7SUFDRjtJQUNBLElBQUlHLFNBQVN0SjtJQUNic0osT0FBTzlJLFdBQVcsR0FBRztJQUNyQjhJLE9BQU83SSxXQUFXLEdBQUc7SUFDckI2SSxPQUFPaEMsVUFBVSxHQUFHO0lBQ3BCZ0MsT0FBTzFCLFVBQVUsR0FBRztJQUNwQjBCLE9BQU83QixVQUFVLEdBQUc7SUFDcEI2QixPQUFPcEIsVUFBVSxHQUFHO0lBQ3BCb0IsT0FBT3ZELHVCQUF1QixHQUFHO1FBQy9CO1lBQUMsQ0FBQztZQUFHO1lBQUc7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1NBQUc7UUFDbks7WUFBQyxDQUFDO1lBQUc7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7U0FBRztRQUNwSztZQUFDLENBQUM7WUFBRztZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtTQUFHO1FBQ3BLO1lBQUMsQ0FBQztZQUFHO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1NBQUc7S0FDcks7SUFDRHVELE9BQU8xRCwyQkFBMkIsR0FBRztRQUNuQztZQUFDLENBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtTQUFHO1FBQzdJO1lBQUMsQ0FBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1NBQUc7UUFDdEo7WUFBQyxDQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7U0FBRztRQUN6SjtZQUFDLENBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZ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SUFBSTRCLFNBQVMsQ0FBQzlDO0lBQ1osTUFBTUMsS0FBS0QsT0FBTyxFQUFFK0MsUUFBUSxFQUFFLEdBQUc5QyxJQUFJSyxhQUFheFAsVUFBVW1QLElBQUk7UUFBQztLQUFXO0lBQzVFLElBQUk4QyxhQUFhLE9BQU87UUFDdEIsT0FBTyxhQUFhLGlCQUFHNVIsMERBQW1CLENBQUNvUixXQUFXOVIsZUFBZSxDQUFDLEdBQUc2UDtJQUMzRTtJQUNBLE9BQU8sYUFBYSxpQkFBR25QLDBEQUFtQixDQUFDNE8sY0FBY3RQLGVBQWUsQ0FBQyxHQUFHNlA7QUFDOUU7QUFLRSIsInNvdXJjZXMiOlsid2VicGFjazovL2lzb21vcnBoaWMvLi9ub2RlX21vZHVsZXMvcXJjb2RlLnJlYWN0L2xpYi9lc20vaW5kZXguanM/YzRhYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19vYmpSZXN0ID0gKHNvdXJjZSwgZXhjbHVkZSkgPT4ge1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIGZvciAodmFyIHByb3AgaW4gc291cmNlKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChzb3VyY2UsIHByb3ApICYmIGV4Y2x1ZGUuaW5kZXhPZihwcm9wKSA8IDApXG4gICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gIGlmIChzb3VyY2UgIT0gbnVsbCAmJiBfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhzb3VyY2UpKSB7XG4gICAgICBpZiAoZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMCAmJiBfX3Byb3BJc0VudW0uY2FsbChzb3VyY2UsIHByb3ApKVxuICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLy8gc3JjL2luZGV4LnRzeFxuaW1wb3J0IFJlYWN0LCB7IHVzZVJlZiwgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdGhpcmQtcGFydHkvcXJjb2RlZ2VuL2luZGV4LnRzXG4vKipcbiAqIEBsaWNlbnNlIFFSIENvZGUgZ2VuZXJhdG9yIGxpYnJhcnkgKFR5cGVTY3JpcHQpXG4gKiBDb3B5cmlnaHQgKGMpIFByb2plY3QgTmF5dWtpLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVFxuICovXG52YXIgcXJjb2RlZ2VuO1xuKChxcmNvZGVnZW4yKSA9PiB7XG4gIGNvbnN0IF9RckNvZGUgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IodmVyc2lvbiwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwsIGRhdGFDb2Rld29yZHMsIG1zaykge1xuICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgIHRoaXMuZXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSBlcnJvckNvcnJlY3Rpb25MZXZlbDtcbiAgICAgIHRoaXMubW9kdWxlcyA9IFtdO1xuICAgICAgdGhpcy5pc0Z1bmN0aW9uID0gW107XG4gICAgICBpZiAodmVyc2lvbiA8IF9RckNvZGUuTUlOX1ZFUlNJT04gfHwgdmVyc2lvbiA+IF9RckNvZGUuTUFYX1ZFUlNJT04pXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVmVyc2lvbiB2YWx1ZSBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICBpZiAobXNrIDwgLTEgfHwgbXNrID4gNylcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNYXNrIHZhbHVlIG91dCBvZiByYW5nZVwiKTtcbiAgICAgIHRoaXMuc2l6ZSA9IHZlcnNpb24gKiA0ICsgMTc7XG4gICAgICBsZXQgcm93ID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2l6ZTsgaSsrKVxuICAgICAgICByb3cucHVzaChmYWxzZSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2l6ZTsgaSsrKSB7XG4gICAgICAgIHRoaXMubW9kdWxlcy5wdXNoKHJvdy5zbGljZSgpKTtcbiAgICAgICAgdGhpcy5pc0Z1bmN0aW9uLnB1c2gocm93LnNsaWNlKCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5kcmF3RnVuY3Rpb25QYXR0ZXJucygpO1xuICAgICAgY29uc3QgYWxsQ29kZXdvcmRzID0gdGhpcy5hZGRFY2NBbmRJbnRlcmxlYXZlKGRhdGFDb2Rld29yZHMpO1xuICAgICAgdGhpcy5kcmF3Q29kZXdvcmRzKGFsbENvZGV3b3Jkcyk7XG4gICAgICBpZiAobXNrID09IC0xKSB7XG4gICAgICAgIGxldCBtaW5QZW5hbHR5ID0gMWU5O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgICAgIHRoaXMuYXBwbHlNYXNrKGkpO1xuICAgICAgICAgIHRoaXMuZHJhd0Zvcm1hdEJpdHMoaSk7XG4gICAgICAgICAgY29uc3QgcGVuYWx0eSA9IHRoaXMuZ2V0UGVuYWx0eVNjb3JlKCk7XG4gICAgICAgICAgaWYgKHBlbmFsdHkgPCBtaW5QZW5hbHR5KSB7XG4gICAgICAgICAgICBtc2sgPSBpO1xuICAgICAgICAgICAgbWluUGVuYWx0eSA9IHBlbmFsdHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYXBwbHlNYXNrKGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhc3NlcnQoMCA8PSBtc2sgJiYgbXNrIDw9IDcpO1xuICAgICAgdGhpcy5tYXNrID0gbXNrO1xuICAgICAgdGhpcy5hcHBseU1hc2sobXNrKTtcbiAgICAgIHRoaXMuZHJhd0Zvcm1hdEJpdHMobXNrKTtcbiAgICAgIHRoaXMuaXNGdW5jdGlvbiA9IFtdO1xuICAgIH1cbiAgICBzdGF0aWMgZW5jb2RlVGV4dCh0ZXh0LCBlY2wpIHtcbiAgICAgIGNvbnN0IHNlZ3MgPSBxcmNvZGVnZW4yLlFyU2VnbWVudC5tYWtlU2VnbWVudHModGV4dCk7XG4gICAgICByZXR1cm4gX1FyQ29kZS5lbmNvZGVTZWdtZW50cyhzZWdzLCBlY2wpO1xuICAgIH1cbiAgICBzdGF0aWMgZW5jb2RlQmluYXJ5KGRhdGEsIGVjbCkge1xuICAgICAgY29uc3Qgc2VnID0gcXJjb2RlZ2VuMi5RclNlZ21lbnQubWFrZUJ5dGVzKGRhdGEpO1xuICAgICAgcmV0dXJuIF9RckNvZGUuZW5jb2RlU2VnbWVudHMoW3NlZ10sIGVjbCk7XG4gICAgfVxuICAgIHN0YXRpYyBlbmNvZGVTZWdtZW50cyhzZWdzLCBlY2wsIG1pblZlcnNpb24gPSAxLCBtYXhWZXJzaW9uID0gNDAsIG1hc2sgPSAtMSwgYm9vc3RFY2wgPSB0cnVlKSB7XG4gICAgICBpZiAoIShfUXJDb2RlLk1JTl9WRVJTSU9OIDw9IG1pblZlcnNpb24gJiYgbWluVmVyc2lvbiA8PSBtYXhWZXJzaW9uICYmIG1heFZlcnNpb24gPD0gX1FyQ29kZS5NQVhfVkVSU0lPTikgfHwgbWFzayA8IC0xIHx8IG1hc2sgPiA3KVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgdmFsdWVcIik7XG4gICAgICBsZXQgdmVyc2lvbjtcbiAgICAgIGxldCBkYXRhVXNlZEJpdHM7XG4gICAgICBmb3IgKHZlcnNpb24gPSBtaW5WZXJzaW9uOyA7IHZlcnNpb24rKykge1xuICAgICAgICBjb25zdCBkYXRhQ2FwYWNpdHlCaXRzMiA9IF9RckNvZGUuZ2V0TnVtRGF0YUNvZGV3b3Jkcyh2ZXJzaW9uLCBlY2wpICogODtcbiAgICAgICAgY29uc3QgdXNlZEJpdHMgPSBRclNlZ21lbnQuZ2V0VG90YWxCaXRzKHNlZ3MsIHZlcnNpb24pO1xuICAgICAgICBpZiAodXNlZEJpdHMgPD0gZGF0YUNhcGFjaXR5Qml0czIpIHtcbiAgICAgICAgICBkYXRhVXNlZEJpdHMgPSB1c2VkQml0cztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodmVyc2lvbiA+PSBtYXhWZXJzaW9uKVxuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRGF0YSB0b28gbG9uZ1wiKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgbmV3RWNsIG9mIFtfUXJDb2RlLkVjYy5NRURJVU0sIF9RckNvZGUuRWNjLlFVQVJUSUxFLCBfUXJDb2RlLkVjYy5ISUdIXSkge1xuICAgICAgICBpZiAoYm9vc3RFY2wgJiYgZGF0YVVzZWRCaXRzIDw9IF9RckNvZGUuZ2V0TnVtRGF0YUNvZGV3b3Jkcyh2ZXJzaW9uLCBuZXdFY2wpICogOClcbiAgICAgICAgICBlY2wgPSBuZXdFY2w7XG4gICAgICB9XG4gICAgICBsZXQgYmIgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qgc2VnIG9mIHNlZ3MpIHtcbiAgICAgICAgYXBwZW5kQml0cyhzZWcubW9kZS5tb2RlQml0cywgNCwgYmIpO1xuICAgICAgICBhcHBlbmRCaXRzKHNlZy5udW1DaGFycywgc2VnLm1vZGUubnVtQ2hhckNvdW50Qml0cyh2ZXJzaW9uKSwgYmIpO1xuICAgICAgICBmb3IgKGNvbnN0IGIgb2Ygc2VnLmdldERhdGEoKSlcbiAgICAgICAgICBiYi5wdXNoKGIpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KGJiLmxlbmd0aCA9PSBkYXRhVXNlZEJpdHMpO1xuICAgICAgY29uc3QgZGF0YUNhcGFjaXR5Qml0cyA9IF9RckNvZGUuZ2V0TnVtRGF0YUNvZGV3b3Jkcyh2ZXJzaW9uLCBlY2wpICogODtcbiAgICAgIGFzc2VydChiYi5sZW5ndGggPD0gZGF0YUNhcGFjaXR5Qml0cyk7XG4gICAgICBhcHBlbmRCaXRzKDAsIE1hdGgubWluKDQsIGRhdGFDYXBhY2l0eUJpdHMgLSBiYi5sZW5ndGgpLCBiYik7XG4gICAgICBhcHBlbmRCaXRzKDAsICg4IC0gYmIubGVuZ3RoICUgOCkgJSA4LCBiYik7XG4gICAgICBhc3NlcnQoYmIubGVuZ3RoICUgOCA9PSAwKTtcbiAgICAgIGZvciAobGV0IHBhZEJ5dGUgPSAyMzY7IGJiLmxlbmd0aCA8IGRhdGFDYXBhY2l0eUJpdHM7IHBhZEJ5dGUgXj0gMjM2IF4gMTcpXG4gICAgICAgIGFwcGVuZEJpdHMocGFkQnl0ZSwgOCwgYmIpO1xuICAgICAgbGV0IGRhdGFDb2Rld29yZHMgPSBbXTtcbiAgICAgIHdoaWxlIChkYXRhQ29kZXdvcmRzLmxlbmd0aCAqIDggPCBiYi5sZW5ndGgpXG4gICAgICAgIGRhdGFDb2Rld29yZHMucHVzaCgwKTtcbiAgICAgIGJiLmZvckVhY2goKGIsIGkpID0+IGRhdGFDb2Rld29yZHNbaSA+Pj4gM10gfD0gYiA8PCA3IC0gKGkgJiA3KSk7XG4gICAgICByZXR1cm4gbmV3IF9RckNvZGUodmVyc2lvbiwgZWNsLCBkYXRhQ29kZXdvcmRzLCBtYXNrKTtcbiAgICB9XG4gICAgZ2V0TW9kdWxlKHgsIHkpIHtcbiAgICAgIHJldHVybiAwIDw9IHggJiYgeCA8IHRoaXMuc2l6ZSAmJiAwIDw9IHkgJiYgeSA8IHRoaXMuc2l6ZSAmJiB0aGlzLm1vZHVsZXNbeV1beF07XG4gICAgfVxuICAgIGdldE1vZHVsZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb2R1bGVzO1xuICAgIH1cbiAgICBkcmF3RnVuY3Rpb25QYXR0ZXJucygpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaXplOyBpKyspIHtcbiAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSg2LCBpLCBpICUgMiA9PSAwKTtcbiAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZShpLCA2LCBpICUgMiA9PSAwKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZHJhd0ZpbmRlclBhdHRlcm4oMywgMyk7XG4gICAgICB0aGlzLmRyYXdGaW5kZXJQYXR0ZXJuKHRoaXMuc2l6ZSAtIDQsIDMpO1xuICAgICAgdGhpcy5kcmF3RmluZGVyUGF0dGVybigzLCB0aGlzLnNpemUgLSA0KTtcbiAgICAgIGNvbnN0IGFsaWduUGF0UG9zID0gdGhpcy5nZXRBbGlnbm1lbnRQYXR0ZXJuUG9zaXRpb25zKCk7XG4gICAgICBjb25zdCBudW1BbGlnbiA9IGFsaWduUGF0UG9zLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQWxpZ247IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUFsaWduOyBqKyspIHtcbiAgICAgICAgICBpZiAoIShpID09IDAgJiYgaiA9PSAwIHx8IGkgPT0gMCAmJiBqID09IG51bUFsaWduIC0gMSB8fCBpID09IG51bUFsaWduIC0gMSAmJiBqID09IDApKVxuICAgICAgICAgICAgdGhpcy5kcmF3QWxpZ25tZW50UGF0dGVybihhbGlnblBhdFBvc1tpXSwgYWxpZ25QYXRQb3Nbal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmRyYXdGb3JtYXRCaXRzKDApO1xuICAgICAgdGhpcy5kcmF3VmVyc2lvbigpO1xuICAgIH1cbiAgICBkcmF3Rm9ybWF0Qml0cyhtYXNrKSB7XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5lcnJvckNvcnJlY3Rpb25MZXZlbC5mb3JtYXRCaXRzIDw8IDMgfCBtYXNrO1xuICAgICAgbGV0IHJlbSA9IGRhdGE7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspXG4gICAgICAgIHJlbSA9IHJlbSA8PCAxIF4gKHJlbSA+Pj4gOSkgKiAxMzM1O1xuICAgICAgY29uc3QgYml0cyA9IChkYXRhIDw8IDEwIHwgcmVtKSBeIDIxNTIyO1xuICAgICAgYXNzZXJ0KGJpdHMgPj4+IDE1ID09IDApO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gNTsgaSsrKVxuICAgICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKDgsIGksIGdldEJpdChiaXRzLCBpKSk7XG4gICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKDgsIDcsIGdldEJpdChiaXRzLCA2KSk7XG4gICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKDgsIDgsIGdldEJpdChiaXRzLCA3KSk7XG4gICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKDcsIDgsIGdldEJpdChiaXRzLCA4KSk7XG4gICAgICBmb3IgKGxldCBpID0gOTsgaSA8IDE1OyBpKyspXG4gICAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoMTQgLSBpLCA4LCBnZXRCaXQoYml0cywgaSkpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspXG4gICAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUodGhpcy5zaXplIC0gMSAtIGksIDgsIGdldEJpdChiaXRzLCBpKSk7XG4gICAgICBmb3IgKGxldCBpID0gODsgaSA8IDE1OyBpKyspXG4gICAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoOCwgdGhpcy5zaXplIC0gMTUgKyBpLCBnZXRCaXQoYml0cywgaSkpO1xuICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSg4LCB0aGlzLnNpemUgLSA4LCB0cnVlKTtcbiAgICB9XG4gICAgZHJhd1ZlcnNpb24oKSB7XG4gICAgICBpZiAodGhpcy52ZXJzaW9uIDwgNylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGV0IHJlbSA9IHRoaXMudmVyc2lvbjtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTI7IGkrKylcbiAgICAgICAgcmVtID0gcmVtIDw8IDEgXiAocmVtID4+PiAxMSkgKiA3OTczO1xuICAgICAgY29uc3QgYml0cyA9IHRoaXMudmVyc2lvbiA8PCAxMiB8IHJlbTtcbiAgICAgIGFzc2VydChiaXRzID4+PiAxOCA9PSAwKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTg7IGkrKykge1xuICAgICAgICBjb25zdCBjb2xvciA9IGdldEJpdChiaXRzLCBpKTtcbiAgICAgICAgY29uc3QgYSA9IHRoaXMuc2l6ZSAtIDExICsgaSAlIDM7XG4gICAgICAgIGNvbnN0IGIgPSBNYXRoLmZsb29yKGkgLyAzKTtcbiAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZShhLCBiLCBjb2xvcik7XG4gICAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoYiwgYSwgY29sb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBkcmF3RmluZGVyUGF0dGVybih4LCB5KSB7XG4gICAgICBmb3IgKGxldCBkeSA9IC00OyBkeSA8PSA0OyBkeSsrKSB7XG4gICAgICAgIGZvciAobGV0IGR4ID0gLTQ7IGR4IDw9IDQ7IGR4KyspIHtcbiAgICAgICAgICBjb25zdCBkaXN0ID0gTWF0aC5tYXgoTWF0aC5hYnMoZHgpLCBNYXRoLmFicyhkeSkpO1xuICAgICAgICAgIGNvbnN0IHh4ID0geCArIGR4O1xuICAgICAgICAgIGNvbnN0IHl5ID0geSArIGR5O1xuICAgICAgICAgIGlmICgwIDw9IHh4ICYmIHh4IDwgdGhpcy5zaXplICYmIDAgPD0geXkgJiYgeXkgPCB0aGlzLnNpemUpXG4gICAgICAgICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKHh4LCB5eSwgZGlzdCAhPSAyICYmIGRpc3QgIT0gNCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZHJhd0FsaWdubWVudFBhdHRlcm4oeCwgeSkge1xuICAgICAgZm9yIChsZXQgZHkgPSAtMjsgZHkgPD0gMjsgZHkrKykge1xuICAgICAgICBmb3IgKGxldCBkeCA9IC0yOyBkeCA8PSAyOyBkeCsrKVxuICAgICAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoeCArIGR4LCB5ICsgZHksIE1hdGgubWF4KE1hdGguYWJzKGR4KSwgTWF0aC5hYnMoZHkpKSAhPSAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0RnVuY3Rpb25Nb2R1bGUoeCwgeSwgaXNEYXJrKSB7XG4gICAgICB0aGlzLm1vZHVsZXNbeV1beF0gPSBpc0Rhcms7XG4gICAgICB0aGlzLmlzRnVuY3Rpb25beV1beF0gPSB0cnVlO1xuICAgIH1cbiAgICBhZGRFY2NBbmRJbnRlcmxlYXZlKGRhdGEpIHtcbiAgICAgIGNvbnN0IHZlciA9IHRoaXMudmVyc2lvbjtcbiAgICAgIGNvbnN0IGVjbCA9IHRoaXMuZXJyb3JDb3JyZWN0aW9uTGV2ZWw7XG4gICAgICBpZiAoZGF0YS5sZW5ndGggIT0gX1FyQ29kZS5nZXROdW1EYXRhQ29kZXdvcmRzKHZlciwgZWNsKSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50XCIpO1xuICAgICAgY29uc3QgbnVtQmxvY2tzID0gX1FyQ29kZS5OVU1fRVJST1JfQ09SUkVDVElPTl9CTE9DS1NbZWNsLm9yZGluYWxdW3Zlcl07XG4gICAgICBjb25zdCBibG9ja0VjY0xlbiA9IF9RckNvZGUuRUNDX0NPREVXT1JEU19QRVJfQkxPQ0tbZWNsLm9yZGluYWxdW3Zlcl07XG4gICAgICBjb25zdCByYXdDb2Rld29yZHMgPSBNYXRoLmZsb29yKF9RckNvZGUuZ2V0TnVtUmF3RGF0YU1vZHVsZXModmVyKSAvIDgpO1xuICAgICAgY29uc3QgbnVtU2hvcnRCbG9ja3MgPSBudW1CbG9ja3MgLSByYXdDb2Rld29yZHMgJSBudW1CbG9ja3M7XG4gICAgICBjb25zdCBzaG9ydEJsb2NrTGVuID0gTWF0aC5mbG9vcihyYXdDb2Rld29yZHMgLyBudW1CbG9ja3MpO1xuICAgICAgbGV0IGJsb2NrcyA9IFtdO1xuICAgICAgY29uc3QgcnNEaXYgPSBfUXJDb2RlLnJlZWRTb2xvbW9uQ29tcHV0ZURpdmlzb3IoYmxvY2tFY2NMZW4pO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGsgPSAwOyBpIDwgbnVtQmxvY2tzOyBpKyspIHtcbiAgICAgICAgbGV0IGRhdCA9IGRhdGEuc2xpY2UoaywgayArIHNob3J0QmxvY2tMZW4gLSBibG9ja0VjY0xlbiArIChpIDwgbnVtU2hvcnRCbG9ja3MgPyAwIDogMSkpO1xuICAgICAgICBrICs9IGRhdC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGVjYyA9IF9RckNvZGUucmVlZFNvbG9tb25Db21wdXRlUmVtYWluZGVyKGRhdCwgcnNEaXYpO1xuICAgICAgICBpZiAoaSA8IG51bVNob3J0QmxvY2tzKVxuICAgICAgICAgIGRhdC5wdXNoKDApO1xuICAgICAgICBibG9ja3MucHVzaChkYXQuY29uY2F0KGVjYykpO1xuICAgICAgfVxuICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja3NbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYmxvY2tzLmZvckVhY2goKGJsb2NrLCBqKSA9PiB7XG4gICAgICAgICAgaWYgKGkgIT0gc2hvcnRCbG9ja0xlbiAtIGJsb2NrRWNjTGVuIHx8IGogPj0gbnVtU2hvcnRCbG9ja3MpXG4gICAgICAgICAgICByZXN1bHQucHVzaChibG9ja1tpXSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KHJlc3VsdC5sZW5ndGggPT0gcmF3Q29kZXdvcmRzKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGRyYXdDb2Rld29yZHMoZGF0YSkge1xuICAgICAgaWYgKGRhdGEubGVuZ3RoICE9IE1hdGguZmxvb3IoX1FyQ29kZS5nZXROdW1SYXdEYXRhTW9kdWxlcyh0aGlzLnZlcnNpb24pIC8gOCkpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudFwiKTtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAobGV0IHJpZ2h0ID0gdGhpcy5zaXplIC0gMTsgcmlnaHQgPj0gMTsgcmlnaHQgLT0gMikge1xuICAgICAgICBpZiAocmlnaHQgPT0gNilcbiAgICAgICAgICByaWdodCA9IDU7XG4gICAgICAgIGZvciAobGV0IHZlcnQgPSAwOyB2ZXJ0IDwgdGhpcy5zaXplOyB2ZXJ0KyspIHtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDI7IGorKykge1xuICAgICAgICAgICAgY29uc3QgeCA9IHJpZ2h0IC0gajtcbiAgICAgICAgICAgIGNvbnN0IHVwd2FyZCA9IChyaWdodCArIDEgJiAyKSA9PSAwO1xuICAgICAgICAgICAgY29uc3QgeSA9IHVwd2FyZCA/IHRoaXMuc2l6ZSAtIDEgLSB2ZXJ0IDogdmVydDtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0Z1bmN0aW9uW3ldW3hdICYmIGkgPCBkYXRhLmxlbmd0aCAqIDgpIHtcbiAgICAgICAgICAgICAgdGhpcy5tb2R1bGVzW3ldW3hdID0gZ2V0Qml0KGRhdGFbaSA+Pj4gM10sIDcgLSAoaSAmIDcpKTtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXNzZXJ0KGkgPT0gZGF0YS5sZW5ndGggKiA4KTtcbiAgICB9XG4gICAgYXBwbHlNYXNrKG1hc2spIHtcbiAgICAgIGlmIChtYXNrIDwgMCB8fCBtYXNrID4gNylcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNYXNrIHZhbHVlIG91dCBvZiByYW5nZVwiKTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5zaXplOyB5KyspIHtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLnNpemU7IHgrKykge1xuICAgICAgICAgIGxldCBpbnZlcnQ7XG4gICAgICAgICAgc3dpdGNoIChtYXNrKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGludmVydCA9ICh4ICsgeSkgJSAyID09IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBpbnZlcnQgPSB5ICUgMiA9PSAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgaW52ZXJ0ID0geCAlIDMgPT0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGludmVydCA9ICh4ICsgeSkgJSAzID09IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBpbnZlcnQgPSAoTWF0aC5mbG9vcih4IC8gMykgKyBNYXRoLmZsb29yKHkgLyAyKSkgJSAyID09IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBpbnZlcnQgPSB4ICogeSAlIDIgKyB4ICogeSAlIDMgPT0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIGludmVydCA9ICh4ICogeSAlIDIgKyB4ICogeSAlIDMpICUgMiA9PSAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgaW52ZXJ0ID0gKCh4ICsgeSkgJSAyICsgeCAqIHkgJSAzKSAlIDIgPT0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlYWNoYWJsZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLmlzRnVuY3Rpb25beV1beF0gJiYgaW52ZXJ0KVxuICAgICAgICAgICAgdGhpcy5tb2R1bGVzW3ldW3hdID0gIXRoaXMubW9kdWxlc1t5XVt4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBnZXRQZW5hbHR5U2NvcmUoKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5zaXplOyB5KyspIHtcbiAgICAgICAgbGV0IHJ1bkNvbG9yID0gZmFsc2U7XG4gICAgICAgIGxldCBydW5YID0gMDtcbiAgICAgICAgbGV0IHJ1bkhpc3RvcnkgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5zaXplOyB4KyspIHtcbiAgICAgICAgICBpZiAodGhpcy5tb2R1bGVzW3ldW3hdID09IHJ1bkNvbG9yKSB7XG4gICAgICAgICAgICBydW5YKys7XG4gICAgICAgICAgICBpZiAocnVuWCA9PSA1KVxuICAgICAgICAgICAgICByZXN1bHQgKz0gX1FyQ29kZS5QRU5BTFRZX04xO1xuICAgICAgICAgICAgZWxzZSBpZiAocnVuWCA+IDUpXG4gICAgICAgICAgICAgIHJlc3VsdCsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRlclBlbmFsdHlBZGRIaXN0b3J5KHJ1blgsIHJ1bkhpc3RvcnkpO1xuICAgICAgICAgICAgaWYgKCFydW5Db2xvcilcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuZmluZGVyUGVuYWx0eUNvdW50UGF0dGVybnMocnVuSGlzdG9yeSkgKiBfUXJDb2RlLlBFTkFMVFlfTjM7XG4gICAgICAgICAgICBydW5Db2xvciA9IHRoaXMubW9kdWxlc1t5XVt4XTtcbiAgICAgICAgICAgIHJ1blggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gdGhpcy5maW5kZXJQZW5hbHR5VGVybWluYXRlQW5kQ291bnQocnVuQ29sb3IsIHJ1blgsIHJ1bkhpc3RvcnkpICogX1FyQ29kZS5QRU5BTFRZX04zO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLnNpemU7IHgrKykge1xuICAgICAgICBsZXQgcnVuQ29sb3IgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJ1blkgPSAwO1xuICAgICAgICBsZXQgcnVuSGlzdG9yeSA9IFswLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLnNpemU7IHkrKykge1xuICAgICAgICAgIGlmICh0aGlzLm1vZHVsZXNbeV1beF0gPT0gcnVuQ29sb3IpIHtcbiAgICAgICAgICAgIHJ1blkrKztcbiAgICAgICAgICAgIGlmIChydW5ZID09IDUpXG4gICAgICAgICAgICAgIHJlc3VsdCArPSBfUXJDb2RlLlBFTkFMVFlfTjE7XG4gICAgICAgICAgICBlbHNlIGlmIChydW5ZID4gNSlcbiAgICAgICAgICAgICAgcmVzdWx0Kys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmluZGVyUGVuYWx0eUFkZEhpc3RvcnkocnVuWSwgcnVuSGlzdG9yeSk7XG4gICAgICAgICAgICBpZiAoIXJ1bkNvbG9yKVxuICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5maW5kZXJQZW5hbHR5Q291bnRQYXR0ZXJucyhydW5IaXN0b3J5KSAqIF9RckNvZGUuUEVOQUxUWV9OMztcbiAgICAgICAgICAgIHJ1bkNvbG9yID0gdGhpcy5tb2R1bGVzW3ldW3hdO1xuICAgICAgICAgICAgcnVuWSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSB0aGlzLmZpbmRlclBlbmFsdHlUZXJtaW5hdGVBbmRDb3VudChydW5Db2xvciwgcnVuWSwgcnVuSGlzdG9yeSkgKiBfUXJDb2RlLlBFTkFMVFlfTjM7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuc2l6ZSAtIDE7IHkrKykge1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuc2l6ZSAtIDE7IHgrKykge1xuICAgICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5tb2R1bGVzW3ldW3hdO1xuICAgICAgICAgIGlmIChjb2xvciA9PSB0aGlzLm1vZHVsZXNbeV1beCArIDFdICYmIGNvbG9yID09IHRoaXMubW9kdWxlc1t5ICsgMV1beF0gJiYgY29sb3IgPT0gdGhpcy5tb2R1bGVzW3kgKyAxXVt4ICsgMV0pXG4gICAgICAgICAgICByZXN1bHQgKz0gX1FyQ29kZS5QRU5BTFRZX04yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgZGFyayA9IDA7XG4gICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0aGlzLm1vZHVsZXMpXG4gICAgICAgIGRhcmsgPSByb3cucmVkdWNlKChzdW0sIGNvbG9yKSA9PiBzdW0gKyAoY29sb3IgPyAxIDogMCksIGRhcmspO1xuICAgICAgY29uc3QgdG90YWwgPSB0aGlzLnNpemUgKiB0aGlzLnNpemU7XG4gICAgICBjb25zdCBrID0gTWF0aC5jZWlsKE1hdGguYWJzKGRhcmsgKiAyMCAtIHRvdGFsICogMTApIC8gdG90YWwpIC0gMTtcbiAgICAgIGFzc2VydCgwIDw9IGsgJiYgayA8PSA5KTtcbiAgICAgIHJlc3VsdCArPSBrICogX1FyQ29kZS5QRU5BTFRZX040O1xuICAgICAgYXNzZXJ0KDAgPD0gcmVzdWx0ICYmIHJlc3VsdCA8PSAyNTY4ODg4KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGdldEFsaWdubWVudFBhdHRlcm5Qb3NpdGlvbnMoKSB7XG4gICAgICBpZiAodGhpcy52ZXJzaW9uID09IDEpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBudW1BbGlnbiA9IE1hdGguZmxvb3IodGhpcy52ZXJzaW9uIC8gNykgKyAyO1xuICAgICAgICBjb25zdCBzdGVwID0gdGhpcy52ZXJzaW9uID09IDMyID8gMjYgOiBNYXRoLmNlaWwoKHRoaXMudmVyc2lvbiAqIDQgKyA0KSAvIChudW1BbGlnbiAqIDIgLSAyKSkgKiAyO1xuICAgICAgICBsZXQgcmVzdWx0ID0gWzZdO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSB0aGlzLnNpemUgLSA3OyByZXN1bHQubGVuZ3RoIDwgbnVtQWxpZ247IHBvcyAtPSBzdGVwKVxuICAgICAgICAgIHJlc3VsdC5zcGxpY2UoMSwgMCwgcG9zKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdldE51bVJhd0RhdGFNb2R1bGVzKHZlcikge1xuICAgICAgaWYgKHZlciA8IF9RckNvZGUuTUlOX1ZFUlNJT04gfHwgdmVyID4gX1FyQ29kZS5NQVhfVkVSU0lPTilcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJWZXJzaW9uIG51bWJlciBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICBsZXQgcmVzdWx0ID0gKDE2ICogdmVyICsgMTI4KSAqIHZlciArIDY0O1xuICAgICAgaWYgKHZlciA+PSAyKSB7XG4gICAgICAgIGNvbnN0IG51bUFsaWduID0gTWF0aC5mbG9vcih2ZXIgLyA3KSArIDI7XG4gICAgICAgIHJlc3VsdCAtPSAoMjUgKiBudW1BbGlnbiAtIDEwKSAqIG51bUFsaWduIC0gNTU7XG4gICAgICAgIGlmICh2ZXIgPj0gNylcbiAgICAgICAgICByZXN1bHQgLT0gMzY7XG4gICAgICB9XG4gICAgICBhc3NlcnQoMjA4IDw9IHJlc3VsdCAmJiByZXN1bHQgPD0gMjk2NDgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIGdldE51bURhdGFDb2Rld29yZHModmVyLCBlY2wpIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKF9RckNvZGUuZ2V0TnVtUmF3RGF0YU1vZHVsZXModmVyKSAvIDgpIC0gX1FyQ29kZS5FQ0NfQ09ERVdPUkRTX1BFUl9CTE9DS1tlY2wub3JkaW5hbF1bdmVyXSAqIF9RckNvZGUuTlVNX0VSUk9SX0NPUlJFQ1RJT05fQkxPQ0tTW2VjbC5vcmRpbmFsXVt2ZXJdO1xuICAgIH1cbiAgICBzdGF0aWMgcmVlZFNvbG9tb25Db21wdXRlRGl2aXNvcihkZWdyZWUpIHtcbiAgICAgIGlmIChkZWdyZWUgPCAxIHx8IGRlZ3JlZSA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEZWdyZWUgb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWdyZWUgLSAxOyBpKyspXG4gICAgICAgIHJlc3VsdC5wdXNoKDApO1xuICAgICAgcmVzdWx0LnB1c2goMSk7XG4gICAgICBsZXQgcm9vdCA9IDE7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZ3JlZTsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVzdWx0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgcmVzdWx0W2pdID0gX1FyQ29kZS5yZWVkU29sb21vbk11bHRpcGx5KHJlc3VsdFtqXSwgcm9vdCk7XG4gICAgICAgICAgaWYgKGogKyAxIDwgcmVzdWx0Lmxlbmd0aClcbiAgICAgICAgICAgIHJlc3VsdFtqXSBePSByZXN1bHRbaiArIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJvb3QgPSBfUXJDb2RlLnJlZWRTb2xvbW9uTXVsdGlwbHkocm9vdCwgMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgcmVlZFNvbG9tb25Db21wdXRlUmVtYWluZGVyKGRhdGEsIGRpdmlzb3IpIHtcbiAgICAgIGxldCByZXN1bHQgPSBkaXZpc29yLm1hcCgoXykgPT4gMCk7XG4gICAgICBmb3IgKGNvbnN0IGIgb2YgZGF0YSkge1xuICAgICAgICBjb25zdCBmYWN0b3IgPSBiIF4gcmVzdWx0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKDApO1xuICAgICAgICBkaXZpc29yLmZvckVhY2goKGNvZWYsIGkpID0+IHJlc3VsdFtpXSBePSBfUXJDb2RlLnJlZWRTb2xvbW9uTXVsdGlwbHkoY29lZiwgZmFjdG9yKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgcmVlZFNvbG9tb25NdWx0aXBseSh4LCB5KSB7XG4gICAgICBpZiAoeCA+Pj4gOCAhPSAwIHx8IHkgPj4+IDggIT0gMClcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCeXRlIG91dCBvZiByYW5nZVwiKTtcbiAgICAgIGxldCB6ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSA3OyBpID49IDA7IGktLSkge1xuICAgICAgICB6ID0geiA8PCAxIF4gKHogPj4+IDcpICogMjg1O1xuICAgICAgICB6IF49ICh5ID4+PiBpICYgMSkgKiB4O1xuICAgICAgfVxuICAgICAgYXNzZXJ0KHogPj4+IDggPT0gMCk7XG4gICAgICByZXR1cm4gejtcbiAgICB9XG4gICAgZmluZGVyUGVuYWx0eUNvdW50UGF0dGVybnMocnVuSGlzdG9yeSkge1xuICAgICAgY29uc3QgbiA9IHJ1bkhpc3RvcnlbMV07XG4gICAgICBhc3NlcnQobiA8PSB0aGlzLnNpemUgKiAzKTtcbiAgICAgIGNvbnN0IGNvcmUgPSBuID4gMCAmJiBydW5IaXN0b3J5WzJdID09IG4gJiYgcnVuSGlzdG9yeVszXSA9PSBuICogMyAmJiBydW5IaXN0b3J5WzRdID09IG4gJiYgcnVuSGlzdG9yeVs1XSA9PSBuO1xuICAgICAgcmV0dXJuIChjb3JlICYmIHJ1bkhpc3RvcnlbMF0gPj0gbiAqIDQgJiYgcnVuSGlzdG9yeVs2XSA+PSBuID8gMSA6IDApICsgKGNvcmUgJiYgcnVuSGlzdG9yeVs2XSA+PSBuICogNCAmJiBydW5IaXN0b3J5WzBdID49IG4gPyAxIDogMCk7XG4gICAgfVxuICAgIGZpbmRlclBlbmFsdHlUZXJtaW5hdGVBbmRDb3VudChjdXJyZW50UnVuQ29sb3IsIGN1cnJlbnRSdW5MZW5ndGgsIHJ1bkhpc3RvcnkpIHtcbiAgICAgIGlmIChjdXJyZW50UnVuQ29sb3IpIHtcbiAgICAgICAgdGhpcy5maW5kZXJQZW5hbHR5QWRkSGlzdG9yeShjdXJyZW50UnVuTGVuZ3RoLCBydW5IaXN0b3J5KTtcbiAgICAgICAgY3VycmVudFJ1bkxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgICBjdXJyZW50UnVuTGVuZ3RoICs9IHRoaXMuc2l6ZTtcbiAgICAgIHRoaXMuZmluZGVyUGVuYWx0eUFkZEhpc3RvcnkoY3VycmVudFJ1bkxlbmd0aCwgcnVuSGlzdG9yeSk7XG4gICAgICByZXR1cm4gdGhpcy5maW5kZXJQZW5hbHR5Q291bnRQYXR0ZXJucyhydW5IaXN0b3J5KTtcbiAgICB9XG4gICAgZmluZGVyUGVuYWx0eUFkZEhpc3RvcnkoY3VycmVudFJ1bkxlbmd0aCwgcnVuSGlzdG9yeSkge1xuICAgICAgaWYgKHJ1bkhpc3RvcnlbMF0gPT0gMClcbiAgICAgICAgY3VycmVudFJ1bkxlbmd0aCArPSB0aGlzLnNpemU7XG4gICAgICBydW5IaXN0b3J5LnBvcCgpO1xuICAgICAgcnVuSGlzdG9yeS51bnNoaWZ0KGN1cnJlbnRSdW5MZW5ndGgpO1xuICAgIH1cbiAgfTtcbiAgbGV0IFFyQ29kZSA9IF9RckNvZGU7XG4gIFFyQ29kZS5NSU5fVkVSU0lPTiA9IDE7XG4gIFFyQ29kZS5NQVhfVkVSU0lPTiA9IDQwO1xuICBRckNvZGUuUEVOQUxUWV9OMSA9IDM7XG4gIFFyQ29kZS5QRU5BTFRZX04yID0gMztcbiAgUXJDb2RlLlBFTkFMVFlfTjMgPSA0MDtcbiAgUXJDb2RlLlBFTkFMVFlfTjQgPSAxMDtcbiAgUXJDb2RlLkVDQ19DT0RFV09SRFNfUEVSX0JMT0NLID0gW1xuICAgIFstMSwgNywgMTAsIDE1LCAyMCwgMjYsIDE4LCAyMCwgMjQsIDMwLCAxOCwgMjAsIDI0LCAyNiwgMzAsIDIyLCAyNCwgMjgsIDMwLCAyOCwgMjgsIDI4LCAyOCwgMzAsIDMwLCAyNiwgMjgsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMF0sXG4gICAgWy0xLCAxMCwgMTYsIDI2LCAxOCwgMjQsIDE2LCAxOCwgMjIsIDIyLCAyNiwgMzAsIDIyLCAyMiwgMjQsIDI0LCAyOCwgMjgsIDI2LCAyNiwgMjYsIDI2LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOF0sXG4gICAgWy0xLCAxMywgMjIsIDE4LCAyNiwgMTgsIDI0LCAxOCwgMjIsIDIwLCAyNCwgMjgsIDI2LCAyNCwgMjAsIDMwLCAyNCwgMjgsIDI4LCAyNiwgMzAsIDI4LCAzMCwgMzAsIDMwLCAzMCwgMjgsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMF0sXG4gICAgWy0xLCAxNywgMjgsIDIyLCAxNiwgMjIsIDI4LCAyNiwgMjYsIDI0LCAyOCwgMjQsIDI4LCAyMiwgMjQsIDI0LCAzMCwgMjgsIDI4LCAyNiwgMjgsIDMwLCAyNCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMF1cbiAgXTtcbiAgUXJDb2RlLk5VTV9FUlJPUl9DT1JSRUNUSU9OX0JMT0NLUyA9IFtcbiAgICBbLTEsIDEsIDEsIDEsIDEsIDEsIDIsIDIsIDIsIDIsIDQsIDQsIDQsIDQsIDQsIDYsIDYsIDYsIDYsIDcsIDgsIDgsIDksIDksIDEwLCAxMiwgMTIsIDEyLCAxMywgMTQsIDE1LCAxNiwgMTcsIDE4LCAxOSwgMTksIDIwLCAyMSwgMjIsIDI0LCAyNV0sXG4gICAgWy0xLCAxLCAxLCAxLCAyLCAyLCA0LCA0LCA0LCA1LCA1LCA1LCA4LCA5LCA5LCAxMCwgMTAsIDExLCAxMywgMTQsIDE2LCAxNywgMTcsIDE4LCAyMCwgMjEsIDIzLCAyNSwgMjYsIDI4LCAyOSwgMzEsIDMzLCAzNSwgMzcsIDM4LCA0MCwgNDMsIDQ1LCA0NywgNDldLFxuICAgIFstMSwgMSwgMSwgMiwgMiwgNCwgNCwgNiwgNiwgOCwgOCwgOCwgMTAsIDEyLCAxNiwgMTIsIDE3LCAxNiwgMTgsIDIxLCAyMCwgMjMsIDIzLCAyNSwgMjcsIDI5LCAzNCwgMzQsIDM1LCAzOCwgNDAsIDQzLCA0NSwgNDgsIDUxLCA1MywgNTYsIDU5LCA2MiwgNjUsIDY4XSxcbiAgICBbLTEsIDEsIDEsIDIsIDQsIDQsIDQsIDUsIDYsIDgsIDgsIDExLCAxMSwgMTYsIDE2LCAxOCwgMTYsIDE5LCAyMSwgMjUsIDI1LCAyNSwgMzQsIDMwLCAzMiwgMzUsIDM3LCA0MCwgNDIsIDQ1LCA0OCwgNTEsIDU0LCA1NywgNjAsIDYzLCA2NiwgNzAsIDc0LCA3NywgODFdXG4gIF07XG4gIHFyY29kZWdlbjIuUXJDb2RlID0gUXJDb2RlO1xuICBmdW5jdGlvbiBhcHBlbmRCaXRzKHZhbCwgbGVuLCBiYikge1xuICAgIGlmIChsZW4gPCAwIHx8IGxlbiA+IDMxIHx8IHZhbCA+Pj4gbGVuICE9IDApXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlZhbHVlIG91dCBvZiByYW5nZVwiKTtcbiAgICBmb3IgKGxldCBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICBiYi5wdXNoKHZhbCA+Pj4gaSAmIDEpO1xuICB9XG4gIGZ1bmN0aW9uIGdldEJpdCh4LCBpKSB7XG4gICAgcmV0dXJuICh4ID4+PiBpICYgMSkgIT0gMDtcbiAgfVxuICBmdW5jdGlvbiBhc3NlcnQoY29uZCkge1xuICAgIGlmICghY29uZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzc2VydGlvbiBlcnJvclwiKTtcbiAgfVxuICBjb25zdCBfUXJTZWdtZW50ID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKG1vZGUsIG51bUNoYXJzLCBiaXREYXRhKSB7XG4gICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgdGhpcy5udW1DaGFycyA9IG51bUNoYXJzO1xuICAgICAgdGhpcy5iaXREYXRhID0gYml0RGF0YTtcbiAgICAgIGlmIChudW1DaGFycyA8IDApXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudFwiKTtcbiAgICAgIHRoaXMuYml0RGF0YSA9IGJpdERhdGEuc2xpY2UoKTtcbiAgICB9XG4gICAgc3RhdGljIG1ha2VCeXRlcyhkYXRhKSB7XG4gICAgICBsZXQgYmIgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgYiBvZiBkYXRhKVxuICAgICAgICBhcHBlbmRCaXRzKGIsIDgsIGJiKTtcbiAgICAgIHJldHVybiBuZXcgX1FyU2VnbWVudChfUXJTZWdtZW50Lk1vZGUuQllURSwgZGF0YS5sZW5ndGgsIGJiKTtcbiAgICB9XG4gICAgc3RhdGljIG1ha2VOdW1lcmljKGRpZ2l0cykge1xuICAgICAgaWYgKCFfUXJTZWdtZW50LmlzTnVtZXJpYyhkaWdpdHMpKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlN0cmluZyBjb250YWlucyBub24tbnVtZXJpYyBjaGFyYWN0ZXJzXCIpO1xuICAgICAgbGV0IGJiID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZ2l0cy5sZW5ndGg7ICkge1xuICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oZGlnaXRzLmxlbmd0aCAtIGksIDMpO1xuICAgICAgICBhcHBlbmRCaXRzKHBhcnNlSW50KGRpZ2l0cy5zdWJzdHIoaSwgbiksIDEwKSwgbiAqIDMgKyAxLCBiYik7XG4gICAgICAgIGkgKz0gbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgX1FyU2VnbWVudChfUXJTZWdtZW50Lk1vZGUuTlVNRVJJQywgZGlnaXRzLmxlbmd0aCwgYmIpO1xuICAgIH1cbiAgICBzdGF0aWMgbWFrZUFscGhhbnVtZXJpYyh0ZXh0KSB7XG4gICAgICBpZiAoIV9RclNlZ21lbnQuaXNBbHBoYW51bWVyaWModGV4dCkpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiU3RyaW5nIGNvbnRhaW5zIHVuZW5jb2RhYmxlIGNoYXJhY3RlcnMgaW4gYWxwaGFudW1lcmljIG1vZGVcIik7XG4gICAgICBsZXQgYmIgPSBbXTtcbiAgICAgIGxldCBpO1xuICAgICAgZm9yIChpID0gMDsgaSArIDIgPD0gdGV4dC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBsZXQgdGVtcCA9IF9RclNlZ21lbnQuQUxQSEFOVU1FUklDX0NIQVJTRVQuaW5kZXhPZih0ZXh0LmNoYXJBdChpKSkgKiA0NTtcbiAgICAgICAgdGVtcCArPSBfUXJTZWdtZW50LkFMUEhBTlVNRVJJQ19DSEFSU0VULmluZGV4T2YodGV4dC5jaGFyQXQoaSArIDEpKTtcbiAgICAgICAgYXBwZW5kQml0cyh0ZW1wLCAxMSwgYmIpO1xuICAgICAgfVxuICAgICAgaWYgKGkgPCB0ZXh0Lmxlbmd0aClcbiAgICAgICAgYXBwZW5kQml0cyhfUXJTZWdtZW50LkFMUEhBTlVNRVJJQ19DSEFSU0VULmluZGV4T2YodGV4dC5jaGFyQXQoaSkpLCA2LCBiYik7XG4gICAgICByZXR1cm4gbmV3IF9RclNlZ21lbnQoX1FyU2VnbWVudC5Nb2RlLkFMUEhBTlVNRVJJQywgdGV4dC5sZW5ndGgsIGJiKTtcbiAgICB9XG4gICAgc3RhdGljIG1ha2VTZWdtZW50cyh0ZXh0KSB7XG4gICAgICBpZiAodGV4dCA9PSBcIlwiKVxuICAgICAgICByZXR1cm4gW107XG4gICAgICBlbHNlIGlmIChfUXJTZWdtZW50LmlzTnVtZXJpYyh0ZXh0KSlcbiAgICAgICAgcmV0dXJuIFtfUXJTZWdtZW50Lm1ha2VOdW1lcmljKHRleHQpXTtcbiAgICAgIGVsc2UgaWYgKF9RclNlZ21lbnQuaXNBbHBoYW51bWVyaWModGV4dCkpXG4gICAgICAgIHJldHVybiBbX1FyU2VnbWVudC5tYWtlQWxwaGFudW1lcmljKHRleHQpXTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIFtfUXJTZWdtZW50Lm1ha2VCeXRlcyhfUXJTZWdtZW50LnRvVXRmOEJ5dGVBcnJheSh0ZXh0KSldO1xuICAgIH1cbiAgICBzdGF0aWMgbWFrZUVjaShhc3NpZ25WYWwpIHtcbiAgICAgIGxldCBiYiA9IFtdO1xuICAgICAgaWYgKGFzc2lnblZhbCA8IDApXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRUNJIGFzc2lnbm1lbnQgdmFsdWUgb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgZWxzZSBpZiAoYXNzaWduVmFsIDwgMSA8PCA3KVxuICAgICAgICBhcHBlbmRCaXRzKGFzc2lnblZhbCwgOCwgYmIpO1xuICAgICAgZWxzZSBpZiAoYXNzaWduVmFsIDwgMSA8PCAxNCkge1xuICAgICAgICBhcHBlbmRCaXRzKDIsIDIsIGJiKTtcbiAgICAgICAgYXBwZW5kQml0cyhhc3NpZ25WYWwsIDE0LCBiYik7XG4gICAgICB9IGVsc2UgaWYgKGFzc2lnblZhbCA8IDFlNikge1xuICAgICAgICBhcHBlbmRCaXRzKDYsIDMsIGJiKTtcbiAgICAgICAgYXBwZW5kQml0cyhhc3NpZ25WYWwsIDIxLCBiYik7XG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFQ0kgYXNzaWdubWVudCB2YWx1ZSBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICByZXR1cm4gbmV3IF9RclNlZ21lbnQoX1FyU2VnbWVudC5Nb2RlLkVDSSwgMCwgYmIpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNOdW1lcmljKHRleHQpIHtcbiAgICAgIHJldHVybiBfUXJTZWdtZW50Lk5VTUVSSUNfUkVHRVgudGVzdCh0ZXh0KTtcbiAgICB9XG4gICAgc3RhdGljIGlzQWxwaGFudW1lcmljKHRleHQpIHtcbiAgICAgIHJldHVybiBfUXJTZWdtZW50LkFMUEhBTlVNRVJJQ19SRUdFWC50ZXN0KHRleHQpO1xuICAgIH1cbiAgICBnZXREYXRhKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYml0RGF0YS5zbGljZSgpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0VG90YWxCaXRzKHNlZ3MsIHZlcnNpb24pIHtcbiAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgZm9yIChjb25zdCBzZWcgb2Ygc2Vncykge1xuICAgICAgICBjb25zdCBjY2JpdHMgPSBzZWcubW9kZS5udW1DaGFyQ291bnRCaXRzKHZlcnNpb24pO1xuICAgICAgICBpZiAoc2VnLm51bUNoYXJzID49IDEgPDwgY2NiaXRzKVxuICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgcmVzdWx0ICs9IDQgKyBjY2JpdHMgKyBzZWcuYml0RGF0YS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgdG9VdGY4Qnl0ZUFycmF5KHN0cikge1xuICAgICAgc3RyID0gZW5jb2RlVVJJKHN0cik7XG4gICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3RyLmNoYXJBdChpKSAhPSBcIiVcIilcbiAgICAgICAgICByZXN1bHQucHVzaChzdHIuY2hhckNvZGVBdChpKSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDEsIDIpLCAxNikpO1xuICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG4gIGxldCBRclNlZ21lbnQgPSBfUXJTZWdtZW50O1xuICBRclNlZ21lbnQuTlVNRVJJQ19SRUdFWCA9IC9eWzAtOV0qJC87XG4gIFFyU2VnbWVudC5BTFBIQU5VTUVSSUNfUkVHRVggPSAvXltBLVowLTkgJCUqKy5cXC86LV0qJC87XG4gIFFyU2VnbWVudC5BTFBIQU5VTUVSSUNfQ0hBUlNFVCA9IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaICQlKistLi86XCI7XG4gIHFyY29kZWdlbjIuUXJTZWdtZW50ID0gUXJTZWdtZW50O1xufSkocXJjb2RlZ2VuIHx8IChxcmNvZGVnZW4gPSB7fSkpO1xuKChxcmNvZGVnZW4yKSA9PiB7XG4gIGxldCBRckNvZGU7XG4gICgoUXJDb2RlMikgPT4ge1xuICAgIGNvbnN0IF9FY2MgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcihvcmRpbmFsLCBmb3JtYXRCaXRzKSB7XG4gICAgICAgIHRoaXMub3JkaW5hbCA9IG9yZGluYWw7XG4gICAgICAgIHRoaXMuZm9ybWF0Qml0cyA9IGZvcm1hdEJpdHM7XG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgRWNjID0gX0VjYztcbiAgICBFY2MuTE9XID0gbmV3IF9FY2MoMCwgMSk7XG4gICAgRWNjLk1FRElVTSA9IG5ldyBfRWNjKDEsIDApO1xuICAgIEVjYy5RVUFSVElMRSA9IG5ldyBfRWNjKDIsIDMpO1xuICAgIEVjYy5ISUdIID0gbmV3IF9FY2MoMywgMik7XG4gICAgUXJDb2RlMi5FY2MgPSBFY2M7XG4gIH0pKFFyQ29kZSA9IHFyY29kZWdlbjIuUXJDb2RlIHx8IChxcmNvZGVnZW4yLlFyQ29kZSA9IHt9KSk7XG59KShxcmNvZGVnZW4gfHwgKHFyY29kZWdlbiA9IHt9KSk7XG4oKHFyY29kZWdlbjIpID0+IHtcbiAgbGV0IFFyU2VnbWVudDtcbiAgKChRclNlZ21lbnQyKSA9PiB7XG4gICAgY29uc3QgX01vZGUgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3Rvcihtb2RlQml0cywgbnVtQml0c0NoYXJDb3VudCkge1xuICAgICAgICB0aGlzLm1vZGVCaXRzID0gbW9kZUJpdHM7XG4gICAgICAgIHRoaXMubnVtQml0c0NoYXJDb3VudCA9IG51bUJpdHNDaGFyQ291bnQ7XG4gICAgICB9XG4gICAgICBudW1DaGFyQ291bnRCaXRzKHZlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1CaXRzQ2hhckNvdW50W01hdGguZmxvb3IoKHZlciArIDcpIC8gMTcpXTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCBNb2RlID0gX01vZGU7XG4gICAgTW9kZS5OVU1FUklDID0gbmV3IF9Nb2RlKDEsIFsxMCwgMTIsIDE0XSk7XG4gICAgTW9kZS5BTFBIQU5VTUVSSUMgPSBuZXcgX01vZGUoMiwgWzksIDExLCAxM10pO1xuICAgIE1vZGUuQllURSA9IG5ldyBfTW9kZSg0LCBbOCwgMTYsIDE2XSk7XG4gICAgTW9kZS5LQU5KSSA9IG5ldyBfTW9kZSg4LCBbOCwgMTAsIDEyXSk7XG4gICAgTW9kZS5FQ0kgPSBuZXcgX01vZGUoNywgWzAsIDAsIDBdKTtcbiAgICBRclNlZ21lbnQyLk1vZGUgPSBNb2RlO1xuICB9KShRclNlZ21lbnQgPSBxcmNvZGVnZW4yLlFyU2VnbWVudCB8fCAocXJjb2RlZ2VuMi5RclNlZ21lbnQgPSB7fSkpO1xufSkocXJjb2RlZ2VuIHx8IChxcmNvZGVnZW4gPSB7fSkpO1xudmFyIHFyY29kZWdlbl9kZWZhdWx0ID0gcXJjb2RlZ2VuO1xuXG4vLyBzcmMvaW5kZXgudHN4XG4vKipcbiAqIEBsaWNlbnNlIHFyY29kZS5yZWFjdFxuICogQ29weXJpZ2h0IChjKSBQYXVsIE8nU2hhbm5lc3N5XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogSVNDXG4gKi9cbnZhciBFUlJPUl9MRVZFTF9NQVAgPSB7XG4gIEw6IHFyY29kZWdlbl9kZWZhdWx0LlFyQ29kZS5FY2MuTE9XLFxuICBNOiBxcmNvZGVnZW5fZGVmYXVsdC5RckNvZGUuRWNjLk1FRElVTSxcbiAgUTogcXJjb2RlZ2VuX2RlZmF1bHQuUXJDb2RlLkVjYy5RVUFSVElMRSxcbiAgSDogcXJjb2RlZ2VuX2RlZmF1bHQuUXJDb2RlLkVjYy5ISUdIXG59O1xudmFyIERFRkFVTFRfU0laRSA9IDEyODtcbnZhciBERUZBVUxUX0xFVkVMID0gXCJMXCI7XG52YXIgREVGQVVMVF9CR0NPTE9SID0gXCIjRkZGRkZGXCI7XG52YXIgREVGQVVMVF9GR0NPTE9SID0gXCIjMDAwMDAwXCI7XG52YXIgREVGQVVMVF9JTkNMVURFTUFSR0lOID0gZmFsc2U7XG52YXIgTUFSR0lOX1NJWkUgPSA0O1xudmFyIERFRkFVTFRfSU1HX1NDQUxFID0gMC4xO1xuZnVuY3Rpb24gZ2VuZXJhdGVQYXRoKG1vZHVsZXMsIG1hcmdpbiA9IDApIHtcbiAgY29uc3Qgb3BzID0gW107XG4gIG1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbihyb3csIHkpIHtcbiAgICBsZXQgc3RhcnQgPSBudWxsO1xuICAgIHJvdy5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwsIHgpIHtcbiAgICAgIGlmICghY2VsbCAmJiBzdGFydCAhPT0gbnVsbCkge1xuICAgICAgICBvcHMucHVzaChgTSR7c3RhcnQgKyBtYXJnaW59ICR7eSArIG1hcmdpbn1oJHt4IC0gc3RhcnR9djFIJHtzdGFydCArIG1hcmdpbn16YCk7XG4gICAgICAgIHN0YXJ0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHggPT09IHJvdy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGlmICghY2VsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPT09IG51bGwpIHtcbiAgICAgICAgICBvcHMucHVzaChgTSR7eCArIG1hcmdpbn0sJHt5ICsgbWFyZ2lufSBoMXYxSCR7eCArIG1hcmdpbn16YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3BzLnB1c2goYE0ke3N0YXJ0ICsgbWFyZ2lufSwke3kgKyBtYXJnaW59IGgke3ggKyAxIC0gc3RhcnR9djFIJHtzdGFydCArIG1hcmdpbn16YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNlbGwgJiYgc3RhcnQgPT09IG51bGwpIHtcbiAgICAgICAgc3RhcnQgPSB4O1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG9wcy5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gZXhjYXZhdGVNb2R1bGVzKG1vZHVsZXMsIGV4Y2F2YXRpb24pIHtcbiAgcmV0dXJuIG1vZHVsZXMuc2xpY2UoKS5tYXAoKHJvdywgeSkgPT4ge1xuICAgIGlmICh5IDwgZXhjYXZhdGlvbi55IHx8IHkgPj0gZXhjYXZhdGlvbi55ICsgZXhjYXZhdGlvbi5oKSB7XG4gICAgICByZXR1cm4gcm93O1xuICAgIH1cbiAgICByZXR1cm4gcm93Lm1hcCgoY2VsbCwgeCkgPT4ge1xuICAgICAgaWYgKHggPCBleGNhdmF0aW9uLnggfHwgeCA+PSBleGNhdmF0aW9uLnggKyBleGNhdmF0aW9uLncpIHtcbiAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0SW1hZ2VTZXR0aW5ncyhjZWxscywgc2l6ZSwgaW5jbHVkZU1hcmdpbiwgaW1hZ2VTZXR0aW5ncykge1xuICBpZiAoaW1hZ2VTZXR0aW5ncyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgbWFyZ2luID0gaW5jbHVkZU1hcmdpbiA/IE1BUkdJTl9TSVpFIDogMDtcbiAgY29uc3QgbnVtQ2VsbHMgPSBjZWxscy5sZW5ndGggKyBtYXJnaW4gKiAyO1xuICBjb25zdCBkZWZhdWx0U2l6ZSA9IE1hdGguZmxvb3Ioc2l6ZSAqIERFRkFVTFRfSU1HX1NDQUxFKTtcbiAgY29uc3Qgc2NhbGUgPSBudW1DZWxscyAvIHNpemU7XG4gIGNvbnN0IHcgPSAoaW1hZ2VTZXR0aW5ncy53aWR0aCB8fCBkZWZhdWx0U2l6ZSkgKiBzY2FsZTtcbiAgY29uc3QgaCA9IChpbWFnZVNldHRpbmdzLmhlaWdodCB8fCBkZWZhdWx0U2l6ZSkgKiBzY2FsZTtcbiAgY29uc3QgeCA9IGltYWdlU2V0dGluZ3MueCA9PSBudWxsID8gY2VsbHMubGVuZ3RoIC8gMiAtIHcgLyAyIDogaW1hZ2VTZXR0aW5ncy54ICogc2NhbGU7XG4gIGNvbnN0IHkgPSBpbWFnZVNldHRpbmdzLnkgPT0gbnVsbCA/IGNlbGxzLmxlbmd0aCAvIDIgLSBoIC8gMiA6IGltYWdlU2V0dGluZ3MueSAqIHNjYWxlO1xuICBsZXQgZXhjYXZhdGlvbiA9IG51bGw7XG4gIGlmIChpbWFnZVNldHRpbmdzLmV4Y2F2YXRlKSB7XG4gICAgbGV0IGZsb29yWCA9IE1hdGguZmxvb3IoeCk7XG4gICAgbGV0IGZsb29yWSA9IE1hdGguZmxvb3IoeSk7XG4gICAgbGV0IGNlaWxXID0gTWF0aC5jZWlsKHcgKyB4IC0gZmxvb3JYKTtcbiAgICBsZXQgY2VpbEggPSBNYXRoLmNlaWwoaCArIHkgLSBmbG9vclkpO1xuICAgIGV4Y2F2YXRpb24gPSB7IHg6IGZsb29yWCwgeTogZmxvb3JZLCB3OiBjZWlsVywgaDogY2VpbEggfTtcbiAgfVxuICByZXR1cm4geyB4LCB5LCBoLCB3LCBleGNhdmF0aW9uIH07XG59XG52YXIgU1VQUE9SVFNfUEFUSDJEID0gZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgbmV3IFBhdGgyRCgpLmFkZFBhdGgobmV3IFBhdGgyRCgpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn0oKTtcbmZ1bmN0aW9uIFFSQ29kZUNhbnZhcyhwcm9wcykge1xuICBjb25zdCBfYSA9IHByb3BzLCB7XG4gICAgdmFsdWUsXG4gICAgc2l6ZSA9IERFRkFVTFRfU0laRSxcbiAgICBsZXZlbCA9IERFRkFVTFRfTEVWRUwsXG4gICAgYmdDb2xvciA9IERFRkFVTFRfQkdDT0xPUixcbiAgICBmZ0NvbG9yID0gREVGQVVMVF9GR0NPTE9SLFxuICAgIGluY2x1ZGVNYXJnaW4gPSBERUZBVUxUX0lOQ0xVREVNQVJHSU4sXG4gICAgc3R5bGUsXG4gICAgaW1hZ2VTZXR0aW5nc1xuICB9ID0gX2EsIG90aGVyUHJvcHMgPSBfX29ialJlc3QoX2EsIFtcbiAgICBcInZhbHVlXCIsXG4gICAgXCJzaXplXCIsXG4gICAgXCJsZXZlbFwiLFxuICAgIFwiYmdDb2xvclwiLFxuICAgIFwiZmdDb2xvclwiLFxuICAgIFwiaW5jbHVkZU1hcmdpblwiLFxuICAgIFwic3R5bGVcIixcbiAgICBcImltYWdlU2V0dGluZ3NcIlxuICBdKTtcbiAgY29uc3QgaW1nU3JjID0gaW1hZ2VTZXR0aW5ncyA9PSBudWxsID8gdm9pZCAwIDogaW1hZ2VTZXR0aW5ncy5zcmM7XG4gIGNvbnN0IF9jYW52YXMgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IF9pbWFnZSA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgW2lzSW1nTG9hZGVkLCBzZXRJc0ltYWdlTG9hZGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoX2NhbnZhcy5jdXJyZW50ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IF9jYW52YXMuY3VycmVudDtcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBpZiAoIWN0eCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgY2VsbHMgPSBxcmNvZGVnZW5fZGVmYXVsdC5RckNvZGUuZW5jb2RlVGV4dCh2YWx1ZSwgRVJST1JfTEVWRUxfTUFQW2xldmVsXSkuZ2V0TW9kdWxlcygpO1xuICAgICAgY29uc3QgbWFyZ2luID0gaW5jbHVkZU1hcmdpbiA/IE1BUkdJTl9TSVpFIDogMDtcbiAgICAgIGNvbnN0IG51bUNlbGxzID0gY2VsbHMubGVuZ3RoICsgbWFyZ2luICogMjtcbiAgICAgIGNvbnN0IGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzID0gZ2V0SW1hZ2VTZXR0aW5ncyhjZWxscywgc2l6ZSwgaW5jbHVkZU1hcmdpbiwgaW1hZ2VTZXR0aW5ncyk7XG4gICAgICBjb25zdCBpbWFnZSA9IF9pbWFnZS5jdXJyZW50O1xuICAgICAgY29uc3QgaGF2ZUltYWdlVG9SZW5kZXIgPSBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncyAhPSBudWxsICYmIGltYWdlICE9PSBudWxsICYmIGltYWdlLmNvbXBsZXRlICYmIGltYWdlLm5hdHVyYWxIZWlnaHQgIT09IDAgJiYgaW1hZ2UubmF0dXJhbFdpZHRoICE9PSAwO1xuICAgICAgaWYgKGhhdmVJbWFnZVRvUmVuZGVyKSB7XG4gICAgICAgIGlmIChjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy5leGNhdmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICBjZWxscyA9IGV4Y2F2YXRlTW9kdWxlcyhjZWxscywgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MuZXhjYXZhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy53aWR0aCA9IHNpemUgKiBwaXhlbFJhdGlvO1xuICAgICAgY29uc3Qgc2NhbGUgPSBzaXplIC8gbnVtQ2VsbHMgKiBwaXhlbFJhdGlvO1xuICAgICAgY3R4LnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYmdDb2xvcjtcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBudW1DZWxscywgbnVtQ2VsbHMpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGZnQ29sb3I7XG4gICAgICBpZiAoU1VQUE9SVFNfUEFUSDJEKSB7XG4gICAgICAgIGN0eC5maWxsKG5ldyBQYXRoMkQoZ2VuZXJhdGVQYXRoKGNlbGxzLCBtYXJnaW4pKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjZWxscy5mb3JFYWNoKGZ1bmN0aW9uKHJvdywgcmR4KSB7XG4gICAgICAgICAgcm93LmZvckVhY2goZnVuY3Rpb24oY2VsbCwgY2R4KSB7XG4gICAgICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoY2R4ICsgbWFyZ2luLCByZHggKyBtYXJnaW4sIDEsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXZlSW1hZ2VUb1JlbmRlcikge1xuICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy54ICsgbWFyZ2luLCBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy55ICsgbWFyZ2luLCBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy53LCBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy5oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldElzSW1hZ2VMb2FkZWQoZmFsc2UpO1xuICB9LCBbaW1nU3JjXSk7XG4gIGNvbnN0IGNhbnZhc1N0eWxlID0gX19zcHJlYWRWYWx1ZXMoeyBoZWlnaHQ6IHNpemUsIHdpZHRoOiBzaXplIH0sIHN0eWxlKTtcbiAgbGV0IGltZyA9IG51bGw7XG4gIGlmIChpbWdTcmMgIT0gbnVsbCkge1xuICAgIGltZyA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIsIHtcbiAgICAgIHNyYzogaW1nU3JjLFxuICAgICAga2V5OiBpbWdTcmMsXG4gICAgICBzdHlsZTogeyBkaXNwbGF5OiBcIm5vbmVcIiB9LFxuICAgICAgb25Mb2FkOiAoKSA9PiB7XG4gICAgICAgIHNldElzSW1hZ2VMb2FkZWQodHJ1ZSk7XG4gICAgICB9LFxuICAgICAgcmVmOiBfaW1hZ2VcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIsIF9fc3ByZWFkVmFsdWVzKHtcbiAgICBzdHlsZTogY2FudmFzU3R5bGUsXG4gICAgaGVpZ2h0OiBzaXplLFxuICAgIHdpZHRoOiBzaXplLFxuICAgIHJlZjogX2NhbnZhc1xuICB9LCBvdGhlclByb3BzKSksIGltZyk7XG59XG5mdW5jdGlvbiBRUkNvZGVTVkcocHJvcHMpIHtcbiAgY29uc3QgX2EgPSBwcm9wcywge1xuICAgIHZhbHVlLFxuICAgIHNpemUgPSBERUZBVUxUX1NJWkUsXG4gICAgbGV2ZWwgPSBERUZBVUxUX0xFVkVMLFxuICAgIGJnQ29sb3IgPSBERUZBVUxUX0JHQ09MT1IsXG4gICAgZmdDb2xvciA9IERFRkFVTFRfRkdDT0xPUixcbiAgICBpbmNsdWRlTWFyZ2luID0gREVGQVVMVF9JTkNMVURFTUFSR0lOLFxuICAgIGltYWdlU2V0dGluZ3NcbiAgfSA9IF9hLCBvdGhlclByb3BzID0gX19vYmpSZXN0KF9hLCBbXG4gICAgXCJ2YWx1ZVwiLFxuICAgIFwic2l6ZVwiLFxuICAgIFwibGV2ZWxcIixcbiAgICBcImJnQ29sb3JcIixcbiAgICBcImZnQ29sb3JcIixcbiAgICBcImluY2x1ZGVNYXJnaW5cIixcbiAgICBcImltYWdlU2V0dGluZ3NcIlxuICBdKTtcbiAgbGV0IGNlbGxzID0gcXJjb2RlZ2VuX2RlZmF1bHQuUXJDb2RlLmVuY29kZVRleHQodmFsdWUsIEVSUk9SX0xFVkVMX01BUFtsZXZlbF0pLmdldE1vZHVsZXMoKTtcbiAgY29uc3QgbWFyZ2luID0gaW5jbHVkZU1hcmdpbiA/IE1BUkdJTl9TSVpFIDogMDtcbiAgY29uc3QgbnVtQ2VsbHMgPSBjZWxscy5sZW5ndGggKyBtYXJnaW4gKiAyO1xuICBjb25zdCBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncyA9IGdldEltYWdlU2V0dGluZ3MoY2VsbHMsIHNpemUsIGluY2x1ZGVNYXJnaW4sIGltYWdlU2V0dGluZ3MpO1xuICBsZXQgaW1hZ2UgPSBudWxsO1xuICBpZiAoaW1hZ2VTZXR0aW5ncyAhPSBudWxsICYmIGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzICE9IG51bGwpIHtcbiAgICBpZiAoY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MuZXhjYXZhdGlvbiAhPSBudWxsKSB7XG4gICAgICBjZWxscyA9IGV4Y2F2YXRlTW9kdWxlcyhjZWxscywgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MuZXhjYXZhdGlvbik7XG4gICAgfVxuICAgIGltYWdlID0gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbWFnZVwiLCB7XG4gICAgICB4bGlua0hyZWY6IGltYWdlU2V0dGluZ3Muc3JjLFxuICAgICAgaGVpZ2h0OiBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy5oLFxuICAgICAgd2lkdGg6IGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLncsXG4gICAgICB4OiBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy54ICsgbWFyZ2luLFxuICAgICAgeTogY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MueSArIG1hcmdpbixcbiAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IFwibm9uZVwiXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgZmdQYXRoID0gZ2VuZXJhdGVQYXRoKGNlbGxzLCBtYXJnaW4pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgX19zcHJlYWRWYWx1ZXMoe1xuICAgIGhlaWdodDogc2l6ZSxcbiAgICB3aWR0aDogc2l6ZSxcbiAgICB2aWV3Qm94OiBgMCAwICR7bnVtQ2VsbHN9ICR7bnVtQ2VsbHN9YFxuICB9LCBvdGhlclByb3BzKSwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBmaWxsOiBiZ0NvbG9yLFxuICAgIGQ6IGBNMCwwIGgke251bUNlbGxzfXYke251bUNlbGxzfUgwemAsXG4gICAgc2hhcGVSZW5kZXJpbmc6IFwiY3Jpc3BFZGdlc1wiXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGZpbGw6IGZnQ29sb3IsXG4gICAgZDogZmdQYXRoLFxuICAgIHNoYXBlUmVuZGVyaW5nOiBcImNyaXNwRWRnZXNcIlxuICB9KSwgaW1hZ2UpO1xufVxudmFyIFFSQ29kZSA9IChwcm9wcykgPT4ge1xuICBjb25zdCBfYSA9IHByb3BzLCB7IHJlbmRlckFzIH0gPSBfYSwgb3RoZXJQcm9wcyA9IF9fb2JqUmVzdChfYSwgW1wicmVuZGVyQXNcIl0pO1xuICBpZiAocmVuZGVyQXMgPT09IFwic3ZnXCIpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUVJDb2RlU1ZHLCBfX3NwcmVhZFZhbHVlcyh7fSwgb3RoZXJQcm9wcykpO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChRUkNvZGVDYW52YXMsIF9fc3ByZWFkVmFsdWVzKHt9LCBvdGhlclByb3BzKSk7XG59O1xuZXhwb3J0IHtcbiAgUVJDb2RlQ2FudmFzLFxuICBRUkNvZGVTVkcsXG4gIFFSQ29kZSBhcyBkZWZhdWx0XG59O1xuIl0sIm5hbWVzIjpbIl9fZGVmUHJvcCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX19nZXRPd25Qcm9wU3ltYm9scyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIl9faGFzT3duUHJvcCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiX19wcm9wSXNFbnVtIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfX2RlZk5vcm1hbFByb3AiLCJvYmoiLCJrZXkiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9fc3ByZWFkVmFsdWVzIiwiYSIsImIiLCJwcm9wIiwiY2FsbCIsIl9fb2JqUmVzdCIsInNvdXJjZSIsImV4Y2x1ZGUiLCJ0YXJnZXQiLCJpbmRleE9mIiwiUmVhY3QiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsInFyY29kZWdlbiIsInFyY29kZWdlbjIiLCJfUXJDb2RlIiwiY29uc3RydWN0b3IiLCJ2ZXJzaW9uIiwiZXJyb3JDb3JyZWN0aW9uTGV2ZWwiLCJkYXRhQ29kZXdvcmRzIiwibXNrIiwibW9kdWxlcyIsImlzRnVuY3Rpb24iLCJNSU5fVkVSU0lPTiIsIk1BWF9WRVJTSU9OIiwiUmFuZ2VFcnJvciIsInNpemUiLCJyb3ciLCJpIiwicHVzaCIsInNsaWNlIiwiZHJhd0Z1bmN0aW9uUGF0dGVybnMiLCJhbGxDb2Rld29yZHMiLCJhZGRFY2NBbmRJbnRlcmxlYXZlIiwiZHJhd0NvZGV3b3JkcyIsIm1pblBlbmFsdHkiLCJhcHBseU1hc2siLCJkcmF3Rm9ybWF0Qml0cyIsInBlbmFsdHkiLCJnZXRQZW5hbHR5U2NvcmUiLCJhc3NlcnQiLCJtYXNrIiwiZW5jb2RlVGV4dCIsInRleHQiLCJlY2wiLCJzZWdzIiwiUXJTZWdtZW50IiwibWFrZVNlZ21lbnRzIiwiZW5jb2RlU2VnbWVudHMiLCJlbmNvZGVCaW5hcnkiLCJkYXRhIiwic2VnIiwibWFrZUJ5dGVzIiwibWluVmVyc2lvbiIsIm1heFZlcnNpb24iLCJib29zdEVjbCIsImRhdGFVc2VkQml0cyIsImRhdGFDYXBhY2l0eUJpdHMyIiwiZ2V0TnVtRGF0YUNvZGV3b3JkcyIsInVzZWRCaXRzIiwiZ2V0VG90YWxCaXRzIiwibmV3RWNsIiwiRWNjIiwiTUVESVVNIiwiUVVBUlRJTEUiLCJISUdIIiwiYmIiLCJhcHBlbmRCaXRzIiwibW9kZSIsIm1vZGVCaXRzIiwibnVtQ2hhcnMiLCJudW1DaGFyQ291bnRCaXRzIiwiZ2V0RGF0YSIsImxlbmd0aCIsImRhdGFDYXBhY2l0eUJpdHMiLCJNYXRoIiwibWluIiwicGFkQnl0ZSIsImZvckVhY2giLCJnZXRNb2R1bGUiLCJ4IiwieSIsImdldE1vZHVsZXMiLCJzZXRGdW5jdGlvbk1vZHVsZSIsImRyYXdGaW5kZXJQYXR0ZXJuIiwiYWxpZ25QYXRQb3MiLCJnZXRBbGlnbm1lbnRQYXR0ZXJuUG9zaXRpb25zIiwibnVtQWxpZ24iLCJqIiwiZHJhd0FsaWdubWVudFBhdHRlcm4iLCJkcmF3VmVyc2lvbiIsImZvcm1hdEJpdHMiLCJyZW0iLCJiaXRzIiwiZ2V0Qml0IiwiY29sb3IiLCJmbG9vciIsImR5IiwiZHgiLCJkaXN0IiwibWF4IiwiYWJzIiwieHgiLCJ5eSIsImlzRGFyayIsInZlciIsIm51bUJsb2NrcyIsIk5VTV9FUlJPUl9DT1JSRUNUSU9OX0JMT0NLUyIsIm9yZGluYWwiLCJibG9ja0VjY0xlbiIsIkVDQ19DT0RFV09SRFNfUEVSX0JMT0NLIiwicmF3Q29kZXdvcmRzIiwiZ2V0TnVtUmF3RGF0YU1vZHVsZXMiLCJudW1TaG9ydEJsb2NrcyIsInNob3J0QmxvY2tMZW4iLCJibG9ja3MiLCJyc0RpdiIsInJlZWRTb2xvbW9uQ29tcHV0ZURpdmlzb3IiLCJrIiwiZGF0IiwiZWNjIiwicmVlZFNvbG9tb25Db21wdXRlUmVtYWluZGVyIiwiY29uY2F0IiwicmVzdWx0IiwiYmxvY2siLCJyaWdodCIsInZlcnQiLCJ1cHdhcmQiLCJpbnZlcnQiLCJFcnJvciIsInJ1bkNvbG9yIiwicnVuWCIsInJ1bkhpc3RvcnkiLCJQRU5BTFRZX04xIiwiZmluZGVyUGVuYWx0eUFkZEhpc3RvcnkiLCJmaW5kZXJQZW5hbHR5Q291bnRQYXR0ZXJucyIsIlBFTkFMVFlfTjMiLCJmaW5kZXJQZW5hbHR5VGVybWluYXRlQW5kQ291bnQiLCJydW5ZIiwiUEVOQUxUWV9OMiIsImRhcmsiLCJyZWR1Y2UiLCJzdW0iLCJ0b3RhbCIsImNlaWwiLCJQRU5BTFRZX040Iiwic3RlcCIsInBvcyIsInNwbGljZSIsImRlZ3JlZSIsInJvb3QiLCJyZWVkU29sb21vbk11bHRpcGx5IiwiZGl2aXNvciIsIm1hcCIsIl8iLCJmYWN0b3IiLCJzaGlmdCIsImNvZWYiLCJ6IiwibiIsImNvcmUiLCJjdXJyZW50UnVuQ29sb3IiLCJjdXJyZW50UnVuTGVuZ3RoIiwicG9wIiwidW5zaGlmdCIsIlFyQ29kZSIsInZhbCIsImxlbiIsImNvbmQiLCJfUXJTZWdtZW50IiwiYml0RGF0YSIsIk1vZGUiLCJCWVRFIiwibWFrZU51bWVyaWMiLCJkaWdpdHMiLCJpc051bWVyaWMiLCJwYXJzZUludCIsInN1YnN0ciIsIk5VTUVSSUMiLCJtYWtlQWxwaGFudW1lcmljIiwiaXNBbHBoYW51bWVyaWMiLCJ0ZW1wIiwiQUxQSEFOVU1FUklDX0NIQVJTRVQiLCJjaGFyQXQiLCJBTFBIQU5VTUVSSUMiLCJ0b1V0ZjhCeXRlQXJyYXkiLCJtYWtlRWNpIiwiYXNzaWduVmFsIiwiRUNJIiwiTlVNRVJJQ19SRUdFWCIsInRlc3QiLCJBTFBIQU5VTUVSSUNfUkVHRVgiLCJjY2JpdHMiLCJJbmZpbml0eSIsInN0ciIsImVuY29kZVVSSSIsImNoYXJDb2RlQXQiLCJRckNvZGUyIiwiX0VjYyIsIkxPVyIsIlFyU2VnbWVudDIiLCJfTW9kZSIsIm51bUJpdHNDaGFyQ291bnQiLCJLQU5KSSIsInFyY29kZWdlbl9kZWZhdWx0IiwiRVJST1JfTEVWRUxfTUFQIiwiTCIsIk0iLCJRIiwiSCIsIkRFRkFVTFRfU0laRSIsIkRFRkFVTFRfTEVWRUwiLCJERUZBVUxUX0JHQ09MT1IiLCJERUZBVUxUX0ZHQ09MT1IiLCJERUZBVUxUX0lOQ0xVREVNQVJHSU4iLCJNQVJHSU5fU0laRSIsIkRFRkFVTFRfSU1HX1NDQUxFIiwiZ2VuZXJhdGVQYXRoIiwibWFyZ2luIiwib3BzIiwic3RhcnQiLCJjZWxsIiwiam9pbiIsImV4Y2F2YXRlTW9kdWxlcyIsImV4Y2F2YXRpb24iLCJoIiwidyIsImdldEltYWdlU2V0dGluZ3MiLCJjZWxscyIsImluY2x1ZGVNYXJnaW4iLCJpbWFnZVNldHRpbmdzIiwibnVtQ2VsbHMiLCJkZWZhdWx0U2l6ZSIsInNjYWxlIiwid2lkdGgiLCJoZWlnaHQiLCJleGNhdmF0ZSIsImZsb29yWCIsImZsb29yWSIsImNlaWxXIiwiY2VpbEgiLCJTVVBQT1JUU19QQVRIMkQiLCJQYXRoMkQiLCJhZGRQYXRoIiwiZSIsIlFSQ29kZUNhbnZhcyIsInByb3BzIiwiX2EiLCJsZXZlbCIsImJnQ29sb3IiLCJmZ0NvbG9yIiwic3R5bGUiLCJvdGhlclByb3BzIiwiaW1nU3JjIiwic3JjIiwiX2NhbnZhcyIsIl9pbWFnZSIsImlzSW1nTG9hZGVkIiwic2V0SXNJbWFnZUxvYWRlZCIsImN1cnJlbnQiLCJjYW52YXMiLCJjdHgiLCJnZXRDb250ZXh0IiwiY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MiLCJpbWFnZSIsImhhdmVJbWFnZVRvUmVuZGVyIiwiY29tcGxldGUiLCJuYXR1cmFsSGVpZ2h0IiwibmF0dXJhbFdpZHRoIiwicGl4ZWxSYXRpbyIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImZpbGwiLCJyZHgiLCJjZHgiLCJkcmF3SW1hZ2UiLCJjYW52YXNTdHlsZSIsImltZyIsImNyZWF0ZUVsZW1lbnQiLCJkaXNwbGF5Iiwib25Mb2FkIiwicmVmIiwiRnJhZ21lbnQiLCJRUkNvZGVTVkciLCJ4bGlua0hyZWYiLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIiwiZmdQYXRoIiwidmlld0JveCIsImQiLCJzaGFwZVJlbmRlcmluZyIsIlFSQ29kZSIsInJlbmRlckFzIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/qrcode.react/lib/esm/index.js\n");

/***/ })

};
;