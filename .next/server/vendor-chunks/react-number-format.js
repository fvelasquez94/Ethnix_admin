"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-number-format";
exports.ids = ["vendor-chunks/react-number-format"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-number-format/dist/react-number-format.es.js":
/*!*************************************************************************!*\
  !*** ./node_modules/react-number-format/dist/react-number-format.es.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NumberFormatBase: () => (/* binding */ NumberFormatBase),\n/* harmony export */   NumericFormat: () => (/* binding */ NumericFormat),\n/* harmony export */   PatternFormat: () => (/* binding */ PatternFormat),\n/* harmony export */   getNumericCaretBoundary: () => (/* binding */ getCaretBoundary),\n/* harmony export */   getPatternCaretBoundary: () => (/* binding */ getCaretBoundary$1),\n/* harmony export */   numericFormatter: () => (/* binding */ format),\n/* harmony export */   patternFormatter: () => (/* binding */ format$1),\n/* harmony export */   removeNumericFormat: () => (/* binding */ removeFormatting),\n/* harmony export */   removePatternFormat: () => (/* binding */ removeFormatting$1),\n/* harmony export */   useNumericFormat: () => (/* binding */ useNumericFormat),\n/* harmony export */   usePatternFormat: () => (/* binding */ usePatternFormat)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * react-number-format - 5.1.4\n * Author : Sudhanshu Yadav\n * Copyright (c) 2016, 2023 to Sudhanshu Yadav, released under the MIT license.\n * https://github.com/s-yadav/react-number-format\n */ \n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __rest(s, e) {\n    var t = {};\n    for(var p in s){\n        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) {\n            t[p] = s[p];\n        }\n    }\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") {\n        for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) {\n                t[p[i]] = s[p[i]];\n            }\n        }\n    }\n    return t;\n}\nvar SourceType;\n(function(SourceType) {\n    SourceType[\"event\"] = \"event\";\n    SourceType[\"props\"] = \"prop\";\n})(SourceType || (SourceType = {}));\n// basic noop function\nfunction noop() {}\nfunction charIsNumber(char) {\n    return !!(char || \"\").match(/\\d/);\n}\nfunction isNil(val) {\n    return val === null || val === undefined;\n}\nfunction isNanValue(val) {\n    return typeof val === \"number\" && isNaN(val);\n}\nfunction escapeRegExp(str) {\n    return str.replace(/[-[\\]/{}()*+?.\\\\^$|]/g, \"\\\\$&\");\n}\nfunction getThousandsGroupRegex(thousandsGroupStyle) {\n    switch(thousandsGroupStyle){\n        case \"lakh\":\n            return /(\\d+?)(?=(\\d\\d)+(\\d)(?!\\d))(\\.\\d+)?/g;\n        case \"wan\":\n            return /(\\d)(?=(\\d{4})+(?!\\d))/g;\n        case \"thousand\":\n        default:\n            return /(\\d)(?=(\\d{3})+(?!\\d))/g;\n    }\n}\nfunction applyThousandSeparator(str, thousandSeparator, thousandsGroupStyle) {\n    var thousandsGroupRegex = getThousandsGroupRegex(thousandsGroupStyle);\n    var index = str.search(/[1-9]/);\n    index = index === -1 ? str.length : index;\n    return str.substring(0, index) + str.substring(index, str.length).replace(thousandsGroupRegex, \"$1\" + thousandSeparator);\n}\nfunction usePersistentCallback(cb) {\n    var callbackRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(cb);\n    // keep the callback ref upto date\n    callbackRef.current = cb;\n    /**\n     * initialize a persistent callback which never changes\n     * through out the component lifecycle\n     */ var persistentCbRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(function() {\n        var args = [], len = arguments.length;\n        while(len--)args[len] = arguments[len];\n        return callbackRef.current.apply(callbackRef, args);\n    });\n    return persistentCbRef.current;\n}\n//spilt a float number into different parts beforeDecimal, afterDecimal, and negation\nfunction splitDecimal(numStr, allowNegative) {\n    if (allowNegative === void 0) allowNegative = true;\n    var hasNegation = numStr[0] === \"-\";\n    var addNegation = hasNegation && allowNegative;\n    numStr = numStr.replace(\"-\", \"\");\n    var parts = numStr.split(\".\");\n    var beforeDecimal = parts[0];\n    var afterDecimal = parts[1] || \"\";\n    return {\n        beforeDecimal: beforeDecimal,\n        afterDecimal: afterDecimal,\n        hasNegation: hasNegation,\n        addNegation: addNegation\n    };\n}\nfunction fixLeadingZero(numStr) {\n    if (!numStr) {\n        return numStr;\n    }\n    var isNegative = numStr[0] === \"-\";\n    if (isNegative) {\n        numStr = numStr.substring(1, numStr.length);\n    }\n    var parts = numStr.split(\".\");\n    var beforeDecimal = parts[0].replace(/^0+/, \"\") || \"0\";\n    var afterDecimal = parts[1] || \"\";\n    return \"\" + (isNegative ? \"-\" : \"\") + beforeDecimal + (afterDecimal ? \".\" + afterDecimal : \"\");\n}\n/**\n * limit decimal numbers to given scale\n * Not used .fixedTo because that will break with big numbers\n */ function limitToScale(numStr, scale, fixedDecimalScale) {\n    var str = \"\";\n    var filler = fixedDecimalScale ? \"0\" : \"\";\n    for(var i = 0; i <= scale - 1; i++){\n        str += numStr[i] || filler;\n    }\n    return str;\n}\nfunction repeat(str, count) {\n    return Array(count + 1).join(str);\n}\nfunction toNumericString(num) {\n    var _num = num + \"\"; // typecast number to string\n    // store the sign and remove it from the number.\n    var sign = _num[0] === \"-\" ? \"-\" : \"\";\n    if (sign) {\n        _num = _num.substring(1);\n    }\n    // split the number into cofficient and exponent\n    var ref = _num.split(/[eE]/g);\n    var coefficient = ref[0];\n    var exponent = ref[1];\n    // covert exponent to number;\n    exponent = Number(exponent);\n    // if there is no exponent part or its 0, return the coffiecient with sign\n    if (!exponent) {\n        return sign + coefficient;\n    }\n    coefficient = coefficient.replace(\".\", \"\");\n    /**\n     * for scientific notation the current decimal index will be after first number (index 0)\n     * So effective decimal index will always be 1 + exponent value\n     */ var decimalIndex = 1 + exponent;\n    var coffiecientLn = coefficient.length;\n    if (decimalIndex < 0) {\n        // if decimal index is less then 0 add preceding 0s\n        // add 1 as join will have\n        coefficient = \"0.\" + repeat(\"0\", Math.abs(decimalIndex)) + coefficient;\n    } else if (decimalIndex >= coffiecientLn) {\n        // if decimal index is less then 0 add leading 0s\n        coefficient = coefficient + repeat(\"0\", decimalIndex - coffiecientLn);\n    } else {\n        // else add decimal point at proper index\n        coefficient = (coefficient.substring(0, decimalIndex) || \"0\") + \".\" + coefficient.substring(decimalIndex);\n    }\n    return sign + coefficient;\n}\n/**\n * This method is required to round prop value to given scale.\n * Not used .round or .fixedTo because that will break with big numbers\n */ function roundToPrecision(numStr, scale, fixedDecimalScale) {\n    //if number is empty don't do anything return empty string\n    if ([\n        \"\",\n        \"-\"\n    ].indexOf(numStr) !== -1) {\n        return numStr;\n    }\n    var shouldHaveDecimalSeparator = (numStr.indexOf(\".\") !== -1 || fixedDecimalScale) && scale;\n    var ref = splitDecimal(numStr);\n    var beforeDecimal = ref.beforeDecimal;\n    var afterDecimal = ref.afterDecimal;\n    var hasNegation = ref.hasNegation;\n    var floatValue = parseFloat(\"0.\" + (afterDecimal || \"0\"));\n    var floatValueStr = afterDecimal.length <= scale ? \"0.\" + afterDecimal : floatValue.toFixed(scale);\n    var roundedDecimalParts = floatValueStr.split(\".\");\n    var intPart = beforeDecimal.split(\"\").reverse().reduce(function(roundedStr, current, idx) {\n        if (roundedStr.length > idx) {\n            return (Number(roundedStr[0]) + Number(current)).toString() + roundedStr.substring(1, roundedStr.length);\n        }\n        return current + roundedStr;\n    }, roundedDecimalParts[0]);\n    var decimalPart = limitToScale(roundedDecimalParts[1] || \"\", scale, fixedDecimalScale);\n    var negation = hasNegation ? \"-\" : \"\";\n    var decimalSeparator = shouldHaveDecimalSeparator ? \".\" : \"\";\n    return \"\" + negation + intPart + decimalSeparator + decimalPart;\n}\n/** set the caret positon in an input field **/ function setCaretPosition(el, caretPos) {\n    el.value = el.value;\n    // ^ this is used to not only get 'focus', but\n    // to make sure we don't have it everything -selected-\n    // (it causes an issue in chrome, and having it doesn't hurt any other browser)\n    if (el !== null) {\n        /* @ts-ignore */ if (el.createTextRange) {\n            /* @ts-ignore */ var range = el.createTextRange();\n            range.move(\"character\", caretPos);\n            range.select();\n            return true;\n        }\n        // (el.selectionStart === 0 added for Firefox bug)\n        if (el.selectionStart || el.selectionStart === 0) {\n            el.focus();\n            el.setSelectionRange(caretPos, caretPos);\n            return true;\n        }\n        // fail city, fortunately this never happens (as far as I've tested) :)\n        el.focus();\n        return false;\n    }\n}\nfunction findChangeRange(prevValue, newValue) {\n    var i = 0, j = 0;\n    var prevLength = prevValue.length;\n    var newLength = newValue.length;\n    while(prevValue[i] === newValue[i] && i < prevLength){\n        i++;\n    }\n    //check what has been changed from last\n    while(prevValue[prevLength - 1 - j] === newValue[newLength - 1 - j] && newLength - j > i && prevLength - j > i){\n        j++;\n    }\n    return {\n        from: {\n            start: i,\n            end: prevLength - j\n        },\n        to: {\n            start: i,\n            end: newLength - j\n        }\n    };\n}\n/*\n  Returns a number whose value is limited to the given range\n*/ function clamp(num, min, max) {\n    return Math.min(Math.max(num, min), max);\n}\nfunction geInputCaretPosition(el) {\n    /*Max of selectionStart and selectionEnd is taken for the patch of pixel and other mobile device caret bug*/ return Math.max(el.selectionStart, el.selectionEnd);\n}\nfunction addInputMode() {\n    return typeof navigator !== \"undefined\" && !(navigator.platform && /iPhone|iPod/.test(navigator.platform));\n}\nfunction getDefaultChangeMeta(value) {\n    return {\n        from: {\n            start: 0,\n            end: 0\n        },\n        to: {\n            start: 0,\n            end: value.length\n        },\n        lastValue: \"\"\n    };\n}\nfunction getMaskAtIndex(mask, index) {\n    if (mask === void 0) mask = \" \";\n    if (typeof mask === \"string\") {\n        return mask;\n    }\n    return mask[index] || \" \";\n}\nfunction getCaretPosition(newFormattedValue, lastFormattedValue, curValue, curCaretPos, boundary, isValidInputCharacter) {\n    /**\n     * if something got inserted on empty value, add the formatted character before the current value,\n     * This is to avoid the case where typed character is present on format characters\n     */ var firstAllowedPosition = boundary.findIndex(function(b) {\n        return b;\n    });\n    var prefixFormat = newFormattedValue.slice(0, firstAllowedPosition);\n    if (!lastFormattedValue && !curValue.startsWith(prefixFormat)) {\n        curValue = prefixFormat + curValue;\n        curCaretPos = curCaretPos + prefixFormat.length;\n    }\n    var curValLn = curValue.length;\n    var formattedValueLn = newFormattedValue.length;\n    // create index map\n    var addedIndexMap = {};\n    var indexMap = new Array(curValLn);\n    for(var i = 0; i < curValLn; i++){\n        indexMap[i] = -1;\n        for(var j = 0, jLn = formattedValueLn; j < jLn; j++){\n            if (curValue[i] === newFormattedValue[j] && addedIndexMap[j] !== true) {\n                indexMap[i] = j;\n                addedIndexMap[j] = true;\n                break;\n            }\n        }\n    }\n    /**\n     * For current caret position find closest characters (left and right side)\n     * which are properly mapped to formatted value.\n     * The idea is that the new caret position will exist always in the boundary of\n     * that mapped index\n     */ var pos = curCaretPos;\n    while(pos < curValLn && (indexMap[pos] === -1 || !isValidInputCharacter(curValue[pos]))){\n        pos++;\n    }\n    // if the caret position is on last keep the endIndex as last for formatted value\n    var endIndex = pos === curValLn || indexMap[pos] === -1 ? formattedValueLn : indexMap[pos];\n    pos = curCaretPos - 1;\n    while(pos > 0 && indexMap[pos] === -1){\n        pos--;\n    }\n    var startIndex = pos === -1 || indexMap[pos] === -1 ? 0 : indexMap[pos] + 1;\n    /**\n     * case where a char is added on suffix and removed from middle, example 2sq345 becoming $2,345 sq\n     * there is still a mapping but the order of start index and end index is changed\n     */ if (startIndex > endIndex) {\n        return endIndex;\n    }\n    /**\n     * given the current caret position if it closer to startIndex\n     * keep the new caret position on start index or keep it closer to endIndex\n     */ return curCaretPos - startIndex < endIndex - curCaretPos ? startIndex : endIndex;\n}\n/* This keeps the caret within typing area so people can't type in between prefix or suffix or format characters */ function getCaretPosInBoundary(value, caretPos, boundary, direction) {\n    var valLn = value.length;\n    // clamp caret position to [0, value.length]\n    caretPos = clamp(caretPos, 0, valLn);\n    if (direction === \"left\") {\n        while(caretPos >= 0 && !boundary[caretPos]){\n            caretPos--;\n        }\n        // if we don't find any suitable caret position on left, set it on first allowed position\n        if (caretPos === -1) {\n            caretPos = boundary.indexOf(true);\n        }\n    } else {\n        while(caretPos <= valLn && !boundary[caretPos]){\n            caretPos++;\n        }\n        // if we don't find any suitable caret position on right, set it on last allowed position\n        if (caretPos > valLn) {\n            caretPos = boundary.lastIndexOf(true);\n        }\n    }\n    // if we still don't find caret position, set it at the end of value\n    if (caretPos === -1) {\n        caretPos = valLn;\n    }\n    return caretPos;\n}\nfunction caretUnknownFormatBoundary(formattedValue) {\n    var boundaryAry = Array.from({\n        length: formattedValue.length + 1\n    }).map(function() {\n        return true;\n    });\n    for(var i = 0, ln = boundaryAry.length; i < ln; i++){\n        // consider caret to be in boundary if it is before or after numeric value\n        boundaryAry[i] = Boolean(charIsNumber(formattedValue[i]) || charIsNumber(formattedValue[i - 1]));\n    }\n    return boundaryAry;\n}\nfunction useInternalValues(value, defaultValue, valueIsNumericString, format, removeFormatting, onValueChange) {\n    if (onValueChange === void 0) onValueChange = noop;\n    var propValues = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    var getValues = usePersistentCallback(function(value) {\n        var formattedValue, numAsString;\n        if (isNil(value) || isNanValue(value)) {\n            numAsString = \"\";\n            formattedValue = \"\";\n        } else if (typeof value === \"number\" || valueIsNumericString) {\n            numAsString = typeof value === \"number\" ? toNumericString(value) : value;\n            formattedValue = format(numAsString);\n        } else {\n            numAsString = removeFormatting(value, undefined);\n            formattedValue = value;\n        }\n        return {\n            formattedValue: formattedValue,\n            numAsString: numAsString\n        };\n    });\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(function() {\n        return getValues(defaultValue);\n    });\n    var values = ref[0];\n    var setValues = ref[1];\n    var _onValueChange = function(values, sourceInfo) {\n        setValues({\n            formattedValue: values.formattedValue,\n            numAsString: values.value\n        });\n        onValueChange(values, sourceInfo);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function() {\n        //if element is moved to uncontrolled mode, don't reset the value\n        if (!isNil(value)) {\n            propValues.current = getValues(value);\n            setValues(propValues.current);\n        } else {\n            propValues.current = undefined;\n        }\n    }, [\n        value,\n        getValues\n    ]);\n    return [\n        values,\n        _onValueChange\n    ];\n}\nfunction defaultRemoveFormatting(value) {\n    return value.replace(/[^0-9]/g, \"\");\n}\nfunction defaultFormat(value) {\n    return value;\n}\nfunction NumberFormatBase(props) {\n    var type = props.type;\n    if (type === void 0) type = \"text\";\n    var displayType = props.displayType;\n    if (displayType === void 0) displayType = \"input\";\n    var customInput = props.customInput;\n    var renderText = props.renderText;\n    var getInputRef = props.getInputRef;\n    var format = props.format;\n    if (format === void 0) format = defaultFormat;\n    var removeFormatting = props.removeFormatting;\n    if (removeFormatting === void 0) removeFormatting = defaultRemoveFormatting;\n    var defaultValue = props.defaultValue;\n    var valueIsNumericString = props.valueIsNumericString;\n    var onValueChange = props.onValueChange;\n    var isAllowed = props.isAllowed;\n    var onChange = props.onChange;\n    if (onChange === void 0) onChange = noop;\n    var onKeyDown = props.onKeyDown;\n    if (onKeyDown === void 0) onKeyDown = noop;\n    var onMouseUp = props.onMouseUp;\n    if (onMouseUp === void 0) onMouseUp = noop;\n    var onFocus = props.onFocus;\n    if (onFocus === void 0) onFocus = noop;\n    var onBlur = props.onBlur;\n    if (onBlur === void 0) onBlur = noop;\n    var propValue = props.value;\n    var getCaretBoundary = props.getCaretBoundary;\n    if (getCaretBoundary === void 0) getCaretBoundary = caretUnknownFormatBoundary;\n    var isValidInputCharacter = props.isValidInputCharacter;\n    if (isValidInputCharacter === void 0) isValidInputCharacter = charIsNumber;\n    var otherProps = __rest(props, [\n        \"type\",\n        \"displayType\",\n        \"customInput\",\n        \"renderText\",\n        \"getInputRef\",\n        \"format\",\n        \"removeFormatting\",\n        \"defaultValue\",\n        \"valueIsNumericString\",\n        \"onValueChange\",\n        \"isAllowed\",\n        \"onChange\",\n        \"onKeyDown\",\n        \"onMouseUp\",\n        \"onFocus\",\n        \"onBlur\",\n        \"value\",\n        \"getCaretBoundary\",\n        \"isValidInputCharacter\"\n    ]);\n    var ref = useInternalValues(propValue, defaultValue, Boolean(valueIsNumericString), format, removeFormatting, onValueChange);\n    var ref_0 = ref[0];\n    var formattedValue = ref_0.formattedValue;\n    var numAsString = ref_0.numAsString;\n    var onFormattedValueChange = ref[1];\n    var lastUpdatedValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    var _onValueChange = function(values, source) {\n        lastUpdatedValue.current = values.formattedValue;\n        onFormattedValueChange(values, source);\n    };\n    // check if there is any change in the value due to props change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        var newFormattedValue = format(numAsString);\n        // if the formatted value is not synced to parent, or if the formatted value is different\n        if (lastUpdatedValue.current === undefined || newFormattedValue !== lastUpdatedValue.current) {\n            var input = focusedElm.current;\n            // formatting can remove some of the number chars, so we need to fine number string again\n            var _numAsString = removeFormatting(newFormattedValue, undefined);\n            updateValue({\n                formattedValue: newFormattedValue,\n                numAsString: _numAsString,\n                input: input,\n                setCaretPosition: true,\n                source: SourceType.props,\n                event: undefined\n            });\n        }\n    });\n    var ref$1 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    var mounted = ref$1[0];\n    var setMounted = ref$1[1];\n    var focusedElm = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var timeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        setCaretTimeout: null,\n        focusTimeout: null\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        setMounted(true);\n        return function() {\n            clearTimeout(timeout.current.setCaretTimeout);\n            clearTimeout(timeout.current.focusTimeout);\n        };\n    }, []);\n    var _format = format;\n    var getValueObject = function(formattedValue, numAsString) {\n        var floatValue = parseFloat(numAsString);\n        return {\n            formattedValue: formattedValue,\n            value: numAsString,\n            floatValue: isNaN(floatValue) ? undefined : floatValue\n        };\n    };\n    var setPatchedCaretPosition = function(el, caretPos, currentValue) {\n        /* setting caret position within timeout of 0ms is required for mobile chrome,\n        otherwise browser resets the caret position after we set it\n        We are also setting it without timeout so that in normal browser we don't see the flickering */ setCaretPosition(el, caretPos);\n        timeout.current.setCaretTimeout = setTimeout(function() {\n            if (el.value === currentValue) {\n                setCaretPosition(el, caretPos);\n            }\n        }, 0);\n    };\n    /* This keeps the caret within typing area so people can't type in between prefix or suffix */ var correctCaretPosition = function(value, caretPos, direction) {\n        return getCaretPosInBoundary(value, caretPos, getCaretBoundary(value), direction);\n    };\n    var getNewCaretPosition = function(inputValue, newFormattedValue, caretPos) {\n        var caretBoundary = getCaretBoundary(newFormattedValue);\n        var updatedCaretPos = getCaretPosition(newFormattedValue, formattedValue, inputValue, caretPos, caretBoundary, isValidInputCharacter);\n        //correct caret position if its outside of editable area\n        updatedCaretPos = getCaretPosInBoundary(newFormattedValue, updatedCaretPos, caretBoundary);\n        return updatedCaretPos;\n    };\n    var updateValue = function(params) {\n        var newFormattedValue = params.formattedValue;\n        if (newFormattedValue === void 0) newFormattedValue = \"\";\n        var input = params.input;\n        var setCaretPosition = params.setCaretPosition;\n        if (setCaretPosition === void 0) setCaretPosition = true;\n        var source = params.source;\n        var event = params.event;\n        var numAsString = params.numAsString;\n        var caretPos = params.caretPos;\n        if (input) {\n            //calculate caret position if not defined\n            if (caretPos === undefined && setCaretPosition) {\n                var inputValue = params.inputValue || input.value;\n                var currentCaretPosition = geInputCaretPosition(input);\n                /**\n                 * set the value imperatively, this is required for IE fix\n                 * This is also required as if new caret position is beyond the previous value.\n                 * Caret position will not be set correctly\n                 */ input.value = newFormattedValue;\n                //get the caret position\n                caretPos = getNewCaretPosition(inputValue, newFormattedValue, currentCaretPosition);\n            }\n            /**\n             * set the value imperatively, as we set the caret position as well imperatively.\n             * This is to keep value and caret position in sync\n             */ input.value = newFormattedValue;\n            //set caret position, and value imperatively when element is provided\n            if (setCaretPosition && caretPos !== undefined) {\n                //set caret position\n                setPatchedCaretPosition(input, caretPos, newFormattedValue);\n            }\n        }\n        if (newFormattedValue !== formattedValue) {\n            // trigger onValueChange synchronously, so parent is updated along with the number format. Fix for #277, #287\n            _onValueChange(getValueObject(newFormattedValue, numAsString), {\n                event: event,\n                source: source\n            });\n        }\n    };\n    var formatInputValue = function(inputValue, event, source) {\n        var changeRange = findChangeRange(formattedValue, inputValue);\n        var changeMeta = Object.assign(Object.assign({}, changeRange), {\n            lastValue: formattedValue\n        });\n        var _numAsString = removeFormatting(inputValue, changeMeta);\n        var _formattedValue = _format(_numAsString);\n        // formatting can remove some of the number chars, so we need to fine number string again\n        _numAsString = removeFormatting(_formattedValue, undefined);\n        if (isAllowed && !isAllowed(getValueObject(_formattedValue, _numAsString))) {\n            //reset the caret position\n            var input = event.target;\n            var currentCaretPosition = geInputCaretPosition(input);\n            var caretPos = getNewCaretPosition(inputValue, formattedValue, currentCaretPosition);\n            setPatchedCaretPosition(input, caretPos, formattedValue);\n            return false;\n        }\n        updateValue({\n            formattedValue: _formattedValue,\n            numAsString: _numAsString,\n            inputValue: inputValue,\n            event: event,\n            source: source,\n            setCaretPosition: true,\n            input: event.target\n        });\n        return true;\n    };\n    var _onChange = function(e) {\n        var el = e.target;\n        var inputValue = el.value;\n        var changed = formatInputValue(inputValue, e, SourceType.event);\n        if (changed) {\n            onChange(e);\n        }\n    };\n    var _onKeyDown = function(e) {\n        var el = e.target;\n        var key = e.key;\n        var selectionStart = el.selectionStart;\n        var selectionEnd = el.selectionEnd;\n        var value = el.value;\n        if (value === void 0) value = \"\";\n        var expectedCaretPosition;\n        //Handle backspace and delete against non numerical/decimal characters or arrow keys\n        if (key === \"ArrowLeft\" || key === \"Backspace\") {\n            expectedCaretPosition = Math.max(selectionStart - 1, 0);\n        } else if (key === \"ArrowRight\") {\n            expectedCaretPosition = Math.min(selectionStart + 1, value.length);\n        } else if (key === \"Delete\") {\n            expectedCaretPosition = selectionStart;\n        }\n        //if expectedCaretPosition is not set it means we don't want to Handle keyDown\n        // also if multiple characters are selected don't handle\n        if (expectedCaretPosition === undefined || selectionStart !== selectionEnd) {\n            onKeyDown(e);\n            return;\n        }\n        var newCaretPosition = expectedCaretPosition;\n        if (key === \"ArrowLeft\" || key === \"ArrowRight\") {\n            var direction = key === \"ArrowLeft\" ? \"left\" : \"right\";\n            newCaretPosition = correctCaretPosition(value, expectedCaretPosition, direction);\n        } else if (key === \"Delete\" && !isValidInputCharacter(value[expectedCaretPosition])) {\n            // in case of delete go to closest caret boundary on the right side\n            newCaretPosition = correctCaretPosition(value, expectedCaretPosition, \"right\");\n        } else if (key === \"Backspace\" && !isValidInputCharacter(value[expectedCaretPosition])) {\n            // in case of backspace go to closest caret boundary on the left side\n            newCaretPosition = correctCaretPosition(value, expectedCaretPosition, \"left\");\n        }\n        if (newCaretPosition !== expectedCaretPosition) {\n            setPatchedCaretPosition(el, newCaretPosition, value);\n        }\n        /* NOTE: this is just required for unit test as we need to get the newCaretPosition,\n                Remove this when you find different solution */ /* @ts-ignore */ if (e.isUnitTestRun) {\n            setPatchedCaretPosition(el, newCaretPosition, value);\n        }\n        onKeyDown(e);\n    };\n    /** required to handle the caret position when click anywhere within the input **/ var _onMouseUp = function(e) {\n        var el = e.target;\n        /**\n         * NOTE: we have to give default value for value as in case when custom input is provided\n         * value can come as undefined when nothing is provided on value prop.\n         */ var selectionStart = el.selectionStart;\n        var selectionEnd = el.selectionEnd;\n        var value = el.value;\n        if (value === void 0) value = \"\";\n        if (selectionStart === selectionEnd) {\n            var caretPosition = correctCaretPosition(value, selectionStart);\n            if (caretPosition !== selectionStart) {\n                setPatchedCaretPosition(el, caretPosition, value);\n            }\n        }\n        onMouseUp(e);\n    };\n    var _onFocus = function(e) {\n        // Workaround Chrome and Safari bug https://bugs.chromium.org/p/chromium/issues/detail?id=779328\n        // (onFocus event target selectionStart is always 0 before setTimeout)\n        if (e.persist) {\n            e.persist();\n        }\n        var el = e.target;\n        focusedElm.current = el;\n        timeout.current.focusTimeout = setTimeout(function() {\n            var selectionStart = el.selectionStart;\n            var selectionEnd = el.selectionEnd;\n            var value = el.value;\n            if (value === void 0) value = \"\";\n            var caretPosition = correctCaretPosition(value, selectionStart);\n            //setPatchedCaretPosition only when everything is not selected on focus (while tabbing into the field)\n            if (caretPosition !== selectionStart && !(selectionStart === 0 && selectionEnd === value.length)) {\n                setPatchedCaretPosition(el, caretPosition, value);\n            }\n            onFocus(e);\n        }, 0);\n    };\n    var _onBlur = function(e) {\n        focusedElm.current = null;\n        clearTimeout(timeout.current.focusTimeout);\n        clearTimeout(timeout.current.setCaretTimeout);\n        onBlur(e);\n    };\n    // add input mode on element based on format prop and device once the component is mounted\n    var inputMode = mounted && addInputMode() ? \"numeric\" : undefined;\n    var inputProps = Object.assign({\n        inputMode: inputMode\n    }, otherProps, {\n        type: type,\n        value: formattedValue,\n        onChange: _onChange,\n        onKeyDown: _onKeyDown,\n        onMouseUp: _onMouseUp,\n        onFocus: _onFocus,\n        onBlur: _onBlur\n    });\n    if (displayType === \"text\") {\n        return renderText ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, renderText(formattedValue, otherProps) || null) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", Object.assign({}, otherProps, {\n            ref: getInputRef\n        }), formattedValue);\n    } else if (customInput) {\n        var CustomInput = customInput;\n        /* @ts-ignore */ return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(CustomInput, Object.assign({}, inputProps, {\n            ref: getInputRef\n        }));\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"input\", Object.assign({}, inputProps, {\n        ref: getInputRef\n    }));\n}\nfunction format(numStr, props) {\n    var decimalScale = props.decimalScale;\n    var fixedDecimalScale = props.fixedDecimalScale;\n    var prefix = props.prefix;\n    if (prefix === void 0) prefix = \"\";\n    var suffix = props.suffix;\n    if (suffix === void 0) suffix = \"\";\n    var allowNegative = props.allowNegative;\n    var thousandsGroupStyle = props.thousandsGroupStyle;\n    if (thousandsGroupStyle === void 0) thousandsGroupStyle = \"thousand\";\n    // don't apply formatting on empty string or '-'\n    if (numStr === \"\" || numStr === \"-\") {\n        return numStr;\n    }\n    var ref = getSeparators(props);\n    var thousandSeparator = ref.thousandSeparator;\n    var decimalSeparator = ref.decimalSeparator;\n    /**\n     * Keep the decimal separator\n     * when decimalScale is not defined or non zero and the numStr has decimal in it\n     * Or if decimalScale is > 0 and fixeDecimalScale is true (even if numStr has no decimal)\n     */ var hasDecimalSeparator = decimalScale !== 0 && numStr.indexOf(\".\") !== -1 || decimalScale && fixedDecimalScale;\n    var ref$1 = splitDecimal(numStr, allowNegative);\n    var beforeDecimal = ref$1.beforeDecimal;\n    var afterDecimal = ref$1.afterDecimal;\n    var addNegation = ref$1.addNegation; // eslint-disable-line prefer-const\n    //apply decimal precision if its defined\n    if (decimalScale !== undefined) {\n        afterDecimal = limitToScale(afterDecimal, decimalScale, !!fixedDecimalScale);\n    }\n    if (thousandSeparator) {\n        beforeDecimal = applyThousandSeparator(beforeDecimal, thousandSeparator, thousandsGroupStyle);\n    }\n    //add prefix and suffix when there is a number present\n    if (prefix) {\n        beforeDecimal = prefix + beforeDecimal;\n    }\n    if (suffix) {\n        afterDecimal = afterDecimal + suffix;\n    }\n    //restore negation sign\n    if (addNegation) {\n        beforeDecimal = \"-\" + beforeDecimal;\n    }\n    numStr = beforeDecimal + (hasDecimalSeparator && decimalSeparator || \"\") + afterDecimal;\n    return numStr;\n}\nfunction getSeparators(props) {\n    var decimalSeparator = props.decimalSeparator;\n    if (decimalSeparator === void 0) decimalSeparator = \".\";\n    var thousandSeparator = props.thousandSeparator;\n    var allowedDecimalSeparators = props.allowedDecimalSeparators;\n    if (thousandSeparator === true) {\n        thousandSeparator = \",\";\n    }\n    if (!allowedDecimalSeparators) {\n        allowedDecimalSeparators = [\n            decimalSeparator,\n            \".\"\n        ];\n    }\n    return {\n        decimalSeparator: decimalSeparator,\n        thousandSeparator: thousandSeparator,\n        allowedDecimalSeparators: allowedDecimalSeparators\n    };\n}\nfunction handleNegation(value, allowNegative) {\n    if (value === void 0) value = \"\";\n    var negationRegex = new RegExp(\"(-)\");\n    var doubleNegationRegex = new RegExp(\"(-)(.)*(-)\");\n    // Check number has '-' value\n    var hasNegation = negationRegex.test(value);\n    // Check number has 2 or more '-' values\n    var removeNegation = doubleNegationRegex.test(value);\n    //remove negation\n    value = value.replace(/-/g, \"\");\n    if (hasNegation && !removeNegation && allowNegative) {\n        value = \"-\" + value;\n    }\n    return value;\n}\nfunction getNumberRegex(decimalSeparator, global) {\n    return new RegExp(\"(^-)|[0-9]|\" + escapeRegExp(decimalSeparator), global ? \"g\" : undefined);\n}\nfunction removeFormatting(value, changeMeta, props) {\n    var assign;\n    if (changeMeta === void 0) changeMeta = getDefaultChangeMeta(value);\n    var allowNegative = props.allowNegative;\n    var prefix = props.prefix;\n    if (prefix === void 0) prefix = \"\";\n    var suffix = props.suffix;\n    if (suffix === void 0) suffix = \"\";\n    var decimalScale = props.decimalScale;\n    var from = changeMeta.from;\n    var to = changeMeta.to;\n    var start = to.start;\n    var end = to.end;\n    var ref = getSeparators(props);\n    var allowedDecimalSeparators = ref.allowedDecimalSeparators;\n    var decimalSeparator = ref.decimalSeparator;\n    var isBeforeDecimalSeparator = value[end] === decimalSeparator;\n    /**\n     * If only a number is added on empty input which matches with the prefix or suffix,\n     * then don't remove it, just return the same\n     */ if (charIsNumber(value) && (value === prefix || value === suffix) && changeMeta.lastValue === \"\") {\n        return value;\n    }\n    /** Check for any allowed decimal separator is added in the numeric format and replace it with decimal separator */ if (end - start === 1 && allowedDecimalSeparators.indexOf(value[start]) !== -1) {\n        var separator = decimalScale === 0 ? \"\" : decimalSeparator;\n        value = value.substring(0, start) + separator + value.substring(start + 1, value.length);\n    }\n    var stripNegation = function(value, start, end) {\n        /**\n         * if prefix starts with - we don't allow negative number to avoid confusion\n         * if suffix starts with - and the value length is same as suffix length, then the - sign is from the suffix\n         * In other cases, if the value starts with - then it is a negation\n         */ var hasNegation = false;\n        var hasDoubleNegation = false;\n        if (prefix.startsWith(\"-\")) {\n            hasNegation = false;\n        } else if (value.startsWith(\"--\")) {\n            hasNegation = false;\n            hasDoubleNegation = true;\n        } else if (suffix.startsWith(\"-\") && value.length === suffix.length) {\n            hasNegation = false;\n        } else if (value[0] === \"-\") {\n            hasNegation = true;\n        }\n        var charsToRemove = hasNegation ? 1 : 0;\n        if (hasDoubleNegation) {\n            charsToRemove = 2;\n        }\n        // remove negation/double negation from start to simplify prefix logic as negation comes before prefix\n        if (charsToRemove) {\n            value = value.substring(charsToRemove);\n            // account for the removal of the negation for start and end index\n            start -= charsToRemove;\n            end -= charsToRemove;\n        }\n        return {\n            value: value,\n            start: start,\n            end: end,\n            hasNegation: hasNegation\n        };\n    };\n    var toMetadata = stripNegation(value, start, end);\n    var hasNegation = toMetadata.hasNegation;\n    assign = toMetadata, value = assign.value, start = assign.start, end = assign.end;\n    var ref$1 = stripNegation(changeMeta.lastValue, from.start, from.end);\n    var fromStart = ref$1.start;\n    var fromEnd = ref$1.end;\n    var lastValue = ref$1.value;\n    // if only prefix and suffix part is updated reset the value to last value\n    // if the changed range is from suffix in the updated value, and the the suffix starts with the same characters, allow the change\n    var updatedSuffixPart = value.substring(start, end);\n    if (value.length && lastValue.length && (fromStart > lastValue.length - suffix.length || fromEnd < prefix.length) && !(updatedSuffixPart && suffix.startsWith(updatedSuffixPart))) {\n        value = lastValue;\n    }\n    /**\n     * remove prefix\n     * Remove whole prefix part if its present on the value\n     * If the prefix is partially deleted (in which case change start index will be less the prefix length)\n     * Remove only partial part of prefix.\n     */ var startIndex = 0;\n    if (value.startsWith(prefix)) {\n        startIndex += prefix.length;\n    } else if (start < prefix.length) {\n        startIndex = start;\n    }\n    value = value.substring(startIndex);\n    // account for deleted prefix for end\n    end -= startIndex;\n    /**\n     * Remove suffix\n     * Remove whole suffix part if its present on the value\n     * If the suffix is partially deleted (in which case change end index will be greater than the suffixStartIndex)\n     * remove the partial part of suffix\n     */ var endIndex = value.length;\n    var suffixStartIndex = value.length - suffix.length;\n    if (value.endsWith(suffix)) {\n        endIndex = suffixStartIndex;\n    } else if (end > suffixStartIndex) {\n        endIndex = end;\n    } else if (end > value.length - suffix.length) {\n        endIndex = end;\n    }\n    value = value.substring(0, endIndex);\n    // add the negation back and handle for double negation\n    value = handleNegation(hasNegation ? \"-\" + value : value, allowNegative);\n    // remove non numeric characters\n    value = (value.match(getNumberRegex(decimalSeparator, true)) || []).join(\"\");\n    // replace the decimalSeparator with ., and only keep the first separator, ignore following ones\n    var firstIndex = value.indexOf(decimalSeparator);\n    value = value.replace(new RegExp(escapeRegExp(decimalSeparator), \"g\"), function(match, index) {\n        return index === firstIndex ? \".\" : \"\";\n    });\n    //check if beforeDecimal got deleted and there is nothing after decimal,\n    //clear all numbers in such case while keeping the - sign\n    var ref$2 = splitDecimal(value, allowNegative);\n    var beforeDecimal = ref$2.beforeDecimal;\n    var afterDecimal = ref$2.afterDecimal;\n    var addNegation = ref$2.addNegation; // eslint-disable-line prefer-const\n    //clear only if something got deleted before decimal (cursor is before decimal)\n    if (to.end - to.start < from.end - from.start && beforeDecimal === \"\" && isBeforeDecimalSeparator && !parseFloat(afterDecimal)) {\n        value = addNegation ? \"-\" : \"\";\n    }\n    return value;\n}\nfunction getCaretBoundary(formattedValue, props) {\n    var prefix = props.prefix;\n    if (prefix === void 0) prefix = \"\";\n    var suffix = props.suffix;\n    if (suffix === void 0) suffix = \"\";\n    var boundaryAry = Array.from({\n        length: formattedValue.length + 1\n    }).map(function() {\n        return true;\n    });\n    var hasNegation = formattedValue[0] === \"-\";\n    // fill for prefix and negation\n    boundaryAry.fill(false, 0, prefix.length + (hasNegation ? 1 : 0));\n    // fill for suffix\n    var valLn = formattedValue.length;\n    boundaryAry.fill(false, valLn - suffix.length + 1, valLn + 1);\n    return boundaryAry;\n}\nfunction validateAndUpdateProps(props) {\n    var ref = getSeparators(props);\n    var thousandSeparator = ref.thousandSeparator;\n    var decimalSeparator = ref.decimalSeparator;\n    // eslint-disable-next-line prefer-const\n    var prefix = props.prefix;\n    if (prefix === void 0) prefix = \"\";\n    var allowNegative = props.allowNegative;\n    if (allowNegative === void 0) allowNegative = true;\n    if (thousandSeparator === decimalSeparator) {\n        throw new Error(\"\\n        Decimal separator can't be same as thousand separator.\\n        thousandSeparator: \" + thousandSeparator + ' (thousandSeparator = {true} is same as thousandSeparator = \",\")\\n        decimalSeparator: ' + decimalSeparator + \" (default value for decimalSeparator is .)\\n     \");\n    }\n    if (prefix.startsWith(\"-\") && allowNegative) {\n        // TODO: throw error in next major version\n        console.error(\"\\n      Prefix can't start with '-' when allowNegative is true.\\n      prefix: \" + prefix + \"\\n      allowNegative: \" + allowNegative + \"\\n    \");\n        allowNegative = false;\n    }\n    return Object.assign(Object.assign({}, props), {\n        allowNegative: allowNegative\n    });\n}\nfunction useNumericFormat(props) {\n    // validate props\n    props = validateAndUpdateProps(props);\n    var decimalSeparator = props.decimalSeparator;\n    if (decimalSeparator === void 0) decimalSeparator = \".\";\n    var allowedDecimalSeparators = props.allowedDecimalSeparators;\n    var thousandsGroupStyle = props.thousandsGroupStyle;\n    var suffix = props.suffix;\n    var allowNegative = props.allowNegative;\n    var allowLeadingZeros = props.allowLeadingZeros;\n    var onKeyDown = props.onKeyDown;\n    if (onKeyDown === void 0) onKeyDown = noop;\n    var onBlur = props.onBlur;\n    if (onBlur === void 0) onBlur = noop;\n    var thousandSeparator = props.thousandSeparator;\n    var decimalScale = props.decimalScale;\n    var fixedDecimalScale = props.fixedDecimalScale;\n    var prefix = props.prefix;\n    if (prefix === void 0) prefix = \"\";\n    var defaultValue = props.defaultValue;\n    var value = props.value;\n    var valueIsNumericString = props.valueIsNumericString;\n    var onValueChange = props.onValueChange;\n    var restProps = __rest(props, [\n        \"decimalSeparator\",\n        \"allowedDecimalSeparators\",\n        \"thousandsGroupStyle\",\n        \"suffix\",\n        \"allowNegative\",\n        \"allowLeadingZeros\",\n        \"onKeyDown\",\n        \"onBlur\",\n        \"thousandSeparator\",\n        \"decimalScale\",\n        \"fixedDecimalScale\",\n        \"prefix\",\n        \"defaultValue\",\n        \"value\",\n        \"valueIsNumericString\",\n        \"onValueChange\"\n    ]);\n    var _format = function(numStr) {\n        return format(numStr, props);\n    };\n    var _removeFormatting = function(inputValue, changeMeta) {\n        return removeFormatting(inputValue, changeMeta, props);\n    };\n    var _valueIsNumericString = valueIsNumericString;\n    if (!isNil(value)) {\n        _valueIsNumericString = valueIsNumericString !== null && valueIsNumericString !== void 0 ? valueIsNumericString : typeof value === \"number\";\n    } else if (!isNil(defaultValue)) {\n        _valueIsNumericString = valueIsNumericString !== null && valueIsNumericString !== void 0 ? valueIsNumericString : typeof defaultValue === \"number\";\n    }\n    var roundIncomingValueToPrecision = function(value) {\n        if (isNil(value) || isNanValue(value)) {\n            return value;\n        }\n        if (typeof value === \"number\") {\n            value = toNumericString(value);\n        }\n        /**\n         * only round numeric or float string values coming through props,\n         * we don't need to do it for onChange events, as we want to prevent typing there\n         */ if (_valueIsNumericString && typeof decimalScale === \"number\") {\n            return roundToPrecision(value, decimalScale, Boolean(fixedDecimalScale));\n        }\n        return value;\n    };\n    var ref = useInternalValues(roundIncomingValueToPrecision(value), roundIncomingValueToPrecision(defaultValue), Boolean(_valueIsNumericString), _format, _removeFormatting, onValueChange);\n    var ref_0 = ref[0];\n    var numAsString = ref_0.numAsString;\n    var formattedValue = ref_0.formattedValue;\n    var _onValueChange = ref[1];\n    var _onKeyDown = function(e) {\n        var el = e.target;\n        var key = e.key;\n        var selectionStart = el.selectionStart;\n        var selectionEnd = el.selectionEnd;\n        var value = el.value;\n        if (value === void 0) value = \"\";\n        // if multiple characters are selected and user hits backspace, no need to handle anything manually\n        if (selectionStart !== selectionEnd) {\n            onKeyDown(e);\n            return;\n        }\n        // if user hits backspace, while the cursor is before prefix, and the input has negation, remove the negation\n        if (key === \"Backspace\" && value[0] === \"-\" && selectionStart === prefix.length + 1 && allowNegative) {\n            // bring the cursor to after negation\n            setCaretPosition(el, 1);\n        }\n        // don't allow user to delete decimal separator when decimalScale and fixedDecimalScale is set\n        var ref = getSeparators(props);\n        var decimalSeparator = ref.decimalSeparator;\n        var allowedDecimalSeparators = ref.allowedDecimalSeparators;\n        if (key === \"Backspace\" && value[selectionStart - 1] === decimalSeparator && decimalScale && fixedDecimalScale) {\n            setCaretPosition(el, selectionStart - 1);\n            e.preventDefault();\n        }\n        // if user presses the allowed decimal separator before the separator, move the cursor after the separator\n        if ((allowedDecimalSeparators === null || allowedDecimalSeparators === void 0 ? void 0 : allowedDecimalSeparators.includes(key)) && value[selectionStart] === decimalSeparator) {\n            setCaretPosition(el, selectionStart + 1);\n        }\n        var _thousandSeparator = thousandSeparator === true ? \",\" : thousandSeparator;\n        // move cursor when delete or backspace is pressed before/after thousand separator\n        if (key === \"Backspace\" && value[selectionStart - 1] === _thousandSeparator) {\n            setCaretPosition(el, selectionStart - 1);\n        }\n        if (key === \"Delete\" && value[selectionStart] === _thousandSeparator) {\n            setCaretPosition(el, selectionStart + 1);\n        }\n        onKeyDown(e);\n    };\n    var _onBlur = function(e) {\n        var _value = numAsString;\n        // if there no no numeric value, clear the input\n        if (!_value.match(/\\d/g)) {\n            _value = \"\";\n        }\n        // clear leading 0s\n        if (!allowLeadingZeros) {\n            _value = fixLeadingZero(_value);\n        }\n        // apply fixedDecimalScale on blur event\n        if (fixedDecimalScale && decimalScale) {\n            _value = roundToPrecision(_value, decimalScale, fixedDecimalScale);\n        }\n        if (_value !== numAsString) {\n            var formattedValue = format(_value, props);\n            _onValueChange({\n                formattedValue: formattedValue,\n                value: _value,\n                floatValue: parseFloat(_value)\n            }, {\n                event: e,\n                source: SourceType.event\n            });\n        }\n        onBlur(e);\n    };\n    var isValidInputCharacter = function(inputChar) {\n        if (inputChar === decimalSeparator) {\n            return true;\n        }\n        return charIsNumber(inputChar);\n    };\n    return Object.assign(Object.assign({}, restProps), {\n        value: formattedValue,\n        valueIsNumericString: false,\n        isValidInputCharacter: isValidInputCharacter,\n        onValueChange: _onValueChange,\n        format: _format,\n        removeFormatting: _removeFormatting,\n        getCaretBoundary: function(formattedValue) {\n            return getCaretBoundary(formattedValue, props);\n        },\n        onKeyDown: _onKeyDown,\n        onBlur: _onBlur\n    });\n}\nfunction NumericFormat(props) {\n    var numericFormatProps = useNumericFormat(props);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(NumberFormatBase, Object.assign({}, numericFormatProps));\n}\nfunction format$1(numStr, props) {\n    var format = props.format;\n    var allowEmptyFormatting = props.allowEmptyFormatting;\n    var mask = props.mask;\n    var patternChar = props.patternChar;\n    if (patternChar === void 0) patternChar = \"#\";\n    if (numStr === \"\" && !allowEmptyFormatting) {\n        return \"\";\n    }\n    var hashCount = 0;\n    var formattedNumberAry = format.split(\"\");\n    for(var i = 0, ln = format.length; i < ln; i++){\n        if (format[i] === patternChar) {\n            formattedNumberAry[i] = numStr[hashCount] || getMaskAtIndex(mask, hashCount);\n            hashCount += 1;\n        }\n    }\n    return formattedNumberAry.join(\"\");\n}\nfunction removeFormatting$1(value, changeMeta, props) {\n    if (changeMeta === void 0) changeMeta = getDefaultChangeMeta(value);\n    var format = props.format;\n    var patternChar = props.patternChar;\n    if (patternChar === void 0) patternChar = \"#\";\n    var from = changeMeta.from;\n    var to = changeMeta.to;\n    var lastValue = changeMeta.lastValue;\n    if (lastValue === void 0) lastValue = \"\";\n    var isNumericSlot = function(caretPos) {\n        return format[caretPos] === patternChar;\n    };\n    var removeFormatChar = function(string, startIndex) {\n        var str = \"\";\n        for(var i = 0; i < string.length; i++){\n            if (isNumericSlot(startIndex + i) && charIsNumber(string[i])) {\n                str += string[i];\n            }\n        }\n        return str;\n    };\n    var extractNumbers = function(str) {\n        return str.replace(/[^0-9]/g, \"\");\n    };\n    // if format doesn't have any number, remove all the non numeric characters\n    if (!format.match(/\\d/)) {\n        return extractNumbers(value);\n    }\n    /**\n     * if user paste the whole formatted text in an empty input, check if matches to the pattern\n     * and remove the format characters, if there is a mismatch on the pattern, do plane number extract\n     */ if (lastValue === \"\" && value.length === format.length) {\n        var str = \"\";\n        for(var i = 0; i < value.length; i++){\n            if (isNumericSlot(i)) {\n                if (charIsNumber(value[i])) {\n                    str += value[i];\n                }\n            } else if (value[i] !== format[i]) {\n                // if there is a mismatch on the pattern, do plane number extract\n                return extractNumbers(value);\n            }\n        }\n        return str;\n    }\n    /**\n     * For partial change,\n     * where ever there is a change on the input, we can break the number in three parts\n     * 1st: left part which is unchanged\n     * 2nd: middle part which is changed\n     * 3rd: right part which is unchanged\n     *\n     * The first and third section will be same as last value, only the middle part will change\n     * We can consider on the change part all the new characters are non format characters.\n     * And on the first and last section it can have partial format characters.\n     *\n     * We pick first and last section from the lastValue (as that has 1-1 mapping with format)\n     * and middle one from the update value.\n     */ var firstSection = lastValue.substring(0, from.start);\n    var middleSection = value.substring(to.start, to.end);\n    var lastSection = lastValue.substring(from.end);\n    return \"\" + removeFormatChar(firstSection, 0) + extractNumbers(middleSection) + removeFormatChar(lastSection, from.end);\n}\nfunction getCaretBoundary$1(formattedValue, props) {\n    var format = props.format;\n    var mask = props.mask;\n    var patternChar = props.patternChar;\n    if (patternChar === void 0) patternChar = \"#\";\n    var boundaryAry = Array.from({\n        length: formattedValue.length + 1\n    }).map(function() {\n        return true;\n    });\n    var hashCount = 0;\n    var firstEmptySlot = -1;\n    var maskAndIndexMap = {};\n    format.split(\"\").forEach(function(char, index) {\n        var maskAtIndex = undefined;\n        if (char === patternChar) {\n            hashCount++;\n            maskAtIndex = getMaskAtIndex(mask, hashCount - 1);\n            if (firstEmptySlot === -1 && formattedValue[index] === maskAtIndex) {\n                firstEmptySlot = index;\n            }\n        }\n        maskAndIndexMap[index] = maskAtIndex;\n    });\n    var isPosAllowed = function(pos) {\n        // the position is allowed if the position is not masked and valid number area\n        return format[pos] === patternChar && formattedValue[pos] !== maskAndIndexMap[pos];\n    };\n    for(var i = 0, ln = boundaryAry.length; i < ln; i++){\n        // consider caret to be in boundary if it is before or after numeric value\n        // Note: on pattern based format its denoted by patternCharacter\n        // we should also allow user to put cursor on first empty slot\n        boundaryAry[i] = i === firstEmptySlot || isPosAllowed(i) || isPosAllowed(i - 1);\n    }\n    // the first patternChar position is always allowed\n    boundaryAry[format.indexOf(patternChar)] = true;\n    return boundaryAry;\n}\nfunction validateProps(props) {\n    var mask = props.mask;\n    if (mask) {\n        var maskAsStr = mask === \"string\" ? mask : mask.toString();\n        if (maskAsStr.match(/\\d/g)) {\n            throw new Error(\"Mask \" + mask + \" should not contain numeric character;\");\n        }\n    }\n}\nfunction usePatternFormat(props) {\n    var mask = props.mask;\n    var allowEmptyFormatting = props.allowEmptyFormatting;\n    var formatProp = props.format;\n    var inputMode = props.inputMode;\n    if (inputMode === void 0) inputMode = \"numeric\";\n    var onKeyDown = props.onKeyDown;\n    if (onKeyDown === void 0) onKeyDown = noop;\n    var patternChar = props.patternChar;\n    if (patternChar === void 0) patternChar = \"#\";\n    var restProps = __rest(props, [\n        \"mask\",\n        \"allowEmptyFormatting\",\n        \"format\",\n        \"inputMode\",\n        \"onKeyDown\",\n        \"patternChar\"\n    ]);\n    // validate props\n    validateProps(props);\n    var _getCaretBoundary = function(formattedValue) {\n        return getCaretBoundary$1(formattedValue, props);\n    };\n    var _onKeyDown = function(e) {\n        var key = e.key;\n        var el = e.target;\n        var selectionStart = el.selectionStart;\n        var selectionEnd = el.selectionEnd;\n        var value = el.value;\n        // if multiple characters are selected and user hits backspace, no need to handle anything manually\n        if (selectionStart !== selectionEnd) {\n            onKeyDown(e);\n            return;\n        }\n        // bring the cursor to closest numeric section\n        var caretPos = selectionStart;\n        // if backspace is pressed after the format characters, bring it to numeric section\n        // if delete is pressed before the format characters, bring it to numeric section\n        if (key === \"Backspace\" || key === \"Delete\") {\n            var direction = \"right\";\n            if (key === \"Backspace\") {\n                while(caretPos > 0 && formatProp[caretPos - 1] !== patternChar){\n                    caretPos--;\n                }\n                direction = \"left\";\n            } else {\n                var formatLn = formatProp.length;\n                while(caretPos < formatLn && formatProp[caretPos] !== patternChar){\n                    caretPos++;\n                }\n                direction = \"right\";\n            }\n            caretPos = getCaretPosInBoundary(value, caretPos, _getCaretBoundary(value), direction);\n        } else if (formatProp[caretPos] !== patternChar && key !== \"ArrowLeft\" && key !== \"ArrowRight\") {\n            // if user is typing on format character position, bring user to next allowed caret position\n            caretPos = getCaretPosInBoundary(value, caretPos + 1, _getCaretBoundary(value), \"right\");\n        }\n        // if we changing caret position, set the caret position\n        if (caretPos !== selectionStart) {\n            setCaretPosition(el, caretPos);\n        }\n        onKeyDown(e);\n    };\n    return Object.assign(Object.assign({}, restProps), {\n        inputMode: inputMode,\n        format: function(numStr) {\n            return format$1(numStr, props);\n        },\n        removeFormatting: function(inputValue, changeMeta) {\n            return removeFormatting$1(inputValue, changeMeta, props);\n        },\n        getCaretBoundary: _getCaretBoundary,\n        onKeyDown: _onKeyDown\n    });\n}\nfunction PatternFormat(props) {\n    var patternFormatProps = usePatternFormat(props);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(NumberFormatBase, Object.assign({}, patternFormatProps));\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtbnVtYmVyLWZvcm1hdC9kaXN0L3JlYWN0LW51bWJlci1mb3JtYXQuZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7OztDQUtDLEdBRW1FO0FBRXBFOzs7Ozs7Ozs7Ozs7OzhFQWE4RSxHQUU5RSxTQUFTSyxPQUFPQyxDQUFDLEVBQUVDLENBQUM7SUFDaEIsSUFBSUMsSUFBSSxDQUFDO0lBQ1QsSUFBSyxJQUFJQyxLQUFLSCxFQUFHO1FBQUUsSUFBSUksT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1AsR0FBR0csTUFBTUYsRUFBRU8sT0FBTyxDQUFDTCxLQUFLLEdBQ2hGO1lBQUVELENBQUMsQ0FBQ0MsRUFBRSxHQUFHSCxDQUFDLENBQUNHLEVBQUU7UUFBRTtJQUFFO0lBQ3JCLElBQUlILEtBQUssUUFBUSxPQUFPSSxPQUFPSyxxQkFBcUIsS0FBSyxZQUNyRDtRQUFFLElBQUssSUFBSUMsSUFBSSxHQUFHUCxJQUFJQyxPQUFPSyxxQkFBcUIsQ0FBQ1QsSUFBSVUsSUFBSVAsRUFBRVEsTUFBTSxFQUFFRCxJQUFLO1lBQ3RFLElBQUlULEVBQUVPLE9BQU8sQ0FBQ0wsQ0FBQyxDQUFDTyxFQUFFLElBQUksS0FBS04sT0FBT0MsU0FBUyxDQUFDTyxvQkFBb0IsQ0FBQ0wsSUFBSSxDQUFDUCxHQUFHRyxDQUFDLENBQUNPLEVBQUUsR0FDekU7Z0JBQUVSLENBQUMsQ0FBQ0MsQ0FBQyxDQUFDTyxFQUFFLENBQUMsR0FBR1YsQ0FBQyxDQUFDRyxDQUFDLENBQUNPLEVBQUUsQ0FBQztZQUFFO1FBQzdCO0lBQUU7SUFDTixPQUFPUjtBQUNYO0FBRUEsSUFBSVc7QUFDSCxVQUFVQSxVQUFVO0lBQ2pCQSxVQUFVLENBQUMsUUFBUSxHQUFHO0lBQ3RCQSxVQUFVLENBQUMsUUFBUSxHQUFHO0FBQzFCLEdBQUdBLGNBQWVBLENBQUFBLGFBQWEsQ0FBQztBQUVoQyxzQkFBc0I7QUFDdEIs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QyxJQUFJQztRQUN6QjtRQUNBdUYsVUFBVWxMO0lBQ2Q7SUFDQSxPQUFPRyxPQUFPcU4sTUFBTSxDQUFDck4sT0FBT3FOLE1BQU0sQ0FBQyxDQUFDLEdBQUdxRCxZQUFZO1FBQUV0QyxXQUFXQTtRQUFXMUUsUUFBUSxTQUFVbEgsTUFBTTtZQUFJLE9BQU82TyxTQUFTN08sUUFBUStIO1FBQVE7UUFBR1osa0JBQWtCLFNBQVVrRCxVQUFVLEVBQUVPLFVBQVU7WUFBSSxPQUFPc0UsbUJBQW1CN0UsWUFBWU8sWUFBWTdDO1FBQVE7UUFBR2Esa0JBQWtCd0g7UUFBbUI3SCxXQUFXMkM7SUFBVztBQUM1VDtBQUNBLFNBQVNvRixjQUFjdkksS0FBSztJQUN4QixJQUFJd0kscUJBQXFCTCxpQkFBaUJuSTtJQUMxQyxxQkFBT2pMLDBEQUFtQixDQUFDZ0wsa0JBQWtCdEssT0FBT3FOLE1BQU0sQ0FBQyxDQUFDLEdBQUcwRjtBQUNuRTtBQUV3VSIsInNvdXJjZXMiOlsid2VicGFjazovL2lzb21vcnBoaWMvLi9ub2RlX21vZHVsZXMvcmVhY3QtbnVtYmVyLWZvcm1hdC9kaXN0L3JlYWN0LW51bWJlci1mb3JtYXQuZXMuanM/MzQ3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHJlYWN0LW51bWJlci1mb3JtYXQgLSA1LjEuNFxuICogQXV0aG9yIDogU3VkaGFuc2h1IFlhZGF2XG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYsIDIwMjMgdG8gU3VkaGFuc2h1IFlhZGF2LCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcy15YWRhdi9yZWFjdC1udW1iZXItZm9ybWF0XG4gKi9cblxuaW1wb3J0IFJlYWN0LCB7IHVzZVJlZiwgdXNlU3RhdGUsIHVzZU1lbW8sIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgeyB0W3BdID0gc1twXTsgfSB9XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgeyBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHsgdFtwW2ldXSA9IHNbcFtpXV07IH1cclxuICAgICAgICB9IH1cclxuICAgIHJldHVybiB0O1xyXG59XG5cbnZhciBTb3VyY2VUeXBlO1xuKGZ1bmN0aW9uIChTb3VyY2VUeXBlKSB7XG4gICAgU291cmNlVHlwZVtcImV2ZW50XCJdID0gXCJldmVudFwiO1xuICAgIFNvdXJjZVR5cGVbXCJwcm9wc1wiXSA9IFwicHJvcFwiO1xufSkoU291cmNlVHlwZSB8fCAoU291cmNlVHlwZSA9IHt9KSk7XG5cbi8vIGJhc2ljIG5vb3AgZnVuY3Rpb25cbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbmZ1bmN0aW9uIGNoYXJJc051bWJlcihjaGFyKSB7XG4gICAgcmV0dXJuICEhKGNoYXIgfHwgJycpLm1hdGNoKC9cXGQvKTtcbn1cbmZ1bmN0aW9uIGlzTmlsKHZhbCkge1xuICAgIHJldHVybiB2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc05hblZhbHVlKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpO1xufVxuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvWy1bXFxdL3t9KCkqKz8uXFxcXF4kfF0vZywgJ1xcXFwkJicpO1xufVxuZnVuY3Rpb24gZ2V0VGhvdXNhbmRzR3JvdXBSZWdleCh0aG91c2FuZHNHcm91cFN0eWxlKSB7XG4gICAgc3dpdGNoICh0aG91c2FuZHNHcm91cFN0eWxlKSB7XG4gICAgICAgIGNhc2UgJ2xha2gnOlxuICAgICAgICAgICAgcmV0dXJuIC8oXFxkKz8pKD89KFxcZFxcZCkrKFxcZCkoPyFcXGQpKShcXC5cXGQrKT8vZztcbiAgICAgICAgY2FzZSAnd2FuJzpcbiAgICAgICAgICAgIHJldHVybiAvKFxcZCkoPz0oXFxkezR9KSsoPyFcXGQpKS9nO1xuICAgICAgICBjYXNlICd0aG91c2FuZCc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gLyhcXGQpKD89KFxcZHszfSkrKD8hXFxkKSkvZztcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseVRob3VzYW5kU2VwYXJhdG9yKHN0ciwgdGhvdXNhbmRTZXBhcmF0b3IsIHRob3VzYW5kc0dyb3VwU3R5bGUpIHtcbiAgICB2YXIgdGhvdXNhbmRzR3JvdXBSZWdleCA9IGdldFRob3VzYW5kc0dyb3VwUmVnZXgodGhvdXNhbmRzR3JvdXBTdHlsZSk7XG4gICAgdmFyIGluZGV4ID0gc3RyLnNlYXJjaCgvWzEtOV0vKTtcbiAgICBpbmRleCA9IGluZGV4ID09PSAtMSA/IHN0ci5sZW5ndGggOiBpbmRleDtcbiAgICByZXR1cm4gKHN0ci5zdWJzdHJpbmcoMCwgaW5kZXgpICtcbiAgICAgICAgc3RyLnN1YnN0cmluZyhpbmRleCwgc3RyLmxlbmd0aCkucmVwbGFjZSh0aG91c2FuZHNHcm91cFJlZ2V4LCAnJDEnICsgdGhvdXNhbmRTZXBhcmF0b3IpKTtcbn1cbmZ1bmN0aW9uIHVzZVBlcnNpc3RlbnRDYWxsYmFjayhjYikge1xuICAgIHZhciBjYWxsYmFja1JlZiA9IHVzZVJlZihjYik7XG4gICAgLy8ga2VlcCB0aGUgY2FsbGJhY2sgcmVmIHVwdG8gZGF0ZVxuICAgIGNhbGxiYWNrUmVmLmN1cnJlbnQgPSBjYjtcbiAgICAvKipcbiAgICAgKiBpbml0aWFsaXplIGEgcGVyc2lzdGVudCBjYWxsYmFjayB3aGljaCBuZXZlciBjaGFuZ2VzXG4gICAgICogdGhyb3VnaCBvdXQgdGhlIGNvbXBvbmVudCBsaWZlY3ljbGVcbiAgICAgKi9cbiAgICB2YXIgcGVyc2lzdGVudENiUmVmID0gdXNlUmVmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gY2FsbGJhY2tSZWYuY3VycmVudC5hcHBseShjYWxsYmFja1JlZiwgYXJncyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBlcnNpc3RlbnRDYlJlZi5jdXJyZW50O1xufVxuLy9zcGlsdCBhIGZsb2F0IG51bWJlciBpbnRvIGRpZmZlcmVudCBwYXJ0cyBiZWZvcmVEZWNpbWFsLCBhZnRlckRlY2ltYWwsIGFuZCBuZWdhdGlvblxuZnVuY3Rpb24gc3BsaXREZWNpbWFsKG51bVN0ciwgYWxsb3dOZWdhdGl2ZSkge1xuICAgIGlmICggYWxsb3dOZWdhdGl2ZSA9PT0gdm9pZCAwICkgYWxsb3dOZWdhdGl2ZSA9IHRydWU7XG5cbiAgICB2YXIgaGFzTmVnYXRpb24gPSBudW1TdHJbMF0gPT09ICctJztcbiAgICB2YXIgYWRkTmVnYXRpb24gPSBoYXNOZWdhdGlvbiAmJiBhbGxvd05lZ2F0aXZlO1xuICAgIG51bVN0ciA9IG51bVN0ci5yZXBsYWNlKCctJywgJycpO1xuICAgIHZhciBwYXJ0cyA9IG51bVN0ci5zcGxpdCgnLicpO1xuICAgIHZhciBiZWZvcmVEZWNpbWFsID0gcGFydHNbMF07XG4gICAgdmFyIGFmdGVyRGVjaW1hbCA9IHBhcnRzWzFdIHx8ICcnO1xuICAgIHJldHVybiB7XG4gICAgICAgIGJlZm9yZURlY2ltYWw6IGJlZm9yZURlY2ltYWwsXG4gICAgICAgIGFmdGVyRGVjaW1hbDogYWZ0ZXJEZWNpbWFsLFxuICAgICAgICBoYXNOZWdhdGlvbjogaGFzTmVnYXRpb24sXG4gICAgICAgIGFkZE5lZ2F0aW9uOiBhZGROZWdhdGlvbixcbiAgICB9O1xufVxuZnVuY3Rpb24gZml4TGVhZGluZ1plcm8obnVtU3RyKSB7XG4gICAgaWYgKCFudW1TdHIpXG4gICAgICAgIHsgcmV0dXJuIG51bVN0cjsgfVxuICAgIHZhciBpc05lZ2F0aXZlID0gbnVtU3RyWzBdID09PSAnLSc7XG4gICAgaWYgKGlzTmVnYXRpdmUpXG4gICAgICAgIHsgbnVtU3RyID0gbnVtU3RyLnN1YnN0cmluZygxLCBudW1TdHIubGVuZ3RoKTsgfVxuICAgIHZhciBwYXJ0cyA9IG51bVN0ci5zcGxpdCgnLicpO1xuICAgIHZhciBiZWZvcmVEZWNpbWFsID0gcGFydHNbMF0ucmVwbGFjZSgvXjArLywgJycpIHx8ICcwJztcbiAgICB2YXIgYWZ0ZXJEZWNpbWFsID0gcGFydHNbMV0gfHwgJyc7XG4gICAgcmV0dXJuIChcIlwiICsgKGlzTmVnYXRpdmUgPyAnLScgOiAnJykgKyBiZWZvcmVEZWNpbWFsICsgKGFmdGVyRGVjaW1hbCA/IChcIi5cIiArIGFmdGVyRGVjaW1hbCkgOiAnJykpO1xufVxuLyoqXG4gKiBsaW1pdCBkZWNpbWFsIG51bWJlcnMgdG8gZ2l2ZW4gc2NhbGVcbiAqIE5vdCB1c2VkIC5maXhlZFRvIGJlY2F1c2UgdGhhdCB3aWxsIGJyZWFrIHdpdGggYmlnIG51bWJlcnNcbiAqL1xuZnVuY3Rpb24gbGltaXRUb1NjYWxlKG51bVN0ciwgc2NhbGUsIGZpeGVkRGVjaW1hbFNjYWxlKSB7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIHZhciBmaWxsZXIgPSBmaXhlZERlY2ltYWxTY2FsZSA/ICcwJyA6ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHNjYWxlIC0gMTsgaSsrKSB7XG4gICAgICAgIHN0ciArPSBudW1TdHJbaV0gfHwgZmlsbGVyO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gcmVwZWF0KHN0ciwgY291bnQpIHtcbiAgICByZXR1cm4gQXJyYXkoY291bnQgKyAxKS5qb2luKHN0cik7XG59XG5mdW5jdGlvbiB0b051bWVyaWNTdHJpbmcobnVtKSB7XG4gICAgdmFyIF9udW0gPSBudW0gKyAnJzsgLy8gdHlwZWNhc3QgbnVtYmVyIHRvIHN0cmluZ1xuICAgIC8vIHN0b3JlIHRoZSBzaWduIGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgbnVtYmVyLlxuICAgIHZhciBzaWduID0gX251bVswXSA9PT0gJy0nID8gJy0nIDogJyc7XG4gICAgaWYgKHNpZ24pXG4gICAgICAgIHsgX251bSA9IF9udW0uc3Vic3RyaW5nKDEpOyB9XG4gICAgLy8gc3BsaXQgdGhlIG51bWJlciBpbnRvIGNvZmZpY2llbnQgYW5kIGV4cG9uZW50XG4gICAgdmFyIHJlZiA9IF9udW0uc3BsaXQoL1tlRV0vZyk7XG4gICAgdmFyIGNvZWZmaWNpZW50ID0gcmVmWzBdO1xuICAgIHZhciBleHBvbmVudCA9IHJlZlsxXTtcbiAgICAvLyBjb3ZlcnQgZXhwb25lbnQgdG8gbnVtYmVyO1xuICAgIGV4cG9uZW50ID0gTnVtYmVyKGV4cG9uZW50KTtcbiAgICAvLyBpZiB0aGVyZSBpcyBubyBleHBvbmVudCBwYXJ0IG9yIGl0cyAwLCByZXR1cm4gdGhlIGNvZmZpZWNpZW50IHdpdGggc2lnblxuICAgIGlmICghZXhwb25lbnQpXG4gICAgICAgIHsgcmV0dXJuIHNpZ24gKyBjb2VmZmljaWVudDsgfVxuICAgIGNvZWZmaWNpZW50ID0gY29lZmZpY2llbnQucmVwbGFjZSgnLicsICcnKTtcbiAgICAvKipcbiAgICAgKiBmb3Igc2NpZW50aWZpYyBub3RhdGlvbiB0aGUgY3VycmVudCBkZWNpbWFsIGluZGV4IHdpbGwgYmUgYWZ0ZXIgZmlyc3QgbnVtYmVyIChpbmRleCAwKVxuICAgICAqIFNvIGVmZmVjdGl2ZSBkZWNpbWFsIGluZGV4IHdpbGwgYWx3YXlzIGJlIDEgKyBleHBvbmVudCB2YWx1ZVxuICAgICAqL1xuICAgIHZhciBkZWNpbWFsSW5kZXggPSAxICsgZXhwb25lbnQ7XG4gICAgdmFyIGNvZmZpZWNpZW50TG4gPSBjb2VmZmljaWVudC5sZW5ndGg7XG4gICAgaWYgKGRlY2ltYWxJbmRleCA8IDApIHtcbiAgICAgICAgLy8gaWYgZGVjaW1hbCBpbmRleCBpcyBsZXNzIHRoZW4gMCBhZGQgcHJlY2VkaW5nIDBzXG4gICAgICAgIC8vIGFkZCAxIGFzIGpvaW4gd2lsbCBoYXZlXG4gICAgICAgIGNvZWZmaWNpZW50ID0gJzAuJyArIHJlcGVhdCgnMCcsIE1hdGguYWJzKGRlY2ltYWxJbmRleCkpICsgY29lZmZpY2llbnQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRlY2ltYWxJbmRleCA+PSBjb2ZmaWVjaWVudExuKSB7XG4gICAgICAgIC8vIGlmIGRlY2ltYWwgaW5kZXggaXMgbGVzcyB0aGVuIDAgYWRkIGxlYWRpbmcgMHNcbiAgICAgICAgY29lZmZpY2llbnQgPSBjb2VmZmljaWVudCArIHJlcGVhdCgnMCcsIGRlY2ltYWxJbmRleCAtIGNvZmZpZWNpZW50TG4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gZWxzZSBhZGQgZGVjaW1hbCBwb2ludCBhdCBwcm9wZXIgaW5kZXhcbiAgICAgICAgY29lZmZpY2llbnQgPVxuICAgICAgICAgICAgKGNvZWZmaWNpZW50LnN1YnN0cmluZygwLCBkZWNpbWFsSW5kZXgpIHx8ICcwJykgKyAnLicgKyBjb2VmZmljaWVudC5zdWJzdHJpbmcoZGVjaW1hbEluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHNpZ24gKyBjb2VmZmljaWVudDtcbn1cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgcmVxdWlyZWQgdG8gcm91bmQgcHJvcCB2YWx1ZSB0byBnaXZlbiBzY2FsZS5cbiAqIE5vdCB1c2VkIC5yb3VuZCBvciAuZml4ZWRUbyBiZWNhdXNlIHRoYXQgd2lsbCBicmVhayB3aXRoIGJpZyBudW1iZXJzXG4gKi9cbmZ1bmN0aW9uIHJvdW5kVG9QcmVjaXNpb24obnVtU3RyLCBzY2FsZSwgZml4ZWREZWNpbWFsU2NhbGUpIHtcbiAgICAvL2lmIG51bWJlciBpcyBlbXB0eSBkb24ndCBkbyBhbnl0aGluZyByZXR1cm4gZW1wdHkgc3RyaW5nXG4gICAgaWYgKFsnJywgJy0nXS5pbmRleE9mKG51bVN0cikgIT09IC0xKVxuICAgICAgICB7IHJldHVybiBudW1TdHI7IH1cbiAgICB2YXIgc2hvdWxkSGF2ZURlY2ltYWxTZXBhcmF0b3IgPSAobnVtU3RyLmluZGV4T2YoJy4nKSAhPT0gLTEgfHwgZml4ZWREZWNpbWFsU2NhbGUpICYmIHNjYWxlO1xuICAgIHZhciByZWYgPSBzcGxpdERlY2ltYWwobnVtU3RyKTtcbiAgICB2YXIgYmVmb3JlRGVjaW1hbCA9IHJlZi5iZWZvcmVEZWNpbWFsO1xuICAgIHZhciBhZnRlckRlY2ltYWwgPSByZWYuYWZ0ZXJEZWNpbWFsO1xuICAgIHZhciBoYXNOZWdhdGlvbiA9IHJlZi5oYXNOZWdhdGlvbjtcbiAgICB2YXIgZmxvYXRWYWx1ZSA9IHBhcnNlRmxvYXQoKFwiMC5cIiArIChhZnRlckRlY2ltYWwgfHwgJzAnKSkpO1xuICAgIHZhciBmbG9hdFZhbHVlU3RyID0gYWZ0ZXJEZWNpbWFsLmxlbmd0aCA8PSBzY2FsZSA/IChcIjAuXCIgKyBhZnRlckRlY2ltYWwpIDogZmxvYXRWYWx1ZS50b0ZpeGVkKHNjYWxlKTtcbiAgICB2YXIgcm91bmRlZERlY2ltYWxQYXJ0cyA9IGZsb2F0VmFsdWVTdHIuc3BsaXQoJy4nKTtcbiAgICB2YXIgaW50UGFydCA9IGJlZm9yZURlY2ltYWxcbiAgICAgICAgLnNwbGl0KCcnKVxuICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKHJvdW5kZWRTdHIsIGN1cnJlbnQsIGlkeCkge1xuICAgICAgICBpZiAocm91bmRlZFN0ci5sZW5ndGggPiBpZHgpIHtcbiAgICAgICAgICAgIHJldHVybiAoKE51bWJlcihyb3VuZGVkU3RyWzBdKSArIE51bWJlcihjdXJyZW50KSkudG9TdHJpbmcoKSArXG4gICAgICAgICAgICAgICAgcm91bmRlZFN0ci5zdWJzdHJpbmcoMSwgcm91bmRlZFN0ci5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudCArIHJvdW5kZWRTdHI7XG4gICAgfSwgcm91bmRlZERlY2ltYWxQYXJ0c1swXSk7XG4gICAgdmFyIGRlY2ltYWxQYXJ0ID0gbGltaXRUb1NjYWxlKHJvdW5kZWREZWNpbWFsUGFydHNbMV0gfHwgJycsIHNjYWxlLCBmaXhlZERlY2ltYWxTY2FsZSk7XG4gICAgdmFyIG5lZ2F0aW9uID0gaGFzTmVnYXRpb24gPyAnLScgOiAnJztcbiAgICB2YXIgZGVjaW1hbFNlcGFyYXRvciA9IHNob3VsZEhhdmVEZWNpbWFsU2VwYXJhdG9yID8gJy4nIDogJyc7XG4gICAgcmV0dXJuIChcIlwiICsgbmVnYXRpb24gKyBpbnRQYXJ0ICsgZGVjaW1hbFNlcGFyYXRvciArIGRlY2ltYWxQYXJ0KTtcbn1cbi8qKiBzZXQgdGhlIGNhcmV0IHBvc2l0b24gaW4gYW4gaW5wdXQgZmllbGQgKiovXG5mdW5jdGlvbiBzZXRDYXJldFBvc2l0aW9uKGVsLCBjYXJldFBvcykge1xuICAgIGVsLnZhbHVlID0gZWwudmFsdWU7XG4gICAgLy8gXiB0aGlzIGlzIHVzZWQgdG8gbm90IG9ubHkgZ2V0ICdmb2N1cycsIGJ1dFxuICAgIC8vIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIGl0IGV2ZXJ5dGhpbmcgLXNlbGVjdGVkLVxuICAgIC8vIChpdCBjYXVzZXMgYW4gaXNzdWUgaW4gY2hyb21lLCBhbmQgaGF2aW5nIGl0IGRvZXNuJ3QgaHVydCBhbnkgb3RoZXIgYnJvd3NlcilcbiAgICBpZiAoZWwgIT09IG51bGwpIHtcbiAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICBpZiAoZWwuY3JlYXRlVGV4dFJhbmdlKSB7XG4gICAgICAgICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBlbC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgIHJhbmdlLm1vdmUoJ2NoYXJhY3RlcicsIGNhcmV0UG9zKTtcbiAgICAgICAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gKGVsLnNlbGVjdGlvblN0YXJ0ID09PSAwIGFkZGVkIGZvciBGaXJlZm94IGJ1ZylcbiAgICAgICAgaWYgKGVsLnNlbGVjdGlvblN0YXJ0IHx8IGVsLnNlbGVjdGlvblN0YXJ0ID09PSAwKSB7XG4gICAgICAgICAgICBlbC5mb2N1cygpO1xuICAgICAgICAgICAgZWwuc2V0U2VsZWN0aW9uUmFuZ2UoY2FyZXRQb3MsIGNhcmV0UG9zKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZhaWwgY2l0eSwgZm9ydHVuYXRlbHkgdGhpcyBuZXZlciBoYXBwZW5zIChhcyBmYXIgYXMgSSd2ZSB0ZXN0ZWQpIDopXG4gICAgICAgIGVsLmZvY3VzKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kQ2hhbmdlUmFuZ2UocHJldlZhbHVlLCBuZXdWYWx1ZSkge1xuICAgIHZhciBpID0gMCwgaiA9IDA7XG4gICAgdmFyIHByZXZMZW5ndGggPSBwcmV2VmFsdWUubGVuZ3RoO1xuICAgIHZhciBuZXdMZW5ndGggPSBuZXdWYWx1ZS5sZW5ndGg7XG4gICAgd2hpbGUgKHByZXZWYWx1ZVtpXSA9PT0gbmV3VmFsdWVbaV0gJiYgaSA8IHByZXZMZW5ndGgpXG4gICAgICAgIHsgaSsrOyB9XG4gICAgLy9jaGVjayB3aGF0IGhhcyBiZWVuIGNoYW5nZWQgZnJvbSBsYXN0XG4gICAgd2hpbGUgKHByZXZWYWx1ZVtwcmV2TGVuZ3RoIC0gMSAtIGpdID09PSBuZXdWYWx1ZVtuZXdMZW5ndGggLSAxIC0gal0gJiZcbiAgICAgICAgbmV3TGVuZ3RoIC0gaiA+IGkgJiZcbiAgICAgICAgcHJldkxlbmd0aCAtIGogPiBpKSB7XG4gICAgICAgIGorKztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbTogeyBzdGFydDogaSwgZW5kOiBwcmV2TGVuZ3RoIC0gaiB9LFxuICAgICAgICB0bzogeyBzdGFydDogaSwgZW5kOiBuZXdMZW5ndGggLSBqIH0sXG4gICAgfTtcbn1cbi8qXG4gIFJldHVybnMgYSBudW1iZXIgd2hvc2UgdmFsdWUgaXMgbGltaXRlZCB0byB0aGUgZ2l2ZW4gcmFuZ2VcbiovXG5mdW5jdGlvbiBjbGFtcChudW0sIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG51bSwgbWluKSwgbWF4KTtcbn1cbmZ1bmN0aW9uIGdlSW5wdXRDYXJldFBvc2l0aW9uKGVsKSB7XG4gICAgLypNYXggb2Ygc2VsZWN0aW9uU3RhcnQgYW5kIHNlbGVjdGlvbkVuZCBpcyB0YWtlbiBmb3IgdGhlIHBhdGNoIG9mIHBpeGVsIGFuZCBvdGhlciBtb2JpbGUgZGV2aWNlIGNhcmV0IGJ1ZyovXG4gICAgcmV0dXJuIE1hdGgubWF4KGVsLnNlbGVjdGlvblN0YXJ0LCBlbC5zZWxlY3Rpb25FbmQpO1xufVxuZnVuY3Rpb24gYWRkSW5wdXRNb2RlKCkge1xuICAgIHJldHVybiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgIShuYXZpZ2F0b3IucGxhdGZvcm0gJiYgL2lQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkpKTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRDaGFuZ2VNZXRhKHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgIH0sXG4gICAgICAgIHRvOiB7XG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogdmFsdWUubGVuZ3RoLFxuICAgICAgICB9LFxuICAgICAgICBsYXN0VmFsdWU6ICcnLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRNYXNrQXRJbmRleChtYXNrLCBpbmRleCkge1xuICAgIGlmICggbWFzayA9PT0gdm9pZCAwICkgbWFzayA9ICcgJztcblxuICAgIGlmICh0eXBlb2YgbWFzayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG1hc2s7XG4gICAgfVxuICAgIHJldHVybiBtYXNrW2luZGV4XSB8fCAnICc7XG59XG5mdW5jdGlvbiBnZXRDYXJldFBvc2l0aW9uKG5ld0Zvcm1hdHRlZFZhbHVlLCBsYXN0Rm9ybWF0dGVkVmFsdWUsIGN1clZhbHVlLCBjdXJDYXJldFBvcywgYm91bmRhcnksIGlzVmFsaWRJbnB1dENoYXJhY3Rlcikge1xuICAgIC8qKlxuICAgICAqIGlmIHNvbWV0aGluZyBnb3QgaW5zZXJ0ZWQgb24gZW1wdHkgdmFsdWUsIGFkZCB0aGUgZm9ybWF0dGVkIGNoYXJhY3RlciBiZWZvcmUgdGhlIGN1cnJlbnQgdmFsdWUsXG4gICAgICogVGhpcyBpcyB0byBhdm9pZCB0aGUgY2FzZSB3aGVyZSB0eXBlZCBjaGFyYWN0ZXIgaXMgcHJlc2VudCBvbiBmb3JtYXQgY2hhcmFjdGVyc1xuICAgICAqL1xuICAgIHZhciBmaXJzdEFsbG93ZWRQb3NpdGlvbiA9IGJvdW5kYXJ5LmZpbmRJbmRleChmdW5jdGlvbiAoYikgeyByZXR1cm4gYjsgfSk7XG4gICAgdmFyIHByZWZpeEZvcm1hdCA9IG5ld0Zvcm1hdHRlZFZhbHVlLnNsaWNlKDAsIGZpcnN0QWxsb3dlZFBvc2l0aW9uKTtcbiAgICBpZiAoIWxhc3RGb3JtYXR0ZWRWYWx1ZSAmJiAhY3VyVmFsdWUuc3RhcnRzV2l0aChwcmVmaXhGb3JtYXQpKSB7XG4gICAgICAgIGN1clZhbHVlID0gcHJlZml4Rm9ybWF0ICsgY3VyVmFsdWU7XG4gICAgICAgIGN1ckNhcmV0UG9zID0gY3VyQ2FyZXRQb3MgKyBwcmVmaXhGb3JtYXQubGVuZ3RoO1xuICAgIH1cbiAgICB2YXIgY3VyVmFsTG4gPSBjdXJWYWx1ZS5sZW5ndGg7XG4gICAgdmFyIGZvcm1hdHRlZFZhbHVlTG4gPSBuZXdGb3JtYXR0ZWRWYWx1ZS5sZW5ndGg7XG4gICAgLy8gY3JlYXRlIGluZGV4IG1hcFxuICAgIHZhciBhZGRlZEluZGV4TWFwID0ge307XG4gICAgdmFyIGluZGV4TWFwID0gbmV3IEFycmF5KGN1clZhbExuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1clZhbExuOyBpKyspIHtcbiAgICAgICAgaW5kZXhNYXBbaV0gPSAtMTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpMbiA9IGZvcm1hdHRlZFZhbHVlTG47IGogPCBqTG47IGorKykge1xuICAgICAgICAgICAgaWYgKGN1clZhbHVlW2ldID09PSBuZXdGb3JtYXR0ZWRWYWx1ZVtqXSAmJiBhZGRlZEluZGV4TWFwW2pdICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhNYXBbaV0gPSBqO1xuICAgICAgICAgICAgICAgIGFkZGVkSW5kZXhNYXBbal0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciBjdXJyZW50IGNhcmV0IHBvc2l0aW9uIGZpbmQgY2xvc2VzdCBjaGFyYWN0ZXJzIChsZWZ0IGFuZCByaWdodCBzaWRlKVxuICAgICAqIHdoaWNoIGFyZSBwcm9wZXJseSBtYXBwZWQgdG8gZm9ybWF0dGVkIHZhbHVlLlxuICAgICAqIFRoZSBpZGVhIGlzIHRoYXQgdGhlIG5ldyBjYXJldCBwb3NpdGlvbiB3aWxsIGV4aXN0IGFsd2F5cyBpbiB0aGUgYm91bmRhcnkgb2ZcbiAgICAgKiB0aGF0IG1hcHBlZCBpbmRleFxuICAgICAqL1xuICAgIHZhciBwb3MgPSBjdXJDYXJldFBvcztcbiAgICB3aGlsZSAocG9zIDwgY3VyVmFsTG4gJiYgKGluZGV4TWFwW3Bvc10gPT09IC0xIHx8ICFpc1ZhbGlkSW5wdXRDaGFyYWN0ZXIoY3VyVmFsdWVbcG9zXSkpKSB7XG4gICAgICAgIHBvcysrO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgY2FyZXQgcG9zaXRpb24gaXMgb24gbGFzdCBrZWVwIHRoZSBlbmRJbmRleCBhcyBsYXN0IGZvciBmb3JtYXR0ZWQgdmFsdWVcbiAgICB2YXIgZW5kSW5kZXggPSBwb3MgPT09IGN1clZhbExuIHx8IGluZGV4TWFwW3Bvc10gPT09IC0xID8gZm9ybWF0dGVkVmFsdWVMbiA6IGluZGV4TWFwW3Bvc107XG4gICAgcG9zID0gY3VyQ2FyZXRQb3MgLSAxO1xuICAgIHdoaWxlIChwb3MgPiAwICYmIGluZGV4TWFwW3Bvc10gPT09IC0xKVxuICAgICAgICB7IHBvcy0tOyB9XG4gICAgdmFyIHN0YXJ0SW5kZXggPSBwb3MgPT09IC0xIHx8IGluZGV4TWFwW3Bvc10gPT09IC0xID8gMCA6IGluZGV4TWFwW3Bvc10gKyAxO1xuICAgIC8qKlxuICAgICAqIGNhc2Ugd2hlcmUgYSBjaGFyIGlzIGFkZGVkIG9uIHN1ZmZpeCBhbmQgcmVtb3ZlZCBmcm9tIG1pZGRsZSwgZXhhbXBsZSAyc3EzNDUgYmVjb21pbmcgJDIsMzQ1IHNxXG4gICAgICogdGhlcmUgaXMgc3RpbGwgYSBtYXBwaW5nIGJ1dCB0aGUgb3JkZXIgb2Ygc3RhcnQgaW5kZXggYW5kIGVuZCBpbmRleCBpcyBjaGFuZ2VkXG4gICAgICovXG4gICAgaWYgKHN0YXJ0SW5kZXggPiBlbmRJbmRleClcbiAgICAgICAgeyByZXR1cm4gZW5kSW5kZXg7IH1cbiAgICAvKipcbiAgICAgKiBnaXZlbiB0aGUgY3VycmVudCBjYXJldCBwb3NpdGlvbiBpZiBpdCBjbG9zZXIgdG8gc3RhcnRJbmRleFxuICAgICAqIGtlZXAgdGhlIG5ldyBjYXJldCBwb3NpdGlvbiBvbiBzdGFydCBpbmRleCBvciBrZWVwIGl0IGNsb3NlciB0byBlbmRJbmRleFxuICAgICAqL1xuICAgIHJldHVybiBjdXJDYXJldFBvcyAtIHN0YXJ0SW5kZXggPCBlbmRJbmRleCAtIGN1ckNhcmV0UG9zID8gc3RhcnRJbmRleCA6IGVuZEluZGV4O1xufVxuLyogVGhpcyBrZWVwcyB0aGUgY2FyZXQgd2l0aGluIHR5cGluZyBhcmVhIHNvIHBlb3BsZSBjYW4ndCB0eXBlIGluIGJldHdlZW4gcHJlZml4IG9yIHN1ZmZpeCBvciBmb3JtYXQgY2hhcmFjdGVycyAqL1xuZnVuY3Rpb24gZ2V0Q2FyZXRQb3NJbkJvdW5kYXJ5KHZhbHVlLCBjYXJldFBvcywgYm91bmRhcnksIGRpcmVjdGlvbikge1xuICAgIHZhciB2YWxMbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAvLyBjbGFtcCBjYXJldCBwb3NpdGlvbiB0byBbMCwgdmFsdWUubGVuZ3RoXVxuICAgIGNhcmV0UG9zID0gY2xhbXAoY2FyZXRQb3MsIDAsIHZhbExuKTtcbiAgICBpZiAoZGlyZWN0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgd2hpbGUgKGNhcmV0UG9zID49IDAgJiYgIWJvdW5kYXJ5W2NhcmV0UG9zXSlcbiAgICAgICAgICAgIHsgY2FyZXRQb3MtLTsgfVxuICAgICAgICAvLyBpZiB3ZSBkb24ndCBmaW5kIGFueSBzdWl0YWJsZSBjYXJldCBwb3NpdGlvbiBvbiBsZWZ0LCBzZXQgaXQgb24gZmlyc3QgYWxsb3dlZCBwb3NpdGlvblxuICAgICAgICBpZiAoY2FyZXRQb3MgPT09IC0xKVxuICAgICAgICAgICAgeyBjYXJldFBvcyA9IGJvdW5kYXJ5LmluZGV4T2YodHJ1ZSk7IH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdoaWxlIChjYXJldFBvcyA8PSB2YWxMbiAmJiAhYm91bmRhcnlbY2FyZXRQb3NdKVxuICAgICAgICAgICAgeyBjYXJldFBvcysrOyB9XG4gICAgICAgIC8vIGlmIHdlIGRvbid0IGZpbmQgYW55IHN1aXRhYmxlIGNhcmV0IHBvc2l0aW9uIG9uIHJpZ2h0LCBzZXQgaXQgb24gbGFzdCBhbGxvd2VkIHBvc2l0aW9uXG4gICAgICAgIGlmIChjYXJldFBvcyA+IHZhbExuKVxuICAgICAgICAgICAgeyBjYXJldFBvcyA9IGJvdW5kYXJ5Lmxhc3RJbmRleE9mKHRydWUpOyB9XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGRvbid0IGZpbmQgY2FyZXQgcG9zaXRpb24sIHNldCBpdCBhdCB0aGUgZW5kIG9mIHZhbHVlXG4gICAgaWYgKGNhcmV0UG9zID09PSAtMSlcbiAgICAgICAgeyBjYXJldFBvcyA9IHZhbExuOyB9XG4gICAgcmV0dXJuIGNhcmV0UG9zO1xufVxuZnVuY3Rpb24gY2FyZXRVbmtub3duRm9ybWF0Qm91bmRhcnkoZm9ybWF0dGVkVmFsdWUpIHtcbiAgICB2YXIgYm91bmRhcnlBcnkgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBmb3JtYXR0ZWRWYWx1ZS5sZW5ndGggKyAxIH0pLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9KTtcbiAgICBmb3IgKHZhciBpID0gMCwgbG4gPSBib3VuZGFyeUFyeS5sZW5ndGg7IGkgPCBsbjsgaSsrKSB7XG4gICAgICAgIC8vIGNvbnNpZGVyIGNhcmV0IHRvIGJlIGluIGJvdW5kYXJ5IGlmIGl0IGlzIGJlZm9yZSBvciBhZnRlciBudW1lcmljIHZhbHVlXG4gICAgICAgIGJvdW5kYXJ5QXJ5W2ldID0gQm9vbGVhbihjaGFySXNOdW1iZXIoZm9ybWF0dGVkVmFsdWVbaV0pIHx8IGNoYXJJc051bWJlcihmb3JtYXR0ZWRWYWx1ZVtpIC0gMV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGJvdW5kYXJ5QXJ5O1xufVxuZnVuY3Rpb24gdXNlSW50ZXJuYWxWYWx1ZXModmFsdWUsIGRlZmF1bHRWYWx1ZSwgdmFsdWVJc051bWVyaWNTdHJpbmcsIGZvcm1hdCwgcmVtb3ZlRm9ybWF0dGluZywgb25WYWx1ZUNoYW5nZSkge1xuICAgIGlmICggb25WYWx1ZUNoYW5nZSA9PT0gdm9pZCAwICkgb25WYWx1ZUNoYW5nZSA9IG5vb3A7XG5cbiAgICB2YXIgcHJvcFZhbHVlcyA9IHVzZVJlZigpO1xuICAgIHZhciBnZXRWYWx1ZXMgPSB1c2VQZXJzaXN0ZW50Q2FsbGJhY2soZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBmb3JtYXR0ZWRWYWx1ZSwgbnVtQXNTdHJpbmc7XG4gICAgICAgIGlmIChpc05pbCh2YWx1ZSkgfHwgaXNOYW5WYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIG51bUFzU3RyaW5nID0gJyc7XG4gICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWVJc051bWVyaWNTdHJpbmcpIHtcbiAgICAgICAgICAgIG51bUFzU3RyaW5nID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IHRvTnVtZXJpY1N0cmluZyh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlID0gZm9ybWF0KG51bUFzU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG51bUFzU3RyaW5nID0gcmVtb3ZlRm9ybWF0dGluZyh2YWx1ZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZm9ybWF0dGVkVmFsdWU6IGZvcm1hdHRlZFZhbHVlLCBudW1Bc1N0cmluZzogbnVtQXNTdHJpbmcgfTtcbiAgICB9KTtcbiAgICB2YXIgcmVmID0gdXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZ2V0VmFsdWVzKGRlZmF1bHRWYWx1ZSk7XG4gICAgfSk7XG4gICAgdmFyIHZhbHVlcyA9IHJlZlswXTtcbiAgICB2YXIgc2V0VmFsdWVzID0gcmVmWzFdO1xuICAgIHZhciBfb25WYWx1ZUNoYW5nZSA9IGZ1bmN0aW9uICh2YWx1ZXMsIHNvdXJjZUluZm8pIHtcbiAgICAgICAgc2V0VmFsdWVzKHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlOiB2YWx1ZXMuZm9ybWF0dGVkVmFsdWUsXG4gICAgICAgICAgICBudW1Bc1N0cmluZzogdmFsdWVzLnZhbHVlLFxuICAgICAgICB9KTtcbiAgICAgICAgb25WYWx1ZUNoYW5nZSh2YWx1ZXMsIHNvdXJjZUluZm8pO1xuICAgIH07XG4gICAgdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vaWYgZWxlbWVudCBpcyBtb3ZlZCB0byB1bmNvbnRyb2xsZWQgbW9kZSwgZG9uJ3QgcmVzZXQgdGhlIHZhbHVlXG4gICAgICAgIGlmICghaXNOaWwodmFsdWUpKSB7XG4gICAgICAgICAgICBwcm9wVmFsdWVzLmN1cnJlbnQgPSBnZXRWYWx1ZXModmFsdWUpO1xuICAgICAgICAgICAgc2V0VmFsdWVzKHByb3BWYWx1ZXMuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcm9wVmFsdWVzLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9LCBbdmFsdWUsIGdldFZhbHVlc10pO1xuICAgIHJldHVybiBbdmFsdWVzLCBfb25WYWx1ZUNoYW5nZV07XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRSZW1vdmVGb3JtYXR0aW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1teMC05XS9nLCAnJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Rm9ybWF0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gTnVtYmVyRm9ybWF0QmFzZShwcm9wcykge1xuICAgIHZhciB0eXBlID0gcHJvcHMudHlwZTsgaWYgKCB0eXBlID09PSB2b2lkIDAgKSB0eXBlID0gJ3RleHQnO1xuICAgIHZhciBkaXNwbGF5VHlwZSA9IHByb3BzLmRpc3BsYXlUeXBlOyBpZiAoIGRpc3BsYXlUeXBlID09PSB2b2lkIDAgKSBkaXNwbGF5VHlwZSA9ICdpbnB1dCc7XG4gICAgdmFyIGN1c3RvbUlucHV0ID0gcHJvcHMuY3VzdG9tSW5wdXQ7XG4gICAgdmFyIHJlbmRlclRleHQgPSBwcm9wcy5yZW5kZXJUZXh0O1xuICAgIHZhciBnZXRJbnB1dFJlZiA9IHByb3BzLmdldElucHV0UmVmO1xuICAgIHZhciBmb3JtYXQgPSBwcm9wcy5mb3JtYXQ7IGlmICggZm9ybWF0ID09PSB2b2lkIDAgKSBmb3JtYXQgPSBkZWZhdWx0Rm9ybWF0O1xuICAgIHZhciByZW1vdmVGb3JtYXR0aW5nID0gcHJvcHMucmVtb3ZlRm9ybWF0dGluZzsgaWYgKCByZW1vdmVGb3JtYXR0aW5nID09PSB2b2lkIDAgKSByZW1vdmVGb3JtYXR0aW5nID0gZGVmYXVsdFJlbW92ZUZvcm1hdHRpbmc7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICB2YXIgdmFsdWVJc051bWVyaWNTdHJpbmcgPSBwcm9wcy52YWx1ZUlzTnVtZXJpY1N0cmluZztcbiAgICB2YXIgb25WYWx1ZUNoYW5nZSA9IHByb3BzLm9uVmFsdWVDaGFuZ2U7XG4gICAgdmFyIGlzQWxsb3dlZCA9IHByb3BzLmlzQWxsb3dlZDtcbiAgICB2YXIgb25DaGFuZ2UgPSBwcm9wcy5vbkNoYW5nZTsgaWYgKCBvbkNoYW5nZSA9PT0gdm9pZCAwICkgb25DaGFuZ2UgPSBub29wO1xuICAgIHZhciBvbktleURvd24gPSBwcm9wcy5vbktleURvd247IGlmICggb25LZXlEb3duID09PSB2b2lkIDAgKSBvbktleURvd24gPSBub29wO1xuICAgIHZhciBvbk1vdXNlVXAgPSBwcm9wcy5vbk1vdXNlVXA7IGlmICggb25Nb3VzZVVwID09PSB2b2lkIDAgKSBvbk1vdXNlVXAgPSBub29wO1xuICAgIHZhciBvbkZvY3VzID0gcHJvcHMub25Gb2N1czsgaWYgKCBvbkZvY3VzID09PSB2b2lkIDAgKSBvbkZvY3VzID0gbm9vcDtcbiAgICB2YXIgb25CbHVyID0gcHJvcHMub25CbHVyOyBpZiAoIG9uQmx1ciA9PT0gdm9pZCAwICkgb25CbHVyID0gbm9vcDtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHMudmFsdWU7XG4gICAgdmFyIGdldENhcmV0Qm91bmRhcnkgPSBwcm9wcy5nZXRDYXJldEJvdW5kYXJ5OyBpZiAoIGdldENhcmV0Qm91bmRhcnkgPT09IHZvaWQgMCApIGdldENhcmV0Qm91bmRhcnkgPSBjYXJldFVua25vd25Gb3JtYXRCb3VuZGFyeTtcbiAgICB2YXIgaXNWYWxpZElucHV0Q2hhcmFjdGVyID0gcHJvcHMuaXNWYWxpZElucHV0Q2hhcmFjdGVyOyBpZiAoIGlzVmFsaWRJbnB1dENoYXJhY3RlciA9PT0gdm9pZCAwICkgaXNWYWxpZElucHV0Q2hhcmFjdGVyID0gY2hhcklzTnVtYmVyO1xuICAgIHZhciBvdGhlclByb3BzID0gX19yZXN0KHByb3BzLCBbXCJ0eXBlXCIsIFwiZGlzcGxheVR5cGVcIiwgXCJjdXN0b21JbnB1dFwiLCBcInJlbmRlclRleHRcIiwgXCJnZXRJbnB1dFJlZlwiLCBcImZvcm1hdFwiLCBcInJlbW92ZUZvcm1hdHRpbmdcIiwgXCJkZWZhdWx0VmFsdWVcIiwgXCJ2YWx1ZUlzTnVtZXJpY1N0cmluZ1wiLCBcIm9uVmFsdWVDaGFuZ2VcIiwgXCJpc0FsbG93ZWRcIiwgXCJvbkNoYW5nZVwiLCBcIm9uS2V5RG93blwiLCBcIm9uTW91c2VVcFwiLCBcIm9uRm9jdXNcIiwgXCJvbkJsdXJcIiwgXCJ2YWx1ZVwiLCBcImdldENhcmV0Qm91bmRhcnlcIiwgXCJpc1ZhbGlkSW5wdXRDaGFyYWN0ZXJcIl0pO1xuICAgIHZhciByZWYgPSB1c2VJbnRlcm5hbFZhbHVlcyhwcm9wVmFsdWUsIGRlZmF1bHRWYWx1ZSwgQm9vbGVhbih2YWx1ZUlzTnVtZXJpY1N0cmluZyksIGZvcm1hdCwgcmVtb3ZlRm9ybWF0dGluZywgb25WYWx1ZUNoYW5nZSk7XG4gICAgdmFyIHJlZl8wID0gcmVmWzBdO1xuICAgIHZhciBmb3JtYXR0ZWRWYWx1ZSA9IHJlZl8wLmZvcm1hdHRlZFZhbHVlO1xuICAgIHZhciBudW1Bc1N0cmluZyA9IHJlZl8wLm51bUFzU3RyaW5nO1xuICAgIHZhciBvbkZvcm1hdHRlZFZhbHVlQ2hhbmdlID0gcmVmWzFdO1xuICAgIHZhciBsYXN0VXBkYXRlZFZhbHVlID0gdXNlUmVmKCk7XG4gICAgdmFyIF9vblZhbHVlQ2hhbmdlID0gZnVuY3Rpb24gKHZhbHVlcywgc291cmNlKSB7XG4gICAgICAgIGxhc3RVcGRhdGVkVmFsdWUuY3VycmVudCA9IHZhbHVlcy5mb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgb25Gb3JtYXR0ZWRWYWx1ZUNoYW5nZSh2YWx1ZXMsIHNvdXJjZSk7XG4gICAgfTtcbiAgICAvLyBjaGVjayBpZiB0aGVyZSBpcyBhbnkgY2hhbmdlIGluIHRoZSB2YWx1ZSBkdWUgdG8gcHJvcHMgY2hhbmdlXG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5ld0Zvcm1hdHRlZFZhbHVlID0gZm9ybWF0KG51bUFzU3RyaW5nKTtcbiAgICAgICAgLy8gaWYgdGhlIGZvcm1hdHRlZCB2YWx1ZSBpcyBub3Qgc3luY2VkIHRvIHBhcmVudCwgb3IgaWYgdGhlIGZvcm1hdHRlZCB2YWx1ZSBpcyBkaWZmZXJlbnRcbiAgICAgICAgaWYgKGxhc3RVcGRhdGVkVmFsdWUuY3VycmVudCA9PT0gdW5kZWZpbmVkIHx8IG5ld0Zvcm1hdHRlZFZhbHVlICE9PSBsYXN0VXBkYXRlZFZhbHVlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGZvY3VzZWRFbG0uY3VycmVudDtcbiAgICAgICAgICAgIC8vIGZvcm1hdHRpbmcgY2FuIHJlbW92ZSBzb21lIG9mIHRoZSBudW1iZXIgY2hhcnMsIHNvIHdlIG5lZWQgdG8gZmluZSBudW1iZXIgc3RyaW5nIGFnYWluXG4gICAgICAgICAgICB2YXIgX251bUFzU3RyaW5nID0gcmVtb3ZlRm9ybWF0dGluZyhuZXdGb3JtYXR0ZWRWYWx1ZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHVwZGF0ZVZhbHVlKHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZTogbmV3Rm9ybWF0dGVkVmFsdWUsXG4gICAgICAgICAgICAgICAgbnVtQXNTdHJpbmc6IF9udW1Bc1N0cmluZyxcbiAgICAgICAgICAgICAgICBpbnB1dDogaW5wdXQsXG4gICAgICAgICAgICAgICAgc2V0Q2FyZXRQb3NpdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IFNvdXJjZVR5cGUucHJvcHMsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIHJlZiQxID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIHZhciBtb3VudGVkID0gcmVmJDFbMF07XG4gICAgdmFyIHNldE1vdW50ZWQgPSByZWYkMVsxXTtcbiAgICB2YXIgZm9jdXNlZEVsbSA9IHVzZVJlZihudWxsKTtcbiAgICB2YXIgdGltZW91dCA9IHVzZVJlZih7XG4gICAgICAgIHNldENhcmV0VGltZW91dDogbnVsbCxcbiAgICAgICAgZm9jdXNUaW1lb3V0OiBudWxsLFxuICAgIH0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldE1vdW50ZWQodHJ1ZSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dC5jdXJyZW50LnNldENhcmV0VGltZW91dCk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dC5jdXJyZW50LmZvY3VzVGltZW91dCk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHZhciBfZm9ybWF0ID0gZm9ybWF0O1xuICAgIHZhciBnZXRWYWx1ZU9iamVjdCA9IGZ1bmN0aW9uIChmb3JtYXR0ZWRWYWx1ZSwgbnVtQXNTdHJpbmcpIHtcbiAgICAgICAgdmFyIGZsb2F0VmFsdWUgPSBwYXJzZUZsb2F0KG51bUFzU3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlOiBmb3JtYXR0ZWRWYWx1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBudW1Bc1N0cmluZyxcbiAgICAgICAgICAgIGZsb2F0VmFsdWU6IGlzTmFOKGZsb2F0VmFsdWUpID8gdW5kZWZpbmVkIDogZmxvYXRWYWx1ZSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBzZXRQYXRjaGVkQ2FyZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChlbCwgY2FyZXRQb3MsIGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAvKiBzZXR0aW5nIGNhcmV0IHBvc2l0aW9uIHdpdGhpbiB0aW1lb3V0IG9mIDBtcyBpcyByZXF1aXJlZCBmb3IgbW9iaWxlIGNocm9tZSxcbiAgICAgICAgb3RoZXJ3aXNlIGJyb3dzZXIgcmVzZXRzIHRoZSBjYXJldCBwb3NpdGlvbiBhZnRlciB3ZSBzZXQgaXRcbiAgICAgICAgV2UgYXJlIGFsc28gc2V0dGluZyBpdCB3aXRob3V0IHRpbWVvdXQgc28gdGhhdCBpbiBub3JtYWwgYnJvd3NlciB3ZSBkb24ndCBzZWUgdGhlIGZsaWNrZXJpbmcgKi9cbiAgICAgICAgc2V0Q2FyZXRQb3NpdGlvbihlbCwgY2FyZXRQb3MpO1xuICAgICAgICB0aW1lb3V0LmN1cnJlbnQuc2V0Q2FyZXRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZWwudmFsdWUgPT09IGN1cnJlbnRWYWx1ZSlcbiAgICAgICAgICAgICAgICB7IHNldENhcmV0UG9zaXRpb24oZWwsIGNhcmV0UG9zKTsgfVxuICAgICAgICB9LCAwKTtcbiAgICB9O1xuICAgIC8qIFRoaXMga2VlcHMgdGhlIGNhcmV0IHdpdGhpbiB0eXBpbmcgYXJlYSBzbyBwZW9wbGUgY2FuJ3QgdHlwZSBpbiBiZXR3ZWVuIHByZWZpeCBvciBzdWZmaXggKi9cbiAgICB2YXIgY29ycmVjdENhcmV0UG9zaXRpb24gPSBmdW5jdGlvbiAodmFsdWUsIGNhcmV0UG9zLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGdldENhcmV0UG9zSW5Cb3VuZGFyeSh2YWx1ZSwgY2FyZXRQb3MsIGdldENhcmV0Qm91bmRhcnkodmFsdWUpLCBkaXJlY3Rpb24pO1xuICAgIH07XG4gICAgdmFyIGdldE5ld0NhcmV0UG9zaXRpb24gPSBmdW5jdGlvbiAoaW5wdXRWYWx1ZSwgbmV3Rm9ybWF0dGVkVmFsdWUsIGNhcmV0UG9zKSB7XG4gICAgICAgIHZhciBjYXJldEJvdW5kYXJ5ID0gZ2V0Q2FyZXRCb3VuZGFyeShuZXdGb3JtYXR0ZWRWYWx1ZSk7XG4gICAgICAgIHZhciB1cGRhdGVkQ2FyZXRQb3MgPSBnZXRDYXJldFBvc2l0aW9uKG5ld0Zvcm1hdHRlZFZhbHVlLCBmb3JtYXR0ZWRWYWx1ZSwgaW5wdXRWYWx1ZSwgY2FyZXRQb3MsIGNhcmV0Qm91bmRhcnksIGlzVmFsaWRJbnB1dENoYXJhY3Rlcik7XG4gICAgICAgIC8vY29ycmVjdCBjYXJldCBwb3NpdGlvbiBpZiBpdHMgb3V0c2lkZSBvZiBlZGl0YWJsZSBhcmVhXG4gICAgICAgIHVwZGF0ZWRDYXJldFBvcyA9IGdldENhcmV0UG9zSW5Cb3VuZGFyeShuZXdGb3JtYXR0ZWRWYWx1ZSwgdXBkYXRlZENhcmV0UG9zLCBjYXJldEJvdW5kYXJ5KTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZWRDYXJldFBvcztcbiAgICB9O1xuICAgIHZhciB1cGRhdGVWYWx1ZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIG5ld0Zvcm1hdHRlZFZhbHVlID0gcGFyYW1zLmZvcm1hdHRlZFZhbHVlOyBpZiAoIG5ld0Zvcm1hdHRlZFZhbHVlID09PSB2b2lkIDAgKSBuZXdGb3JtYXR0ZWRWYWx1ZSA9ICcnO1xuICAgICAgICB2YXIgaW5wdXQgPSBwYXJhbXMuaW5wdXQ7XG4gICAgICAgIHZhciBzZXRDYXJldFBvc2l0aW9uID0gcGFyYW1zLnNldENhcmV0UG9zaXRpb247IGlmICggc2V0Q2FyZXRQb3NpdGlvbiA9PT0gdm9pZCAwICkgc2V0Q2FyZXRQb3NpdGlvbiA9IHRydWU7XG4gICAgICAgIHZhciBzb3VyY2UgPSBwYXJhbXMuc291cmNlO1xuICAgICAgICB2YXIgZXZlbnQgPSBwYXJhbXMuZXZlbnQ7XG4gICAgICAgIHZhciBudW1Bc1N0cmluZyA9IHBhcmFtcy5udW1Bc1N0cmluZztcbiAgICAgICAgdmFyIGNhcmV0UG9zID0gcGFyYW1zLmNhcmV0UG9zO1xuICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICAgIC8vY2FsY3VsYXRlIGNhcmV0IHBvc2l0aW9uIGlmIG5vdCBkZWZpbmVkXG4gICAgICAgICAgICBpZiAoY2FyZXRQb3MgPT09IHVuZGVmaW5lZCAmJiBzZXRDYXJldFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0VmFsdWUgPSBwYXJhbXMuaW5wdXRWYWx1ZSB8fCBpbnB1dC52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudENhcmV0UG9zaXRpb24gPSBnZUlucHV0Q2FyZXRQb3NpdGlvbihpbnB1dCk7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogc2V0IHRoZSB2YWx1ZSBpbXBlcmF0aXZlbHksIHRoaXMgaXMgcmVxdWlyZWQgZm9yIElFIGZpeFxuICAgICAgICAgICAgICAgICAqIFRoaXMgaXMgYWxzbyByZXF1aXJlZCBhcyBpZiBuZXcgY2FyZXQgcG9zaXRpb24gaXMgYmV5b25kIHRoZSBwcmV2aW91cyB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgKiBDYXJldCBwb3NpdGlvbiB3aWxsIG5vdCBiZSBzZXQgY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaW5wdXQudmFsdWUgPSBuZXdGb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICAvL2dldCB0aGUgY2FyZXQgcG9zaXRpb25cbiAgICAgICAgICAgICAgICBjYXJldFBvcyA9IGdldE5ld0NhcmV0UG9zaXRpb24oaW5wdXRWYWx1ZSwgbmV3Rm9ybWF0dGVkVmFsdWUsIGN1cnJlbnRDYXJldFBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogc2V0IHRoZSB2YWx1ZSBpbXBlcmF0aXZlbHksIGFzIHdlIHNldCB0aGUgY2FyZXQgcG9zaXRpb24gYXMgd2VsbCBpbXBlcmF0aXZlbHkuXG4gICAgICAgICAgICAgKiBUaGlzIGlzIHRvIGtlZXAgdmFsdWUgYW5kIGNhcmV0IHBvc2l0aW9uIGluIHN5bmNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaW5wdXQudmFsdWUgPSBuZXdGb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgICAgIC8vc2V0IGNhcmV0IHBvc2l0aW9uLCBhbmQgdmFsdWUgaW1wZXJhdGl2ZWx5IHdoZW4gZWxlbWVudCBpcyBwcm92aWRlZFxuICAgICAgICAgICAgaWYgKHNldENhcmV0UG9zaXRpb24gJiYgY2FyZXRQb3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vc2V0IGNhcmV0IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgc2V0UGF0Y2hlZENhcmV0UG9zaXRpb24oaW5wdXQsIGNhcmV0UG9zLCBuZXdGb3JtYXR0ZWRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0Zvcm1hdHRlZFZhbHVlICE9PSBmb3JtYXR0ZWRWYWx1ZSkge1xuICAgICAgICAgICAgLy8gdHJpZ2dlciBvblZhbHVlQ2hhbmdlIHN5bmNocm9ub3VzbHksIHNvIHBhcmVudCBpcyB1cGRhdGVkIGFsb25nIHdpdGggdGhlIG51bWJlciBmb3JtYXQuIEZpeCBmb3IgIzI3NywgIzI4N1xuICAgICAgICAgICAgX29uVmFsdWVDaGFuZ2UoZ2V0VmFsdWVPYmplY3QobmV3Rm9ybWF0dGVkVmFsdWUsIG51bUFzU3RyaW5nKSwgeyBldmVudDogZXZlbnQsIHNvdXJjZTogc291cmNlIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgZm9ybWF0SW5wdXRWYWx1ZSA9IGZ1bmN0aW9uIChpbnB1dFZhbHVlLCBldmVudCwgc291cmNlKSB7XG4gICAgICAgIHZhciBjaGFuZ2VSYW5nZSA9IGZpbmRDaGFuZ2VSYW5nZShmb3JtYXR0ZWRWYWx1ZSwgaW5wdXRWYWx1ZSk7XG4gICAgICAgIHZhciBjaGFuZ2VNZXRhID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjaGFuZ2VSYW5nZSksIHsgbGFzdFZhbHVlOiBmb3JtYXR0ZWRWYWx1ZSB9KTtcbiAgICAgICAgdmFyIF9udW1Bc1N0cmluZyA9IHJlbW92ZUZvcm1hdHRpbmcoaW5wdXRWYWx1ZSwgY2hhbmdlTWV0YSk7XG4gICAgICAgIHZhciBfZm9ybWF0dGVkVmFsdWUgPSBfZm9ybWF0KF9udW1Bc1N0cmluZyk7XG4gICAgICAgIC8vIGZvcm1hdHRpbmcgY2FuIHJlbW92ZSBzb21lIG9mIHRoZSBudW1iZXIgY2hhcnMsIHNvIHdlIG5lZWQgdG8gZmluZSBudW1iZXIgc3RyaW5nIGFnYWluXG4gICAgICAgIF9udW1Bc1N0cmluZyA9IHJlbW92ZUZvcm1hdHRpbmcoX2Zvcm1hdHRlZFZhbHVlLCB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoaXNBbGxvd2VkICYmICFpc0FsbG93ZWQoZ2V0VmFsdWVPYmplY3QoX2Zvcm1hdHRlZFZhbHVlLCBfbnVtQXNTdHJpbmcpKSkge1xuICAgICAgICAgICAgLy9yZXNldCB0aGUgY2FyZXQgcG9zaXRpb25cbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIHZhciBjdXJyZW50Q2FyZXRQb3NpdGlvbiA9IGdlSW5wdXRDYXJldFBvc2l0aW9uKGlucHV0KTtcbiAgICAgICAgICAgIHZhciBjYXJldFBvcyA9IGdldE5ld0NhcmV0UG9zaXRpb24oaW5wdXRWYWx1ZSwgZm9ybWF0dGVkVmFsdWUsIGN1cnJlbnRDYXJldFBvc2l0aW9uKTtcbiAgICAgICAgICAgIHNldFBhdGNoZWRDYXJldFBvc2l0aW9uKGlucHV0LCBjYXJldFBvcywgZm9ybWF0dGVkVmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZVZhbHVlKHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlOiBfZm9ybWF0dGVkVmFsdWUsXG4gICAgICAgICAgICBudW1Bc1N0cmluZzogX251bUFzU3RyaW5nLFxuICAgICAgICAgICAgaW5wdXRWYWx1ZTogaW5wdXRWYWx1ZSxcbiAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgc2V0Q2FyZXRQb3NpdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIGlucHV0OiBldmVudC50YXJnZXQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIHZhciBfb25DaGFuZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgZWwgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIGlucHV0VmFsdWUgPSBlbC52YWx1ZTtcbiAgICAgICAgdmFyIGNoYW5nZWQgPSBmb3JtYXRJbnB1dFZhbHVlKGlucHV0VmFsdWUsIGUsIFNvdXJjZVR5cGUuZXZlbnQpO1xuICAgICAgICBpZiAoY2hhbmdlZClcbiAgICAgICAgICAgIHsgb25DaGFuZ2UoZSk7IH1cbiAgICB9O1xuICAgIHZhciBfb25LZXlEb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGVsID0gZS50YXJnZXQ7XG4gICAgICAgIHZhciBrZXkgPSBlLmtleTtcbiAgICAgICAgdmFyIHNlbGVjdGlvblN0YXJ0ID0gZWwuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIHZhciBzZWxlY3Rpb25FbmQgPSBlbC5zZWxlY3Rpb25FbmQ7XG4gICAgICAgIHZhciB2YWx1ZSA9IGVsLnZhbHVlOyBpZiAoIHZhbHVlID09PSB2b2lkIDAgKSB2YWx1ZSA9ICcnO1xuICAgICAgICB2YXIgZXhwZWN0ZWRDYXJldFBvc2l0aW9uO1xuICAgICAgICAvL0hhbmRsZSBiYWNrc3BhY2UgYW5kIGRlbGV0ZSBhZ2FpbnN0IG5vbiBudW1lcmljYWwvZGVjaW1hbCBjaGFyYWN0ZXJzIG9yIGFycm93IGtleXNcbiAgICAgICAgaWYgKGtleSA9PT0gJ0Fycm93TGVmdCcgfHwga2V5ID09PSAnQmFja3NwYWNlJykge1xuICAgICAgICAgICAgZXhwZWN0ZWRDYXJldFBvc2l0aW9uID0gTWF0aC5tYXgoc2VsZWN0aW9uU3RhcnQgLSAxLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdBcnJvd1JpZ2h0Jykge1xuICAgICAgICAgICAgZXhwZWN0ZWRDYXJldFBvc2l0aW9uID0gTWF0aC5taW4oc2VsZWN0aW9uU3RhcnQgKyAxLCB2YWx1ZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ0RlbGV0ZScpIHtcbiAgICAgICAgICAgIGV4cGVjdGVkQ2FyZXRQb3NpdGlvbiA9IHNlbGVjdGlvblN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIC8vaWYgZXhwZWN0ZWRDYXJldFBvc2l0aW9uIGlzIG5vdCBzZXQgaXQgbWVhbnMgd2UgZG9uJ3Qgd2FudCB0byBIYW5kbGUga2V5RG93blxuICAgICAgICAvLyBhbHNvIGlmIG11bHRpcGxlIGNoYXJhY3RlcnMgYXJlIHNlbGVjdGVkIGRvbid0IGhhbmRsZVxuICAgICAgICBpZiAoZXhwZWN0ZWRDYXJldFBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgc2VsZWN0aW9uU3RhcnQgIT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgb25LZXlEb3duKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdDYXJldFBvc2l0aW9uID0gZXhwZWN0ZWRDYXJldFBvc2l0aW9uO1xuICAgICAgICBpZiAoa2V5ID09PSAnQXJyb3dMZWZ0JyB8fCBrZXkgPT09ICdBcnJvd1JpZ2h0Jykge1xuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGtleSA9PT0gJ0Fycm93TGVmdCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICAgICAgbmV3Q2FyZXRQb3NpdGlvbiA9IGNvcnJlY3RDYXJldFBvc2l0aW9uKHZhbHVlLCBleHBlY3RlZENhcmV0UG9zaXRpb24sIGRpcmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnRGVsZXRlJyAmJiAhaXNWYWxpZElucHV0Q2hhcmFjdGVyKHZhbHVlW2V4cGVjdGVkQ2FyZXRQb3NpdGlvbl0pKSB7XG4gICAgICAgICAgICAvLyBpbiBjYXNlIG9mIGRlbGV0ZSBnbyB0byBjbG9zZXN0IGNhcmV0IGJvdW5kYXJ5IG9uIHRoZSByaWdodCBzaWRlXG4gICAgICAgICAgICBuZXdDYXJldFBvc2l0aW9uID0gY29ycmVjdENhcmV0UG9zaXRpb24odmFsdWUsIGV4cGVjdGVkQ2FyZXRQb3NpdGlvbiwgJ3JpZ2h0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnQmFja3NwYWNlJyAmJiAhaXNWYWxpZElucHV0Q2hhcmFjdGVyKHZhbHVlW2V4cGVjdGVkQ2FyZXRQb3NpdGlvbl0pKSB7XG4gICAgICAgICAgICAvLyBpbiBjYXNlIG9mIGJhY2tzcGFjZSBnbyB0byBjbG9zZXN0IGNhcmV0IGJvdW5kYXJ5IG9uIHRoZSBsZWZ0IHNpZGVcbiAgICAgICAgICAgIG5ld0NhcmV0UG9zaXRpb24gPSBjb3JyZWN0Q2FyZXRQb3NpdGlvbih2YWx1ZSwgZXhwZWN0ZWRDYXJldFBvc2l0aW9uLCAnbGVmdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdDYXJldFBvc2l0aW9uICE9PSBleHBlY3RlZENhcmV0UG9zaXRpb24pIHtcbiAgICAgICAgICAgIHNldFBhdGNoZWRDYXJldFBvc2l0aW9uKGVsLCBuZXdDYXJldFBvc2l0aW9uLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyogTk9URTogdGhpcyBpcyBqdXN0IHJlcXVpcmVkIGZvciB1bml0IHRlc3QgYXMgd2UgbmVlZCB0byBnZXQgdGhlIG5ld0NhcmV0UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgUmVtb3ZlIHRoaXMgd2hlbiB5b3UgZmluZCBkaWZmZXJlbnQgc29sdXRpb24gKi9cbiAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICBpZiAoZS5pc1VuaXRUZXN0UnVuKSB7XG4gICAgICAgICAgICBzZXRQYXRjaGVkQ2FyZXRQb3NpdGlvbihlbCwgbmV3Q2FyZXRQb3NpdGlvbiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIG9uS2V5RG93bihlKTtcbiAgICB9O1xuICAgIC8qKiByZXF1aXJlZCB0byBoYW5kbGUgdGhlIGNhcmV0IHBvc2l0aW9uIHdoZW4gY2xpY2sgYW55d2hlcmUgd2l0aGluIHRoZSBpbnB1dCAqKi9cbiAgICB2YXIgX29uTW91c2VVcCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBlbCA9IGUudGFyZ2V0O1xuICAgICAgICAvKipcbiAgICAgICAgICogTk9URTogd2UgaGF2ZSB0byBnaXZlIGRlZmF1bHQgdmFsdWUgZm9yIHZhbHVlIGFzIGluIGNhc2Ugd2hlbiBjdXN0b20gaW5wdXQgaXMgcHJvdmlkZWRcbiAgICAgICAgICogdmFsdWUgY2FuIGNvbWUgYXMgdW5kZWZpbmVkIHdoZW4gbm90aGluZyBpcyBwcm92aWRlZCBvbiB2YWx1ZSBwcm9wLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHNlbGVjdGlvblN0YXJ0ID0gZWwuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIHZhciBzZWxlY3Rpb25FbmQgPSBlbC5zZWxlY3Rpb25FbmQ7XG4gICAgICAgIHZhciB2YWx1ZSA9IGVsLnZhbHVlOyBpZiAoIHZhbHVlID09PSB2b2lkIDAgKSB2YWx1ZSA9ICcnO1xuICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgdmFyIGNhcmV0UG9zaXRpb24gPSBjb3JyZWN0Q2FyZXRQb3NpdGlvbih2YWx1ZSwgc2VsZWN0aW9uU3RhcnQpO1xuICAgICAgICAgICAgaWYgKGNhcmV0UG9zaXRpb24gIT09IHNlbGVjdGlvblN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgc2V0UGF0Y2hlZENhcmV0UG9zaXRpb24oZWwsIGNhcmV0UG9zaXRpb24sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvbk1vdXNlVXAoZSk7XG4gICAgfTtcbiAgICB2YXIgX29uRm9jdXMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyBXb3JrYXJvdW5kIENocm9tZSBhbmQgU2FmYXJpIGJ1ZyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD03NzkzMjhcbiAgICAgICAgLy8gKG9uRm9jdXMgZXZlbnQgdGFyZ2V0IHNlbGVjdGlvblN0YXJ0IGlzIGFsd2F5cyAwIGJlZm9yZSBzZXRUaW1lb3V0KVxuICAgICAgICBpZiAoZS5wZXJzaXN0KVxuICAgICAgICAgICAgeyBlLnBlcnNpc3QoKTsgfVxuICAgICAgICB2YXIgZWwgPSBlLnRhcmdldDtcbiAgICAgICAgZm9jdXNlZEVsbS5jdXJyZW50ID0gZWw7XG4gICAgICAgIHRpbWVvdXQuY3VycmVudC5mb2N1c1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25TdGFydCA9IGVsLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbkVuZCA9IGVsLnNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGVsLnZhbHVlOyBpZiAoIHZhbHVlID09PSB2b2lkIDAgKSB2YWx1ZSA9ICcnO1xuICAgICAgICAgICAgdmFyIGNhcmV0UG9zaXRpb24gPSBjb3JyZWN0Q2FyZXRQb3NpdGlvbih2YWx1ZSwgc2VsZWN0aW9uU3RhcnQpO1xuICAgICAgICAgICAgLy9zZXRQYXRjaGVkQ2FyZXRQb3NpdGlvbiBvbmx5IHdoZW4gZXZlcnl0aGluZyBpcyBub3Qgc2VsZWN0ZWQgb24gZm9jdXMgKHdoaWxlIHRhYmJpbmcgaW50byB0aGUgZmllbGQpXG4gICAgICAgICAgICBpZiAoY2FyZXRQb3NpdGlvbiAhPT0gc2VsZWN0aW9uU3RhcnQgJiZcbiAgICAgICAgICAgICAgICAhKHNlbGVjdGlvblN0YXJ0ID09PSAwICYmIHNlbGVjdGlvbkVuZCA9PT0gdmFsdWUubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHNldFBhdGNoZWRDYXJldFBvc2l0aW9uKGVsLCBjYXJldFBvc2l0aW9uLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbkZvY3VzKGUpO1xuICAgICAgICB9LCAwKTtcbiAgICB9O1xuICAgIHZhciBfb25CbHVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZm9jdXNlZEVsbS5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQuY3VycmVudC5mb2N1c1RpbWVvdXQpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dC5jdXJyZW50LnNldENhcmV0VGltZW91dCk7XG4gICAgICAgIG9uQmx1cihlKTtcbiAgICB9O1xuICAgIC8vIGFkZCBpbnB1dCBtb2RlIG9uIGVsZW1lbnQgYmFzZWQgb24gZm9ybWF0IHByb3AgYW5kIGRldmljZSBvbmNlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZFxuICAgIHZhciBpbnB1dE1vZGUgPSBtb3VudGVkICYmIGFkZElucHV0TW9kZSgpID8gJ251bWVyaWMnIDogdW5kZWZpbmVkO1xuICAgIHZhciBpbnB1dFByb3BzID0gT2JqZWN0LmFzc2lnbih7IGlucHV0TW9kZTogaW5wdXRNb2RlIH0sIG90aGVyUHJvcHMsIHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgdmFsdWU6IGZvcm1hdHRlZFZhbHVlLFxuICAgICAgICBvbkNoYW5nZTogX29uQ2hhbmdlLFxuICAgICAgICBvbktleURvd246IF9vbktleURvd24sXG4gICAgICAgIG9uTW91c2VVcDogX29uTW91c2VVcCxcbiAgICAgICAgb25Gb2N1czogX29uRm9jdXMsXG4gICAgICAgIG9uQmx1cjogX29uQmx1cixcbiAgICB9KTtcbiAgICBpZiAoZGlzcGxheVR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICByZXR1cm4gcmVuZGVyVGV4dCA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCByZW5kZXJUZXh0KGZvcm1hdHRlZFZhbHVlLCBvdGhlclByb3BzKSB8fCBudWxsKSkgOiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgT2JqZWN0LmFzc2lnbih7fSwgb3RoZXJQcm9wcywgeyByZWY6IGdldElucHV0UmVmIH0pLCBmb3JtYXR0ZWRWYWx1ZSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjdXN0b21JbnB1dCkge1xuICAgICAgICB2YXIgQ3VzdG9tSW5wdXQgPSBjdXN0b21JbnB1dDtcbiAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDdXN0b21JbnB1dCwgT2JqZWN0LmFzc2lnbih7fSwgaW5wdXRQcm9wcywgeyByZWY6IGdldElucHV0UmVmIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCBPYmplY3QuYXNzaWduKHt9LCBpbnB1dFByb3BzLCB7IHJlZjogZ2V0SW5wdXRSZWYgfSkpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXQobnVtU3RyLCBwcm9wcykge1xuICAgIHZhciBkZWNpbWFsU2NhbGUgPSBwcm9wcy5kZWNpbWFsU2NhbGU7XG4gICAgdmFyIGZpeGVkRGVjaW1hbFNjYWxlID0gcHJvcHMuZml4ZWREZWNpbWFsU2NhbGU7XG4gICAgdmFyIHByZWZpeCA9IHByb3BzLnByZWZpeDsgaWYgKCBwcmVmaXggPT09IHZvaWQgMCApIHByZWZpeCA9ICcnO1xuICAgIHZhciBzdWZmaXggPSBwcm9wcy5zdWZmaXg7IGlmICggc3VmZml4ID09PSB2b2lkIDAgKSBzdWZmaXggPSAnJztcbiAgICB2YXIgYWxsb3dOZWdhdGl2ZSA9IHByb3BzLmFsbG93TmVnYXRpdmU7XG4gICAgdmFyIHRob3VzYW5kc0dyb3VwU3R5bGUgPSBwcm9wcy50aG91c2FuZHNHcm91cFN0eWxlOyBpZiAoIHRob3VzYW5kc0dyb3VwU3R5bGUgPT09IHZvaWQgMCApIHRob3VzYW5kc0dyb3VwU3R5bGUgPSAndGhvdXNhbmQnO1xuICAgIC8vIGRvbid0IGFwcGx5IGZvcm1hdHRpbmcgb24gZW1wdHkgc3RyaW5nIG9yICctJ1xuICAgIGlmIChudW1TdHIgPT09ICcnIHx8IG51bVN0ciA9PT0gJy0nKSB7XG4gICAgICAgIHJldHVybiBudW1TdHI7XG4gICAgfVxuICAgIHZhciByZWYgPSBnZXRTZXBhcmF0b3JzKHByb3BzKTtcbiAgICB2YXIgdGhvdXNhbmRTZXBhcmF0b3IgPSByZWYudGhvdXNhbmRTZXBhcmF0b3I7XG4gICAgdmFyIGRlY2ltYWxTZXBhcmF0b3IgPSByZWYuZGVjaW1hbFNlcGFyYXRvcjtcbiAgICAvKipcbiAgICAgKiBLZWVwIHRoZSBkZWNpbWFsIHNlcGFyYXRvclxuICAgICAqIHdoZW4gZGVjaW1hbFNjYWxlIGlzIG5vdCBkZWZpbmVkIG9yIG5vbiB6ZXJvIGFuZCB0aGUgbnVtU3RyIGhhcyBkZWNpbWFsIGluIGl0XG4gICAgICogT3IgaWYgZGVjaW1hbFNjYWxlIGlzID4gMCBhbmQgZml4ZURlY2ltYWxTY2FsZSBpcyB0cnVlIChldmVuIGlmIG51bVN0ciBoYXMgbm8gZGVjaW1hbClcbiAgICAgKi9cbiAgICB2YXIgaGFzRGVjaW1hbFNlcGFyYXRvciA9IChkZWNpbWFsU2NhbGUgIT09IDAgJiYgbnVtU3RyLmluZGV4T2YoJy4nKSAhPT0gLTEpIHx8IChkZWNpbWFsU2NhbGUgJiYgZml4ZWREZWNpbWFsU2NhbGUpO1xuICAgIHZhciByZWYkMSA9IHNwbGl0RGVjaW1hbChudW1TdHIsIGFsbG93TmVnYXRpdmUpO1xuICAgIHZhciBiZWZvcmVEZWNpbWFsID0gcmVmJDEuYmVmb3JlRGVjaW1hbDtcbiAgICB2YXIgYWZ0ZXJEZWNpbWFsID0gcmVmJDEuYWZ0ZXJEZWNpbWFsO1xuICAgIHZhciBhZGROZWdhdGlvbiA9IHJlZiQxLmFkZE5lZ2F0aW9uOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1jb25zdFxuICAgIC8vYXBwbHkgZGVjaW1hbCBwcmVjaXNpb24gaWYgaXRzIGRlZmluZWRcbiAgICBpZiAoZGVjaW1hbFNjYWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWZ0ZXJEZWNpbWFsID0gbGltaXRUb1NjYWxlKGFmdGVyRGVjaW1hbCwgZGVjaW1hbFNjYWxlLCAhIWZpeGVkRGVjaW1hbFNjYWxlKTtcbiAgICB9XG4gICAgaWYgKHRob3VzYW5kU2VwYXJhdG9yKSB7XG4gICAgICAgIGJlZm9yZURlY2ltYWwgPSBhcHBseVRob3VzYW5kU2VwYXJhdG9yKGJlZm9yZURlY2ltYWwsIHRob3VzYW5kU2VwYXJhdG9yLCB0aG91c2FuZHNHcm91cFN0eWxlKTtcbiAgICB9XG4gICAgLy9hZGQgcHJlZml4IGFuZCBzdWZmaXggd2hlbiB0aGVyZSBpcyBhIG51bWJlciBwcmVzZW50XG4gICAgaWYgKHByZWZpeClcbiAgICAgICAgeyBiZWZvcmVEZWNpbWFsID0gcHJlZml4ICsgYmVmb3JlRGVjaW1hbDsgfVxuICAgIGlmIChzdWZmaXgpXG4gICAgICAgIHsgYWZ0ZXJEZWNpbWFsID0gYWZ0ZXJEZWNpbWFsICsgc3VmZml4OyB9XG4gICAgLy9yZXN0b3JlIG5lZ2F0aW9uIHNpZ25cbiAgICBpZiAoYWRkTmVnYXRpb24pXG4gICAgICAgIHsgYmVmb3JlRGVjaW1hbCA9ICctJyArIGJlZm9yZURlY2ltYWw7IH1cbiAgICBudW1TdHIgPSBiZWZvcmVEZWNpbWFsICsgKChoYXNEZWNpbWFsU2VwYXJhdG9yICYmIGRlY2ltYWxTZXBhcmF0b3IpIHx8ICcnKSArIGFmdGVyRGVjaW1hbDtcbiAgICByZXR1cm4gbnVtU3RyO1xufVxuZnVuY3Rpb24gZ2V0U2VwYXJhdG9ycyhwcm9wcykge1xuICAgIHZhciBkZWNpbWFsU2VwYXJhdG9yID0gcHJvcHMuZGVjaW1hbFNlcGFyYXRvcjsgaWYgKCBkZWNpbWFsU2VwYXJhdG9yID09PSB2b2lkIDAgKSBkZWNpbWFsU2VwYXJhdG9yID0gJy4nO1xuICAgIHZhciB0aG91c2FuZFNlcGFyYXRvciA9IHByb3BzLnRob3VzYW5kU2VwYXJhdG9yO1xuICAgIHZhciBhbGxvd2VkRGVjaW1hbFNlcGFyYXRvcnMgPSBwcm9wcy5hbGxvd2VkRGVjaW1hbFNlcGFyYXRvcnM7XG4gICAgaWYgKHRob3VzYW5kU2VwYXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgIHRob3VzYW5kU2VwYXJhdG9yID0gJywnO1xuICAgIH1cbiAgICBpZiAoIWFsbG93ZWREZWNpbWFsU2VwYXJhdG9ycykge1xuICAgICAgICBhbGxvd2VkRGVjaW1hbFNlcGFyYXRvcnMgPSBbZGVjaW1hbFNlcGFyYXRvciwgJy4nXTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVjaW1hbFNlcGFyYXRvcjogZGVjaW1hbFNlcGFyYXRvcixcbiAgICAgICAgdGhvdXNhbmRTZXBhcmF0b3I6IHRob3VzYW5kU2VwYXJhdG9yLFxuICAgICAgICBhbGxvd2VkRGVjaW1hbFNlcGFyYXRvcnM6IGFsbG93ZWREZWNpbWFsU2VwYXJhdG9ycyxcbiAgICB9O1xufVxuZnVuY3Rpb24gaGFuZGxlTmVnYXRpb24odmFsdWUsIGFsbG93TmVnYXRpdmUpIHtcbiAgICBpZiAoIHZhbHVlID09PSB2b2lkIDAgKSB2YWx1ZSA9ICcnO1xuXG4gICAgdmFyIG5lZ2F0aW9uUmVnZXggPSBuZXcgUmVnRXhwKCcoLSknKTtcbiAgICB2YXIgZG91YmxlTmVnYXRpb25SZWdleCA9IG5ldyBSZWdFeHAoJygtKSguKSooLSknKTtcbiAgICAvLyBDaGVjayBudW1iZXIgaGFzICctJyB2YWx1ZVxuICAgIHZhciBoYXNOZWdhdGlvbiA9IG5lZ2F0aW9uUmVnZXgudGVzdCh2YWx1ZSk7XG4gICAgLy8gQ2hlY2sgbnVtYmVyIGhhcyAyIG9yIG1vcmUgJy0nIHZhbHVlc1xuICAgIHZhciByZW1vdmVOZWdhdGlvbiA9IGRvdWJsZU5lZ2F0aW9uUmVnZXgudGVzdCh2YWx1ZSk7XG4gICAgLy9yZW1vdmUgbmVnYXRpb25cbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoLy0vZywgJycpO1xuICAgIGlmIChoYXNOZWdhdGlvbiAmJiAhcmVtb3ZlTmVnYXRpb24gJiYgYWxsb3dOZWdhdGl2ZSkge1xuICAgICAgICB2YWx1ZSA9ICctJyArIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBnZXROdW1iZXJSZWdleChkZWNpbWFsU2VwYXJhdG9yLCBnbG9iYWwpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgoXCIoXi0pfFswLTldfFwiICsgKGVzY2FwZVJlZ0V4cChkZWNpbWFsU2VwYXJhdG9yKSkpLCBnbG9iYWwgPyAnZycgOiB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZyh2YWx1ZSwgY2hhbmdlTWV0YSwgcHJvcHMpIHtcbiAgICB2YXIgYXNzaWduO1xuXG4gICAgaWYgKCBjaGFuZ2VNZXRhID09PSB2b2lkIDAgKSBjaGFuZ2VNZXRhID0gZ2V0RGVmYXVsdENoYW5nZU1ldGEodmFsdWUpO1xuICAgIHZhciBhbGxvd05lZ2F0aXZlID0gcHJvcHMuYWxsb3dOZWdhdGl2ZTtcbiAgICB2YXIgcHJlZml4ID0gcHJvcHMucHJlZml4OyBpZiAoIHByZWZpeCA9PT0gdm9pZCAwICkgcHJlZml4ID0gJyc7XG4gICAgdmFyIHN1ZmZpeCA9IHByb3BzLnN1ZmZpeDsgaWYgKCBzdWZmaXggPT09IHZvaWQgMCApIHN1ZmZpeCA9ICcnO1xuICAgIHZhciBkZWNpbWFsU2NhbGUgPSBwcm9wcy5kZWNpbWFsU2NhbGU7XG4gICAgdmFyIGZyb20gPSBjaGFuZ2VNZXRhLmZyb207XG4gICAgdmFyIHRvID0gY2hhbmdlTWV0YS50bztcbiAgICB2YXIgc3RhcnQgPSB0by5zdGFydDtcbiAgICB2YXIgZW5kID0gdG8uZW5kO1xuICAgIHZhciByZWYgPSBnZXRTZXBhcmF0b3JzKHByb3BzKTtcbiAgICB2YXIgYWxsb3dlZERlY2ltYWxTZXBhcmF0b3JzID0gcmVmLmFsbG93ZWREZWNpbWFsU2VwYXJhdG9ycztcbiAgICB2YXIgZGVjaW1hbFNlcGFyYXRvciA9IHJlZi5kZWNpbWFsU2VwYXJhdG9yO1xuICAgIHZhciBpc0JlZm9yZURlY2ltYWxTZXBhcmF0b3IgPSB2YWx1ZVtlbmRdID09PSBkZWNpbWFsU2VwYXJhdG9yO1xuICAgIC8qKlxuICAgICAqIElmIG9ubHkgYSBudW1iZXIgaXMgYWRkZWQgb24gZW1wdHkgaW5wdXQgd2hpY2ggbWF0Y2hlcyB3aXRoIHRoZSBwcmVmaXggb3Igc3VmZml4LFxuICAgICAqIHRoZW4gZG9uJ3QgcmVtb3ZlIGl0LCBqdXN0IHJldHVybiB0aGUgc2FtZVxuICAgICAqL1xuICAgIGlmIChjaGFySXNOdW1iZXIodmFsdWUpICYmXG4gICAgICAgICh2YWx1ZSA9PT0gcHJlZml4IHx8IHZhbHVlID09PSBzdWZmaXgpICYmXG4gICAgICAgIGNoYW5nZU1ldGEubGFzdFZhbHVlID09PSAnJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKiBDaGVjayBmb3IgYW55IGFsbG93ZWQgZGVjaW1hbCBzZXBhcmF0b3IgaXMgYWRkZWQgaW4gdGhlIG51bWVyaWMgZm9ybWF0IGFuZCByZXBsYWNlIGl0IHdpdGggZGVjaW1hbCBzZXBhcmF0b3IgKi9cbiAgICBpZiAoZW5kIC0gc3RhcnQgPT09IDEgJiYgYWxsb3dlZERlY2ltYWxTZXBhcmF0b3JzLmluZGV4T2YodmFsdWVbc3RhcnRdKSAhPT0gLTEpIHtcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9IGRlY2ltYWxTY2FsZSA9PT0gMCA/ICcnIDogZGVjaW1hbFNlcGFyYXRvcjtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgc3RhcnQpICsgc2VwYXJhdG9yICsgdmFsdWUuc3Vic3RyaW5nKHN0YXJ0ICsgMSwgdmFsdWUubGVuZ3RoKTtcbiAgICB9XG4gICAgdmFyIHN0cmlwTmVnYXRpb24gPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGlmIHByZWZpeCBzdGFydHMgd2l0aCAtIHdlIGRvbid0IGFsbG93IG5lZ2F0aXZlIG51bWJlciB0byBhdm9pZCBjb25mdXNpb25cbiAgICAgICAgICogaWYgc3VmZml4IHN0YXJ0cyB3aXRoIC0gYW5kIHRoZSB2YWx1ZSBsZW5ndGggaXMgc2FtZSBhcyBzdWZmaXggbGVuZ3RoLCB0aGVuIHRoZSAtIHNpZ24gaXMgZnJvbSB0aGUgc3VmZml4XG4gICAgICAgICAqIEluIG90aGVyIGNhc2VzLCBpZiB0aGUgdmFsdWUgc3RhcnRzIHdpdGggLSB0aGVuIGl0IGlzIGEgbmVnYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHZhciBoYXNOZWdhdGlvbiA9IGZhbHNlO1xuICAgICAgICB2YXIgaGFzRG91YmxlTmVnYXRpb24gPSBmYWxzZTtcbiAgICAgICAgaWYgKHByZWZpeC5zdGFydHNXaXRoKCctJykpIHtcbiAgICAgICAgICAgIGhhc05lZ2F0aW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUuc3RhcnRzV2l0aCgnLS0nKSkge1xuICAgICAgICAgICAgaGFzTmVnYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIGhhc0RvdWJsZU5lZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdWZmaXguc3RhcnRzV2l0aCgnLScpICYmIHZhbHVlLmxlbmd0aCA9PT0gc3VmZml4Lmxlbmd0aCkge1xuICAgICAgICAgICAgaGFzTmVnYXRpb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZVswXSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBoYXNOZWdhdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYXJzVG9SZW1vdmUgPSBoYXNOZWdhdGlvbiA/IDEgOiAwO1xuICAgICAgICBpZiAoaGFzRG91YmxlTmVnYXRpb24pXG4gICAgICAgICAgICB7IGNoYXJzVG9SZW1vdmUgPSAyOyB9XG4gICAgICAgIC8vIHJlbW92ZSBuZWdhdGlvbi9kb3VibGUgbmVnYXRpb24gZnJvbSBzdGFydCB0byBzaW1wbGlmeSBwcmVmaXggbG9naWMgYXMgbmVnYXRpb24gY29tZXMgYmVmb3JlIHByZWZpeFxuICAgICAgICBpZiAoY2hhcnNUb1JlbW92ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoY2hhcnNUb1JlbW92ZSk7XG4gICAgICAgICAgICAvLyBhY2NvdW50IGZvciB0aGUgcmVtb3ZhbCBvZiB0aGUgbmVnYXRpb24gZm9yIHN0YXJ0IGFuZCBlbmQgaW5kZXhcbiAgICAgICAgICAgIHN0YXJ0IC09IGNoYXJzVG9SZW1vdmU7XG4gICAgICAgICAgICBlbmQgLT0gY2hhcnNUb1JlbW92ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQsIGhhc05lZ2F0aW9uOiBoYXNOZWdhdGlvbiB9O1xuICAgIH07XG4gICAgdmFyIHRvTWV0YWRhdGEgPSBzdHJpcE5lZ2F0aW9uKHZhbHVlLCBzdGFydCwgZW5kKTtcbiAgICB2YXIgaGFzTmVnYXRpb24gPSB0b01ldGFkYXRhLmhhc05lZ2F0aW9uO1xuICAgICgoYXNzaWduID0gdG9NZXRhZGF0YSwgdmFsdWUgPSBhc3NpZ24udmFsdWUsIHN0YXJ0ID0gYXNzaWduLnN0YXJ0LCBlbmQgPSBhc3NpZ24uZW5kKSk7XG4gICAgdmFyIHJlZiQxID0gc3RyaXBOZWdhdGlvbihjaGFuZ2VNZXRhLmxhc3RWYWx1ZSwgZnJvbS5zdGFydCwgZnJvbS5lbmQpO1xuICAgIHZhciBmcm9tU3RhcnQgPSByZWYkMS5zdGFydDtcbiAgICB2YXIgZnJvbUVuZCA9IHJlZiQxLmVuZDtcbiAgICB2YXIgbGFzdFZhbHVlID0gcmVmJDEudmFsdWU7XG4gICAgLy8gaWYgb25seSBwcmVmaXggYW5kIHN1ZmZpeCBwYXJ0IGlzIHVwZGF0ZWQgcmVzZXQgdGhlIHZhbHVlIHRvIGxhc3QgdmFsdWVcbiAgICAvLyBpZiB0aGUgY2hhbmdlZCByYW5nZSBpcyBmcm9tIHN1ZmZpeCBpbiB0aGUgdXBkYXRlZCB2YWx1ZSwgYW5kIHRoZSB0aGUgc3VmZml4IHN0YXJ0cyB3aXRoIHRoZSBzYW1lIGNoYXJhY3RlcnMsIGFsbG93IHRoZSBjaGFuZ2VcbiAgICB2YXIgdXBkYXRlZFN1ZmZpeFBhcnQgPSB2YWx1ZS5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCAmJlxuICAgICAgICBsYXN0VmFsdWUubGVuZ3RoICYmXG4gICAgICAgIChmcm9tU3RhcnQgPiBsYXN0VmFsdWUubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCB8fCBmcm9tRW5kIDwgcHJlZml4Lmxlbmd0aCkgJiZcbiAgICAgICAgISh1cGRhdGVkU3VmZml4UGFydCAmJiBzdWZmaXguc3RhcnRzV2l0aCh1cGRhdGVkU3VmZml4UGFydCkpKSB7XG4gICAgICAgIHZhbHVlID0gbGFzdFZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiByZW1vdmUgcHJlZml4XG4gICAgICogUmVtb3ZlIHdob2xlIHByZWZpeCBwYXJ0IGlmIGl0cyBwcmVzZW50IG9uIHRoZSB2YWx1ZVxuICAgICAqIElmIHRoZSBwcmVmaXggaXMgcGFydGlhbGx5IGRlbGV0ZWQgKGluIHdoaWNoIGNhc2UgY2hhbmdlIHN0YXJ0IGluZGV4IHdpbGwgYmUgbGVzcyB0aGUgcHJlZml4IGxlbmd0aClcbiAgICAgKiBSZW1vdmUgb25seSBwYXJ0aWFsIHBhcnQgb2YgcHJlZml4LlxuICAgICAqL1xuICAgIHZhciBzdGFydEluZGV4ID0gMDtcbiAgICBpZiAodmFsdWUuc3RhcnRzV2l0aChwcmVmaXgpKVxuICAgICAgICB7IHN0YXJ0SW5kZXggKz0gcHJlZml4Lmxlbmd0aDsgfVxuICAgIGVsc2UgaWYgKHN0YXJ0IDwgcHJlZml4Lmxlbmd0aClcbiAgICAgICAgeyBzdGFydEluZGV4ID0gc3RhcnQ7IH1cbiAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZyhzdGFydEluZGV4KTtcbiAgICAvLyBhY2NvdW50IGZvciBkZWxldGVkIHByZWZpeCBmb3IgZW5kXG4gICAgZW5kIC09IHN0YXJ0SW5kZXg7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHN1ZmZpeFxuICAgICAqIFJlbW92ZSB3aG9sZSBzdWZmaXggcGFydCBpZiBpdHMgcHJlc2VudCBvbiB0aGUgdmFsdWVcbiAgICAgKiBJZiB0aGUgc3VmZml4IGlzIHBhcnRpYWxseSBkZWxldGVkIChpbiB3aGljaCBjYXNlIGNoYW5nZSBlbmQgaW5kZXggd2lsbCBiZSBncmVhdGVyIHRoYW4gdGhlIHN1ZmZpeFN0YXJ0SW5kZXgpXG4gICAgICogcmVtb3ZlIHRoZSBwYXJ0aWFsIHBhcnQgb2Ygc3VmZml4XG4gICAgICovXG4gICAgdmFyIGVuZEluZGV4ID0gdmFsdWUubGVuZ3RoO1xuICAgIHZhciBzdWZmaXhTdGFydEluZGV4ID0gdmFsdWUubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aDtcbiAgICBpZiAodmFsdWUuZW5kc1dpdGgoc3VmZml4KSlcbiAgICAgICAgeyBlbmRJbmRleCA9IHN1ZmZpeFN0YXJ0SW5kZXg7IH1cbiAgICAvLyBpZiB0aGUgc3VmZml4IGlzIHJlbW92ZWQgZnJvbSB0aGUgZW5kXG4gICAgZWxzZSBpZiAoZW5kID4gc3VmZml4U3RhcnRJbmRleClcbiAgICAgICAgeyBlbmRJbmRleCA9IGVuZDsgfVxuICAgIC8vIGlmIHRoZSBzdWZmaXggaXMgcmVtb3ZlZCBmcm9tIHN0YXJ0XG4gICAgZWxzZSBpZiAoZW5kID4gdmFsdWUubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aClcbiAgICAgICAgeyBlbmRJbmRleCA9IGVuZDsgfVxuICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIGVuZEluZGV4KTtcbiAgICAvLyBhZGQgdGhlIG5lZ2F0aW9uIGJhY2sgYW5kIGhhbmRsZSBmb3IgZG91YmxlIG5lZ2F0aW9uXG4gICAgdmFsdWUgPSBoYW5kbGVOZWdhdGlvbihoYXNOZWdhdGlvbiA/IChcIi1cIiArIHZhbHVlKSA6IHZhbHVlLCBhbGxvd05lZ2F0aXZlKTtcbiAgICAvLyByZW1vdmUgbm9uIG51bWVyaWMgY2hhcmFjdGVyc1xuICAgIHZhbHVlID0gKHZhbHVlLm1hdGNoKGdldE51bWJlclJlZ2V4KGRlY2ltYWxTZXBhcmF0b3IsIHRydWUpKSB8fCBbXSkuam9pbignJyk7XG4gICAgLy8gcmVwbGFjZSB0aGUgZGVjaW1hbFNlcGFyYXRvciB3aXRoIC4sIGFuZCBvbmx5IGtlZXAgdGhlIGZpcnN0IHNlcGFyYXRvciwgaWdub3JlIGZvbGxvd2luZyBvbmVzXG4gICAgdmFyIGZpcnN0SW5kZXggPSB2YWx1ZS5pbmRleE9mKGRlY2ltYWxTZXBhcmF0b3IpO1xuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4cChkZWNpbWFsU2VwYXJhdG9yKSwgJ2cnKSwgZnVuY3Rpb24gKG1hdGNoLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gaW5kZXggPT09IGZpcnN0SW5kZXggPyAnLicgOiAnJztcbiAgICB9KTtcbiAgICAvL2NoZWNrIGlmIGJlZm9yZURlY2ltYWwgZ290IGRlbGV0ZWQgYW5kIHRoZXJlIGlzIG5vdGhpbmcgYWZ0ZXIgZGVjaW1hbCxcbiAgICAvL2NsZWFyIGFsbCBudW1iZXJzIGluIHN1Y2ggY2FzZSB3aGlsZSBrZWVwaW5nIHRoZSAtIHNpZ25cbiAgICB2YXIgcmVmJDIgPSBzcGxpdERlY2ltYWwodmFsdWUsIGFsbG93TmVnYXRpdmUpO1xuICAgIHZhciBiZWZvcmVEZWNpbWFsID0gcmVmJDIuYmVmb3JlRGVjaW1hbDtcbiAgICB2YXIgYWZ0ZXJEZWNpbWFsID0gcmVmJDIuYWZ0ZXJEZWNpbWFsO1xuICAgIHZhciBhZGROZWdhdGlvbiA9IHJlZiQyLmFkZE5lZ2F0aW9uOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1jb25zdFxuICAgIC8vY2xlYXIgb25seSBpZiBzb21ldGhpbmcgZ290IGRlbGV0ZWQgYmVmb3JlIGRlY2ltYWwgKGN1cnNvciBpcyBiZWZvcmUgZGVjaW1hbClcbiAgICBpZiAodG8uZW5kIC0gdG8uc3RhcnQgPCBmcm9tLmVuZCAtIGZyb20uc3RhcnQgJiZcbiAgICAgICAgYmVmb3JlRGVjaW1hbCA9PT0gJycgJiZcbiAgICAgICAgaXNCZWZvcmVEZWNpbWFsU2VwYXJhdG9yICYmXG4gICAgICAgICFwYXJzZUZsb2F0KGFmdGVyRGVjaW1hbCkpIHtcbiAgICAgICAgdmFsdWUgPSBhZGROZWdhdGlvbiA/ICctJyA6ICcnO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBnZXRDYXJldEJvdW5kYXJ5KGZvcm1hdHRlZFZhbHVlLCBwcm9wcykge1xuICAgIHZhciBwcmVmaXggPSBwcm9wcy5wcmVmaXg7IGlmICggcHJlZml4ID09PSB2b2lkIDAgKSBwcmVmaXggPSAnJztcbiAgICB2YXIgc3VmZml4ID0gcHJvcHMuc3VmZml4OyBpZiAoIHN1ZmZpeCA9PT0gdm9pZCAwICkgc3VmZml4ID0gJyc7XG4gICAgdmFyIGJvdW5kYXJ5QXJ5ID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogZm9ybWF0dGVkVmFsdWUubGVuZ3RoICsgMSB9KS5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XG4gICAgdmFyIGhhc05lZ2F0aW9uID0gZm9ybWF0dGVkVmFsdWVbMF0gPT09ICctJztcbiAgICAvLyBmaWxsIGZvciBwcmVmaXggYW5kIG5lZ2F0aW9uXG4gICAgYm91bmRhcnlBcnkuZmlsbChmYWxzZSwgMCwgcHJlZml4Lmxlbmd0aCArIChoYXNOZWdhdGlvbiA/IDEgOiAwKSk7XG4gICAgLy8gZmlsbCBmb3Igc3VmZml4XG4gICAgdmFyIHZhbExuID0gZm9ybWF0dGVkVmFsdWUubGVuZ3RoO1xuICAgIGJvdW5kYXJ5QXJ5LmZpbGwoZmFsc2UsIHZhbExuIC0gc3VmZml4Lmxlbmd0aCArIDEsIHZhbExuICsgMSk7XG4gICAgcmV0dXJuIGJvdW5kYXJ5QXJ5O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVBbmRVcGRhdGVQcm9wcyhwcm9wcykge1xuICAgIHZhciByZWYgPSBnZXRTZXBhcmF0b3JzKHByb3BzKTtcbiAgICB2YXIgdGhvdXNhbmRTZXBhcmF0b3IgPSByZWYudGhvdXNhbmRTZXBhcmF0b3I7XG4gICAgdmFyIGRlY2ltYWxTZXBhcmF0b3IgPSByZWYuZGVjaW1hbFNlcGFyYXRvcjtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgdmFyIHByZWZpeCA9IHByb3BzLnByZWZpeDsgaWYgKCBwcmVmaXggPT09IHZvaWQgMCApIHByZWZpeCA9ICcnO1xuICAgIHZhciBhbGxvd05lZ2F0aXZlID0gcHJvcHMuYWxsb3dOZWdhdGl2ZTsgaWYgKCBhbGxvd05lZ2F0aXZlID09PSB2b2lkIDAgKSBhbGxvd05lZ2F0aXZlID0gdHJ1ZTtcbiAgICBpZiAodGhvdXNhbmRTZXBhcmF0b3IgPT09IGRlY2ltYWxTZXBhcmF0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcIlxcbiAgICAgICAgRGVjaW1hbCBzZXBhcmF0b3IgY2FuJ3QgYmUgc2FtZSBhcyB0aG91c2FuZCBzZXBhcmF0b3IuXFxuICAgICAgICB0aG91c2FuZFNlcGFyYXRvcjogXCIgKyB0aG91c2FuZFNlcGFyYXRvciArIFwiICh0aG91c2FuZFNlcGFyYXRvciA9IHt0cnVlfSBpcyBzYW1lIGFzIHRob3VzYW5kU2VwYXJhdG9yID0gXFxcIixcXFwiKVxcbiAgICAgICAgZGVjaW1hbFNlcGFyYXRvcjogXCIgKyBkZWNpbWFsU2VwYXJhdG9yICsgXCIgKGRlZmF1bHQgdmFsdWUgZm9yIGRlY2ltYWxTZXBhcmF0b3IgaXMgLilcXG4gICAgIFwiKSk7XG4gICAgfVxuICAgIGlmIChwcmVmaXguc3RhcnRzV2l0aCgnLScpICYmIGFsbG93TmVnYXRpdmUpIHtcbiAgICAgICAgLy8gVE9ETzogdGhyb3cgZXJyb3IgaW4gbmV4dCBtYWpvciB2ZXJzaW9uXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoKFwiXFxuICAgICAgUHJlZml4IGNhbid0IHN0YXJ0IHdpdGggJy0nIHdoZW4gYWxsb3dOZWdhdGl2ZSBpcyB0cnVlLlxcbiAgICAgIHByZWZpeDogXCIgKyBwcmVmaXggKyBcIlxcbiAgICAgIGFsbG93TmVnYXRpdmU6IFwiICsgYWxsb3dOZWdhdGl2ZSArIFwiXFxuICAgIFwiKSk7XG4gICAgICAgIGFsbG93TmVnYXRpdmUgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpLCB7IGFsbG93TmVnYXRpdmU6IGFsbG93TmVnYXRpdmUgfSk7XG59XG5mdW5jdGlvbiB1c2VOdW1lcmljRm9ybWF0KHByb3BzKSB7XG4gICAgLy8gdmFsaWRhdGUgcHJvcHNcbiAgICBwcm9wcyA9IHZhbGlkYXRlQW5kVXBkYXRlUHJvcHMocHJvcHMpO1xuICAgIHZhciBkZWNpbWFsU2VwYXJhdG9yID0gcHJvcHMuZGVjaW1hbFNlcGFyYXRvcjsgaWYgKCBkZWNpbWFsU2VwYXJhdG9yID09PSB2b2lkIDAgKSBkZWNpbWFsU2VwYXJhdG9yID0gJy4nO1xuICAgIHZhciBhbGxvd2VkRGVjaW1hbFNlcGFyYXRvcnMgPSBwcm9wcy5hbGxvd2VkRGVjaW1hbFNlcGFyYXRvcnM7XG4gICAgdmFyIHRob3VzYW5kc0dyb3VwU3R5bGUgPSBwcm9wcy50aG91c2FuZHNHcm91cFN0eWxlO1xuICAgIHZhciBzdWZmaXggPSBwcm9wcy5zdWZmaXg7XG4gICAgdmFyIGFsbG93TmVnYXRpdmUgPSBwcm9wcy5hbGxvd05lZ2F0aXZlO1xuICAgIHZhciBhbGxvd0xlYWRpbmdaZXJvcyA9IHByb3BzLmFsbG93TGVhZGluZ1plcm9zO1xuICAgIHZhciBvbktleURvd24gPSBwcm9wcy5vbktleURvd247IGlmICggb25LZXlEb3duID09PSB2b2lkIDAgKSBvbktleURvd24gPSBub29wO1xuICAgIHZhciBvbkJsdXIgPSBwcm9wcy5vbkJsdXI7IGlmICggb25CbHVyID09PSB2b2lkIDAgKSBvbkJsdXIgPSBub29wO1xuICAgIHZhciB0aG91c2FuZFNlcGFyYXRvciA9IHByb3BzLnRob3VzYW5kU2VwYXJhdG9yO1xuICAgIHZhciBkZWNpbWFsU2NhbGUgPSBwcm9wcy5kZWNpbWFsU2NhbGU7XG4gICAgdmFyIGZpeGVkRGVjaW1hbFNjYWxlID0gcHJvcHMuZml4ZWREZWNpbWFsU2NhbGU7XG4gICAgdmFyIHByZWZpeCA9IHByb3BzLnByZWZpeDsgaWYgKCBwcmVmaXggPT09IHZvaWQgMCApIHByZWZpeCA9ICcnO1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gICAgdmFyIHZhbHVlSXNOdW1lcmljU3RyaW5nID0gcHJvcHMudmFsdWVJc051bWVyaWNTdHJpbmc7XG4gICAgdmFyIG9uVmFsdWVDaGFuZ2UgPSBwcm9wcy5vblZhbHVlQ2hhbmdlO1xuICAgIHZhciByZXN0UHJvcHMgPSBfX3Jlc3QocHJvcHMsIFtcImRlY2ltYWxTZXBhcmF0b3JcIiwgXCJhbGxvd2VkRGVjaW1hbFNlcGFyYXRvcnNcIiwgXCJ0aG91c2FuZHNHcm91cFN0eWxlXCIsIFwic3VmZml4XCIsIFwiYWxsb3dOZWdhdGl2ZVwiLCBcImFsbG93TGVhZGluZ1plcm9zXCIsIFwib25LZXlEb3duXCIsIFwib25CbHVyXCIsIFwidGhvdXNhbmRTZXBhcmF0b3JcIiwgXCJkZWNpbWFsU2NhbGVcIiwgXCJmaXhlZERlY2ltYWxTY2FsZVwiLCBcInByZWZpeFwiLCBcImRlZmF1bHRWYWx1ZVwiLCBcInZhbHVlXCIsIFwidmFsdWVJc051bWVyaWNTdHJpbmdcIiwgXCJvblZhbHVlQ2hhbmdlXCJdKTtcbiAgICB2YXIgX2Zvcm1hdCA9IGZ1bmN0aW9uIChudW1TdHIpIHsgcmV0dXJuIGZvcm1hdChudW1TdHIsIHByb3BzKTsgfTtcbiAgICB2YXIgX3JlbW92ZUZvcm1hdHRpbmcgPSBmdW5jdGlvbiAoaW5wdXRWYWx1ZSwgY2hhbmdlTWV0YSkgeyByZXR1cm4gcmVtb3ZlRm9ybWF0dGluZyhpbnB1dFZhbHVlLCBjaGFuZ2VNZXRhLCBwcm9wcyk7IH07XG4gICAgdmFyIF92YWx1ZUlzTnVtZXJpY1N0cmluZyA9IHZhbHVlSXNOdW1lcmljU3RyaW5nO1xuICAgIGlmICghaXNOaWwodmFsdWUpKSB7XG4gICAgICAgIF92YWx1ZUlzTnVtZXJpY1N0cmluZyA9IHZhbHVlSXNOdW1lcmljU3RyaW5nICE9PSBudWxsICYmIHZhbHVlSXNOdW1lcmljU3RyaW5nICE9PSB2b2lkIDAgPyB2YWx1ZUlzTnVtZXJpY1N0cmluZyA6IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc05pbChkZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgIF92YWx1ZUlzTnVtZXJpY1N0cmluZyA9IHZhbHVlSXNOdW1lcmljU3RyaW5nICE9PSBudWxsICYmIHZhbHVlSXNOdW1lcmljU3RyaW5nICE9PSB2b2lkIDAgPyB2YWx1ZUlzTnVtZXJpY1N0cmluZyA6IHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09ICdudW1iZXInO1xuICAgIH1cbiAgICB2YXIgcm91bmRJbmNvbWluZ1ZhbHVlVG9QcmVjaXNpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKGlzTmlsKHZhbHVlKSB8fCBpc05hblZhbHVlKHZhbHVlKSlcbiAgICAgICAgICAgIHsgcmV0dXJuIHZhbHVlOyB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRvTnVtZXJpY1N0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG9ubHkgcm91bmQgbnVtZXJpYyBvciBmbG9hdCBzdHJpbmcgdmFsdWVzIGNvbWluZyB0aHJvdWdoIHByb3BzLFxuICAgICAgICAgKiB3ZSBkb24ndCBuZWVkIHRvIGRvIGl0IGZvciBvbkNoYW5nZSBldmVudHMsIGFzIHdlIHdhbnQgdG8gcHJldmVudCB0eXBpbmcgdGhlcmVcbiAgICAgICAgICovXG4gICAgICAgIGlmIChfdmFsdWVJc051bWVyaWNTdHJpbmcgJiYgdHlwZW9mIGRlY2ltYWxTY2FsZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiByb3VuZFRvUHJlY2lzaW9uKHZhbHVlLCBkZWNpbWFsU2NhbGUsIEJvb2xlYW4oZml4ZWREZWNpbWFsU2NhbGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICB2YXIgcmVmID0gdXNlSW50ZXJuYWxWYWx1ZXMocm91bmRJbmNvbWluZ1ZhbHVlVG9QcmVjaXNpb24odmFsdWUpLCByb3VuZEluY29taW5nVmFsdWVUb1ByZWNpc2lvbihkZWZhdWx0VmFsdWUpLCBCb29sZWFuKF92YWx1ZUlzTnVtZXJpY1N0cmluZyksIF9mb3JtYXQsIF9yZW1vdmVGb3JtYXR0aW5nLCBvblZhbHVlQ2hhbmdlKTtcbiAgICB2YXIgcmVmXzAgPSByZWZbMF07XG4gICAgdmFyIG51bUFzU3RyaW5nID0gcmVmXzAubnVtQXNTdHJpbmc7XG4gICAgdmFyIGZvcm1hdHRlZFZhbHVlID0gcmVmXzAuZm9ybWF0dGVkVmFsdWU7XG4gICAgdmFyIF9vblZhbHVlQ2hhbmdlID0gcmVmWzFdO1xuICAgIHZhciBfb25LZXlEb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGVsID0gZS50YXJnZXQ7XG4gICAgICAgIHZhciBrZXkgPSBlLmtleTtcbiAgICAgICAgdmFyIHNlbGVjdGlvblN0YXJ0ID0gZWwuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIHZhciBzZWxlY3Rpb25FbmQgPSBlbC5zZWxlY3Rpb25FbmQ7XG4gICAgICAgIHZhciB2YWx1ZSA9IGVsLnZhbHVlOyBpZiAoIHZhbHVlID09PSB2b2lkIDAgKSB2YWx1ZSA9ICcnO1xuICAgICAgICAvLyBpZiBtdWx0aXBsZSBjaGFyYWN0ZXJzIGFyZSBzZWxlY3RlZCBhbmQgdXNlciBoaXRzIGJhY2tzcGFjZSwgbm8gbmVlZCB0byBoYW5kbGUgYW55dGhpbmcgbWFudWFsbHlcbiAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ICE9PSBzZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgIG9uS2V5RG93bihlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB1c2VyIGhpdHMgYmFja3NwYWNlLCB3aGlsZSB0aGUgY3Vyc29yIGlzIGJlZm9yZSBwcmVmaXgsIGFuZCB0aGUgaW5wdXQgaGFzIG5lZ2F0aW9uLCByZW1vdmUgdGhlIG5lZ2F0aW9uXG4gICAgICAgIGlmIChrZXkgPT09ICdCYWNrc3BhY2UnICYmXG4gICAgICAgICAgICB2YWx1ZVswXSA9PT0gJy0nICYmXG4gICAgICAgICAgICBzZWxlY3Rpb25TdGFydCA9PT0gcHJlZml4Lmxlbmd0aCArIDEgJiZcbiAgICAgICAgICAgIGFsbG93TmVnYXRpdmUpIHtcbiAgICAgICAgICAgIC8vIGJyaW5nIHRoZSBjdXJzb3IgdG8gYWZ0ZXIgbmVnYXRpb25cbiAgICAgICAgICAgIHNldENhcmV0UG9zaXRpb24oZWwsIDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvbid0IGFsbG93IHVzZXIgdG8gZGVsZXRlIGRlY2ltYWwgc2VwYXJhdG9yIHdoZW4gZGVjaW1hbFNjYWxlIGFuZCBmaXhlZERlY2ltYWxTY2FsZSBpcyBzZXRcbiAgICAgICAgdmFyIHJlZiA9IGdldFNlcGFyYXRvcnMocHJvcHMpO1xuICAgICAgICB2YXIgZGVjaW1hbFNlcGFyYXRvciA9IHJlZi5kZWNpbWFsU2VwYXJhdG9yO1xuICAgICAgICB2YXIgYWxsb3dlZERlY2ltYWxTZXBhcmF0b3JzID0gcmVmLmFsbG93ZWREZWNpbWFsU2VwYXJhdG9ycztcbiAgICAgICAgaWYgKGtleSA9PT0gJ0JhY2tzcGFjZScgJiZcbiAgICAgICAgICAgIHZhbHVlW3NlbGVjdGlvblN0YXJ0IC0gMV0gPT09IGRlY2ltYWxTZXBhcmF0b3IgJiZcbiAgICAgICAgICAgIGRlY2ltYWxTY2FsZSAmJlxuICAgICAgICAgICAgZml4ZWREZWNpbWFsU2NhbGUpIHtcbiAgICAgICAgICAgIHNldENhcmV0UG9zaXRpb24oZWwsIHNlbGVjdGlvblN0YXJ0IC0gMSk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdXNlciBwcmVzc2VzIHRoZSBhbGxvd2VkIGRlY2ltYWwgc2VwYXJhdG9yIGJlZm9yZSB0aGUgc2VwYXJhdG9yLCBtb3ZlIHRoZSBjdXJzb3IgYWZ0ZXIgdGhlIHNlcGFyYXRvclxuICAgICAgICBpZiAoKGFsbG93ZWREZWNpbWFsU2VwYXJhdG9ycyA9PT0gbnVsbCB8fCBhbGxvd2VkRGVjaW1hbFNlcGFyYXRvcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFsbG93ZWREZWNpbWFsU2VwYXJhdG9ycy5pbmNsdWRlcyhrZXkpKSAmJiB2YWx1ZVtzZWxlY3Rpb25TdGFydF0gPT09IGRlY2ltYWxTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHNldENhcmV0UG9zaXRpb24oZWwsIHNlbGVjdGlvblN0YXJ0ICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF90aG91c2FuZFNlcGFyYXRvciA9IHRob3VzYW5kU2VwYXJhdG9yID09PSB0cnVlID8gJywnIDogdGhvdXNhbmRTZXBhcmF0b3I7XG4gICAgICAgIC8vIG1vdmUgY3Vyc29yIHdoZW4gZGVsZXRlIG9yIGJhY2tzcGFjZSBpcyBwcmVzc2VkIGJlZm9yZS9hZnRlciB0aG91c2FuZCBzZXBhcmF0b3JcbiAgICAgICAgaWYgKGtleSA9PT0gJ0JhY2tzcGFjZScgJiYgdmFsdWVbc2VsZWN0aW9uU3RhcnQgLSAxXSA9PT0gX3Rob3VzYW5kU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICBzZXRDYXJldFBvc2l0aW9uKGVsLCBzZWxlY3Rpb25TdGFydCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT09ICdEZWxldGUnICYmIHZhbHVlW3NlbGVjdGlvblN0YXJ0XSA9PT0gX3Rob3VzYW5kU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICBzZXRDYXJldFBvc2l0aW9uKGVsLCBzZWxlY3Rpb25TdGFydCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIG9uS2V5RG93bihlKTtcbiAgICB9O1xuICAgIHZhciBfb25CbHVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF92YWx1ZSA9IG51bUFzU3RyaW5nO1xuICAgICAgICAvLyBpZiB0aGVyZSBubyBubyBudW1lcmljIHZhbHVlLCBjbGVhciB0aGUgaW5wdXRcbiAgICAgICAgaWYgKCFfdmFsdWUubWF0Y2goL1xcZC9nKSkge1xuICAgICAgICAgICAgX3ZhbHVlID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2xlYXIgbGVhZGluZyAwc1xuICAgICAgICBpZiAoIWFsbG93TGVhZGluZ1plcm9zKSB7XG4gICAgICAgICAgICBfdmFsdWUgPSBmaXhMZWFkaW5nWmVybyhfdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFwcGx5IGZpeGVkRGVjaW1hbFNjYWxlIG9uIGJsdXIgZXZlbnRcbiAgICAgICAgaWYgKGZpeGVkRGVjaW1hbFNjYWxlICYmIGRlY2ltYWxTY2FsZSkge1xuICAgICAgICAgICAgX3ZhbHVlID0gcm91bmRUb1ByZWNpc2lvbihfdmFsdWUsIGRlY2ltYWxTY2FsZSwgZml4ZWREZWNpbWFsU2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdmFsdWUgIT09IG51bUFzU3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVkVmFsdWUgPSBmb3JtYXQoX3ZhbHVlLCBwcm9wcyk7XG4gICAgICAgICAgICBfb25WYWx1ZUNoYW5nZSh7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWU6IGZvcm1hdHRlZFZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBfdmFsdWUsXG4gICAgICAgICAgICAgICAgZmxvYXRWYWx1ZTogcGFyc2VGbG9hdChfdmFsdWUpLFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGV2ZW50OiBlLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogU291cmNlVHlwZS5ldmVudCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG9uQmx1cihlKTtcbiAgICB9O1xuICAgIHZhciBpc1ZhbGlkSW5wdXRDaGFyYWN0ZXIgPSBmdW5jdGlvbiAoaW5wdXRDaGFyKSB7XG4gICAgICAgIGlmIChpbnB1dENoYXIgPT09IGRlY2ltYWxTZXBhcmF0b3IpXG4gICAgICAgICAgICB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgIHJldHVybiBjaGFySXNOdW1iZXIoaW5wdXRDaGFyKTtcbiAgICB9O1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3RQcm9wcyksIHsgdmFsdWU6IGZvcm1hdHRlZFZhbHVlLCB2YWx1ZUlzTnVtZXJpY1N0cmluZzogZmFsc2UsIGlzVmFsaWRJbnB1dENoYXJhY3RlcjogaXNWYWxpZElucHV0Q2hhcmFjdGVyLCBvblZhbHVlQ2hhbmdlOiBfb25WYWx1ZUNoYW5nZSwgZm9ybWF0OiBfZm9ybWF0LCByZW1vdmVGb3JtYXR0aW5nOiBfcmVtb3ZlRm9ybWF0dGluZywgZ2V0Q2FyZXRCb3VuZGFyeTogZnVuY3Rpb24gKGZvcm1hdHRlZFZhbHVlKSB7IHJldHVybiBnZXRDYXJldEJvdW5kYXJ5KGZvcm1hdHRlZFZhbHVlLCBwcm9wcyk7IH0sIG9uS2V5RG93bjogX29uS2V5RG93biwgb25CbHVyOiBfb25CbHVyIH0pO1xufVxuZnVuY3Rpb24gTnVtZXJpY0Zvcm1hdChwcm9wcykge1xuICAgIHZhciBudW1lcmljRm9ybWF0UHJvcHMgPSB1c2VOdW1lcmljRm9ybWF0KHByb3BzKTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChOdW1iZXJGb3JtYXRCYXNlLCBPYmplY3QuYXNzaWduKHt9LCBudW1lcmljRm9ybWF0UHJvcHMpKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0JDEobnVtU3RyLCBwcm9wcykge1xuICAgIHZhciBmb3JtYXQgPSBwcm9wcy5mb3JtYXQ7XG4gICAgdmFyIGFsbG93RW1wdHlGb3JtYXR0aW5nID0gcHJvcHMuYWxsb3dFbXB0eUZvcm1hdHRpbmc7XG4gICAgdmFyIG1hc2sgPSBwcm9wcy5tYXNrO1xuICAgIHZhciBwYXR0ZXJuQ2hhciA9IHByb3BzLnBhdHRlcm5DaGFyOyBpZiAoIHBhdHRlcm5DaGFyID09PSB2b2lkIDAgKSBwYXR0ZXJuQ2hhciA9ICcjJztcbiAgICBpZiAobnVtU3RyID09PSAnJyAmJiAhYWxsb3dFbXB0eUZvcm1hdHRpbmcpXG4gICAgICAgIHsgcmV0dXJuICcnOyB9XG4gICAgdmFyIGhhc2hDb3VudCA9IDA7XG4gICAgdmFyIGZvcm1hdHRlZE51bWJlckFyeSA9IGZvcm1hdC5zcGxpdCgnJyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxuID0gZm9ybWF0Lmxlbmd0aDsgaSA8IGxuOyBpKyspIHtcbiAgICAgICAgaWYgKGZvcm1hdFtpXSA9PT0gcGF0dGVybkNoYXIpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZE51bWJlckFyeVtpXSA9IG51bVN0cltoYXNoQ291bnRdIHx8IGdldE1hc2tBdEluZGV4KG1hc2ssIGhhc2hDb3VudCk7XG4gICAgICAgICAgICBoYXNoQ291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0dGVkTnVtYmVyQXJ5LmpvaW4oJycpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZyQxKHZhbHVlLCBjaGFuZ2VNZXRhLCBwcm9wcykge1xuICAgIGlmICggY2hhbmdlTWV0YSA9PT0gdm9pZCAwICkgY2hhbmdlTWV0YSA9IGdldERlZmF1bHRDaGFuZ2VNZXRhKHZhbHVlKTtcblxuICAgIHZhciBmb3JtYXQgPSBwcm9wcy5mb3JtYXQ7XG4gICAgdmFyIHBhdHRlcm5DaGFyID0gcHJvcHMucGF0dGVybkNoYXI7IGlmICggcGF0dGVybkNoYXIgPT09IHZvaWQgMCApIHBhdHRlcm5DaGFyID0gJyMnO1xuICAgIHZhciBmcm9tID0gY2hhbmdlTWV0YS5mcm9tO1xuICAgIHZhciB0byA9IGNoYW5nZU1ldGEudG87XG4gICAgdmFyIGxhc3RWYWx1ZSA9IGNoYW5nZU1ldGEubGFzdFZhbHVlOyBpZiAoIGxhc3RWYWx1ZSA9PT0gdm9pZCAwICkgbGFzdFZhbHVlID0gJyc7XG4gICAgdmFyIGlzTnVtZXJpY1Nsb3QgPSBmdW5jdGlvbiAoY2FyZXRQb3MpIHsgcmV0dXJuIGZvcm1hdFtjYXJldFBvc10gPT09IHBhdHRlcm5DaGFyOyB9O1xuICAgIHZhciByZW1vdmVGb3JtYXRDaGFyID0gZnVuY3Rpb24gKHN0cmluZywgc3RhcnRJbmRleCkge1xuICAgICAgICB2YXIgc3RyID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXNOdW1lcmljU2xvdChzdGFydEluZGV4ICsgaSkgJiYgY2hhcklzTnVtYmVyKHN0cmluZ1tpXSkpIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gc3RyaW5nW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcbiAgICB2YXIgZXh0cmFjdE51bWJlcnMgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHIucmVwbGFjZSgvW14wLTldL2csICcnKTsgfTtcbiAgICAvLyBpZiBmb3JtYXQgZG9lc24ndCBoYXZlIGFueSBudW1iZXIsIHJlbW92ZSBhbGwgdGhlIG5vbiBudW1lcmljIGNoYXJhY3RlcnNcbiAgICBpZiAoIWZvcm1hdC5tYXRjaCgvXFxkLykpIHtcbiAgICAgICAgcmV0dXJuIGV4dHJhY3ROdW1iZXJzKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogaWYgdXNlciBwYXN0ZSB0aGUgd2hvbGUgZm9ybWF0dGVkIHRleHQgaW4gYW4gZW1wdHkgaW5wdXQsIGNoZWNrIGlmIG1hdGNoZXMgdG8gdGhlIHBhdHRlcm5cbiAgICAgKiBhbmQgcmVtb3ZlIHRoZSBmb3JtYXQgY2hhcmFjdGVycywgaWYgdGhlcmUgaXMgYSBtaXNtYXRjaCBvbiB0aGUgcGF0dGVybiwgZG8gcGxhbmUgbnVtYmVyIGV4dHJhY3RcbiAgICAgKi9cbiAgICBpZiAobGFzdFZhbHVlID09PSAnJyAmJiB2YWx1ZS5sZW5ndGggPT09IGZvcm1hdC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHN0ciA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXNOdW1lcmljU2xvdChpKSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGFySXNOdW1iZXIodmFsdWVbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSB2YWx1ZVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZVtpXSAhPT0gZm9ybWF0W2ldKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBtaXNtYXRjaCBvbiB0aGUgcGF0dGVybiwgZG8gcGxhbmUgbnVtYmVyIGV4dHJhY3RcbiAgICAgICAgICAgICAgICByZXR1cm4gZXh0cmFjdE51bWJlcnModmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciBwYXJ0aWFsIGNoYW5nZSxcbiAgICAgKiB3aGVyZSBldmVyIHRoZXJlIGlzIGEgY2hhbmdlIG9uIHRoZSBpbnB1dCwgd2UgY2FuIGJyZWFrIHRoZSBudW1iZXIgaW4gdGhyZWUgcGFydHNcbiAgICAgKiAxc3Q6IGxlZnQgcGFydCB3aGljaCBpcyB1bmNoYW5nZWRcbiAgICAgKiAybmQ6IG1pZGRsZSBwYXJ0IHdoaWNoIGlzIGNoYW5nZWRcbiAgICAgKiAzcmQ6IHJpZ2h0IHBhcnQgd2hpY2ggaXMgdW5jaGFuZ2VkXG4gICAgICpcbiAgICAgKiBUaGUgZmlyc3QgYW5kIHRoaXJkIHNlY3Rpb24gd2lsbCBiZSBzYW1lIGFzIGxhc3QgdmFsdWUsIG9ubHkgdGhlIG1pZGRsZSBwYXJ0IHdpbGwgY2hhbmdlXG4gICAgICogV2UgY2FuIGNvbnNpZGVyIG9uIHRoZSBjaGFuZ2UgcGFydCBhbGwgdGhlIG5ldyBjaGFyYWN0ZXJzIGFyZSBub24gZm9ybWF0IGNoYXJhY3RlcnMuXG4gICAgICogQW5kIG9uIHRoZSBmaXJzdCBhbmQgbGFzdCBzZWN0aW9uIGl0IGNhbiBoYXZlIHBhcnRpYWwgZm9ybWF0IGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiBXZSBwaWNrIGZpcnN0IGFuZCBsYXN0IHNlY3Rpb24gZnJvbSB0aGUgbGFzdFZhbHVlIChhcyB0aGF0IGhhcyAxLTEgbWFwcGluZyB3aXRoIGZvcm1hdClcbiAgICAgKiBhbmQgbWlkZGxlIG9uZSBmcm9tIHRoZSB1cGRhdGUgdmFsdWUuXG4gICAgICovXG4gICAgdmFyIGZpcnN0U2VjdGlvbiA9IGxhc3RWYWx1ZS5zdWJzdHJpbmcoMCwgZnJvbS5zdGFydCk7XG4gICAgdmFyIG1pZGRsZVNlY3Rpb24gPSB2YWx1ZS5zdWJzdHJpbmcodG8uc3RhcnQsIHRvLmVuZCk7XG4gICAgdmFyIGxhc3RTZWN0aW9uID0gbGFzdFZhbHVlLnN1YnN0cmluZyhmcm9tLmVuZCk7XG4gICAgcmV0dXJuIChcIlwiICsgKHJlbW92ZUZvcm1hdENoYXIoZmlyc3RTZWN0aW9uLCAwKSkgKyAoZXh0cmFjdE51bWJlcnMobWlkZGxlU2VjdGlvbikpICsgKHJlbW92ZUZvcm1hdENoYXIobGFzdFNlY3Rpb24sIGZyb20uZW5kKSkpO1xufVxuZnVuY3Rpb24gZ2V0Q2FyZXRCb3VuZGFyeSQxKGZvcm1hdHRlZFZhbHVlLCBwcm9wcykge1xuICAgIHZhciBmb3JtYXQgPSBwcm9wcy5mb3JtYXQ7XG4gICAgdmFyIG1hc2sgPSBwcm9wcy5tYXNrO1xuICAgIHZhciBwYXR0ZXJuQ2hhciA9IHByb3BzLnBhdHRlcm5DaGFyOyBpZiAoIHBhdHRlcm5DaGFyID09PSB2b2lkIDAgKSBwYXR0ZXJuQ2hhciA9ICcjJztcbiAgICB2YXIgYm91bmRhcnlBcnkgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBmb3JtYXR0ZWRWYWx1ZS5sZW5ndGggKyAxIH0pLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9KTtcbiAgICB2YXIgaGFzaENvdW50ID0gMDtcbiAgICB2YXIgZmlyc3RFbXB0eVNsb3QgPSAtMTtcbiAgICB2YXIgbWFza0FuZEluZGV4TWFwID0ge307XG4gICAgZm9ybWF0LnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFyLCBpbmRleCkge1xuICAgICAgICB2YXIgbWFza0F0SW5kZXggPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChjaGFyID09PSBwYXR0ZXJuQ2hhcikge1xuICAgICAgICAgICAgaGFzaENvdW50Kys7XG4gICAgICAgICAgICBtYXNrQXRJbmRleCA9IGdldE1hc2tBdEluZGV4KG1hc2ssIGhhc2hDb3VudCAtIDEpO1xuICAgICAgICAgICAgaWYgKGZpcnN0RW1wdHlTbG90ID09PSAtMSAmJiBmb3JtYXR0ZWRWYWx1ZVtpbmRleF0gPT09IG1hc2tBdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgZmlyc3RFbXB0eVNsb3QgPSBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYXNrQW5kSW5kZXhNYXBbaW5kZXhdID0gbWFza0F0SW5kZXg7XG4gICAgfSk7XG4gICAgdmFyIGlzUG9zQWxsb3dlZCA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgLy8gdGhlIHBvc2l0aW9uIGlzIGFsbG93ZWQgaWYgdGhlIHBvc2l0aW9uIGlzIG5vdCBtYXNrZWQgYW5kIHZhbGlkIG51bWJlciBhcmVhXG4gICAgICAgIHJldHVybiBmb3JtYXRbcG9zXSA9PT0gcGF0dGVybkNoYXIgJiYgZm9ybWF0dGVkVmFsdWVbcG9zXSAhPT0gbWFza0FuZEluZGV4TWFwW3Bvc107XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMCwgbG4gPSBib3VuZGFyeUFyeS5sZW5ndGg7IGkgPCBsbjsgaSsrKSB7XG4gICAgICAgIC8vIGNvbnNpZGVyIGNhcmV0IHRvIGJlIGluIGJvdW5kYXJ5IGlmIGl0IGlzIGJlZm9yZSBvciBhZnRlciBudW1lcmljIHZhbHVlXG4gICAgICAgIC8vIE5vdGU6IG9uIHBhdHRlcm4gYmFzZWQgZm9ybWF0IGl0cyBkZW5vdGVkIGJ5IHBhdHRlcm5DaGFyYWN0ZXJcbiAgICAgICAgLy8gd2Ugc2hvdWxkIGFsc28gYWxsb3cgdXNlciB0byBwdXQgY3Vyc29yIG9uIGZpcnN0IGVtcHR5IHNsb3RcbiAgICAgICAgYm91bmRhcnlBcnlbaV0gPSBpID09PSBmaXJzdEVtcHR5U2xvdCB8fCBpc1Bvc0FsbG93ZWQoaSkgfHwgaXNQb3NBbGxvd2VkKGkgLSAxKTtcbiAgICB9XG4gICAgLy8gdGhlIGZpcnN0IHBhdHRlcm5DaGFyIHBvc2l0aW9uIGlzIGFsd2F5cyBhbGxvd2VkXG4gICAgYm91bmRhcnlBcnlbZm9ybWF0LmluZGV4T2YocGF0dGVybkNoYXIpXSA9IHRydWU7XG4gICAgcmV0dXJuIGJvdW5kYXJ5QXJ5O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhwcm9wcykge1xuICAgIHZhciBtYXNrID0gcHJvcHMubWFzaztcbiAgICBpZiAobWFzaykge1xuICAgICAgICB2YXIgbWFza0FzU3RyID0gbWFzayA9PT0gJ3N0cmluZycgPyBtYXNrIDogbWFzay50b1N0cmluZygpO1xuICAgICAgICBpZiAobWFza0FzU3RyLm1hdGNoKC9cXGQvZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoXCJNYXNrIFwiICsgbWFzayArIFwiIHNob3VsZCBub3QgY29udGFpbiBudW1lcmljIGNoYXJhY3RlcjtcIikpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdXNlUGF0dGVybkZvcm1hdChwcm9wcykge1xuICAgIHZhciBtYXNrID0gcHJvcHMubWFzaztcbiAgICB2YXIgYWxsb3dFbXB0eUZvcm1hdHRpbmcgPSBwcm9wcy5hbGxvd0VtcHR5Rm9ybWF0dGluZztcbiAgICB2YXIgZm9ybWF0UHJvcCA9IHByb3BzLmZvcm1hdDtcbiAgICB2YXIgaW5wdXRNb2RlID0gcHJvcHMuaW5wdXRNb2RlOyBpZiAoIGlucHV0TW9kZSA9PT0gdm9pZCAwICkgaW5wdXRNb2RlID0gJ251bWVyaWMnO1xuICAgIHZhciBvbktleURvd24gPSBwcm9wcy5vbktleURvd247IGlmICggb25LZXlEb3duID09PSB2b2lkIDAgKSBvbktleURvd24gPSBub29wO1xuICAgIHZhciBwYXR0ZXJuQ2hhciA9IHByb3BzLnBhdHRlcm5DaGFyOyBpZiAoIHBhdHRlcm5DaGFyID09PSB2b2lkIDAgKSBwYXR0ZXJuQ2hhciA9ICcjJztcbiAgICB2YXIgcmVzdFByb3BzID0gX19yZXN0KHByb3BzLCBbXCJtYXNrXCIsIFwiYWxsb3dFbXB0eUZvcm1hdHRpbmdcIiwgXCJmb3JtYXRcIiwgXCJpbnB1dE1vZGVcIiwgXCJvbktleURvd25cIiwgXCJwYXR0ZXJuQ2hhclwiXSk7XG4gICAgLy8gdmFsaWRhdGUgcHJvcHNcbiAgICB2YWxpZGF0ZVByb3BzKHByb3BzKTtcbiAgICB2YXIgX2dldENhcmV0Qm91bmRhcnkgPSBmdW5jdGlvbiAoZm9ybWF0dGVkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGdldENhcmV0Qm91bmRhcnkkMShmb3JtYXR0ZWRWYWx1ZSwgcHJvcHMpO1xuICAgIH07XG4gICAgdmFyIF9vbktleURvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIga2V5ID0gZS5rZXk7XG4gICAgICAgIHZhciBlbCA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgc2VsZWN0aW9uU3RhcnQgPSBlbC5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkVuZCA9IGVsLnNlbGVjdGlvbkVuZDtcbiAgICAgICAgdmFyIHZhbHVlID0gZWwudmFsdWU7XG4gICAgICAgIC8vIGlmIG11bHRpcGxlIGNoYXJhY3RlcnMgYXJlIHNlbGVjdGVkIGFuZCB1c2VyIGhpdHMgYmFja3NwYWNlLCBubyBuZWVkIHRvIGhhbmRsZSBhbnl0aGluZyBtYW51YWxseVxuICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgIT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgb25LZXlEb3duKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJyaW5nIHRoZSBjdXJzb3IgdG8gY2xvc2VzdCBudW1lcmljIHNlY3Rpb25cbiAgICAgICAgdmFyIGNhcmV0UG9zID0gc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIC8vIGlmIGJhY2tzcGFjZSBpcyBwcmVzc2VkIGFmdGVyIHRoZSBmb3JtYXQgY2hhcmFjdGVycywgYnJpbmcgaXQgdG8gbnVtZXJpYyBzZWN0aW9uXG4gICAgICAgIC8vIGlmIGRlbGV0ZSBpcyBwcmVzc2VkIGJlZm9yZSB0aGUgZm9ybWF0IGNoYXJhY3RlcnMsIGJyaW5nIGl0IHRvIG51bWVyaWMgc2VjdGlvblxuICAgICAgICBpZiAoa2V5ID09PSAnQmFja3NwYWNlJyB8fCBrZXkgPT09ICdEZWxldGUnKSB7XG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdCYWNrc3BhY2UnKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNhcmV0UG9zID4gMCAmJiBmb3JtYXRQcm9wW2NhcmV0UG9zIC0gMV0gIT09IHBhdHRlcm5DaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICdsZWZ0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBmb3JtYXRMbiA9IGZvcm1hdFByb3AubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjYXJldFBvcyA8IGZvcm1hdExuICYmIGZvcm1hdFByb3BbY2FyZXRQb3NdICE9PSBwYXR0ZXJuQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICBjYXJldFBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAncmlnaHQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FyZXRQb3MgPSBnZXRDYXJldFBvc0luQm91bmRhcnkodmFsdWUsIGNhcmV0UG9zLCBfZ2V0Q2FyZXRCb3VuZGFyeSh2YWx1ZSksIGRpcmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZm9ybWF0UHJvcFtjYXJldFBvc10gIT09IHBhdHRlcm5DaGFyICYmXG4gICAgICAgICAgICBrZXkgIT09ICdBcnJvd0xlZnQnICYmXG4gICAgICAgICAgICBrZXkgIT09ICdBcnJvd1JpZ2h0Jykge1xuICAgICAgICAgICAgLy8gaWYgdXNlciBpcyB0eXBpbmcgb24gZm9ybWF0IGNoYXJhY3RlciBwb3NpdGlvbiwgYnJpbmcgdXNlciB0byBuZXh0IGFsbG93ZWQgY2FyZXQgcG9zaXRpb25cbiAgICAgICAgICAgIGNhcmV0UG9zID0gZ2V0Q2FyZXRQb3NJbkJvdW5kYXJ5KHZhbHVlLCBjYXJldFBvcyArIDEsIF9nZXRDYXJldEJvdW5kYXJ5KHZhbHVlKSwgJ3JpZ2h0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgY2hhbmdpbmcgY2FyZXQgcG9zaXRpb24sIHNldCB0aGUgY2FyZXQgcG9zaXRpb25cbiAgICAgICAgaWYgKGNhcmV0UG9zICE9PSBzZWxlY3Rpb25TdGFydCkge1xuICAgICAgICAgICAgc2V0Q2FyZXRQb3NpdGlvbihlbCwgY2FyZXRQb3MpO1xuICAgICAgICB9XG4gICAgICAgIG9uS2V5RG93bihlKTtcbiAgICB9O1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3RQcm9wcyksIHsgaW5wdXRNb2RlOiBpbnB1dE1vZGUsIGZvcm1hdDogZnVuY3Rpb24gKG51bVN0cikgeyByZXR1cm4gZm9ybWF0JDEobnVtU3RyLCBwcm9wcyk7IH0sIHJlbW92ZUZvcm1hdHRpbmc6IGZ1bmN0aW9uIChpbnB1dFZhbHVlLCBjaGFuZ2VNZXRhKSB7IHJldHVybiByZW1vdmVGb3JtYXR0aW5nJDEoaW5wdXRWYWx1ZSwgY2hhbmdlTWV0YSwgcHJvcHMpOyB9LCBnZXRDYXJldEJvdW5kYXJ5OiBfZ2V0Q2FyZXRCb3VuZGFyeSwgb25LZXlEb3duOiBfb25LZXlEb3duIH0pO1xufVxuZnVuY3Rpb24gUGF0dGVybkZvcm1hdChwcm9wcykge1xuICAgIHZhciBwYXR0ZXJuRm9ybWF0UHJvcHMgPSB1c2VQYXR0ZXJuRm9ybWF0KHByb3BzKTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChOdW1iZXJGb3JtYXRCYXNlLCBPYmplY3QuYXNzaWduKHt9LCBwYXR0ZXJuRm9ybWF0UHJvcHMpKTtcbn1cblxuZXhwb3J0IHsgTnVtYmVyRm9ybWF0QmFzZSwgTnVtZXJpY0Zvcm1hdCwgUGF0dGVybkZvcm1hdCwgZ2V0Q2FyZXRCb3VuZGFyeSBhcyBnZXROdW1lcmljQ2FyZXRCb3VuZGFyeSwgZ2V0Q2FyZXRCb3VuZGFyeSQxIGFzIGdldFBhdHRlcm5DYXJldEJvdW5kYXJ5LCBmb3JtYXQgYXMgbnVtZXJpY0Zvcm1hdHRlciwgZm9ybWF0JDEgYXMgcGF0dGVybkZvcm1hdHRlciwgcmVtb3ZlRm9ybWF0dGluZyBhcyByZW1vdmVOdW1lcmljRm9ybWF0LCByZW1vdmVGb3JtYXR0aW5nJDEgYXMgcmVtb3ZlUGF0dGVybkZvcm1hdCwgdXNlTnVtZXJpY0Zvcm1hdCwgdXNlUGF0dGVybkZvcm1hdCB9O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VNZW1vIiwidXNlRWZmZWN0IiwiX19yZXN0IiwicyIsImUiLCJ0IiwicCIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImluZGV4T2YiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJpIiwibGVuZ3RoIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJTb3VyY2VUeXBlIiwibm9vcCIsImNoYXJJc051bWJlciIsImNoYXIiLCJtYXRjaCIsImlzTmlsIiwidmFsIiwidW5kZWZpbmVkIiwiaXNOYW5WYWx1ZSIsImlzTmFOIiwiZXNjYXBlUmVnRXhwIiwic3RyIiwicmVwbGFjZSIsImdldFRob3VzYW5kc0dyb3VwUmVnZXgiLCJ0aG91c2FuZHNHcm91cFN0eWxlIiwiYXBwbHlUaG91c2FuZFNlcGFyYXRvciIsInRob3VzYW5kU2VwYXJhdG9yIiwidGhvdXNhbmRzR3JvdXBSZWdleCIsImluZGV4Iiwic2VhcmNoIiwic3Vic3RyaW5nIiwidXNlUGVyc2lzdGVudENhbGxiYWNrIiwiY2IiLCJjYWxsYmFja1JlZiIsImN1cnJlbnQiLCJwZXJzaXN0ZW50Q2JSZWYiLCJhcmdzIiwibGVuIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJzcGxpdERlY2ltYWwiLCJudW1TdHIiLCJhbGxvd05lZ2F0aXZlIiwiaGFzTmVnYXRpb24iLCJhZGROZWdhdGlvbiIsInBhcnRzIiwic3BsaXQiLCJiZWZvcmVEZWNpbWFsIiwiYWZ0ZXJEZWNpbWFsIiwiZml4TGVhZGluZ1plcm8iLCJpc05lZ2F0aXZlIiwibGltaXRUb1NjYWxlIiwic2NhbGUiLCJmaXhlZERlY2ltYWxTY2FsZSIsImZpbGxlciIsInJlcGVhdCIsImNvdW50IiwiQXJyYXkiLCJqb2luIiwidG9OdW1lcmljU3RyaW5nIiwibnVtIiwiX251bSIsInNpZ24iLCJyZWYiLCJjb2VmZmljaWVudCIsImV4cG9uZW50IiwiTnVtYmVyIiwiZGVjaW1hbEluZGV4IiwiY29mZmllY2llbnRMbiIsIk1hdGgiLCJhYnMiLCJyb3VuZFRvUHJlY2lzaW9uIiwic2hvdWxkSGF2ZURlY2ltYWxTZXBhcmF0b3IiLCJmbG9hdFZhbHVlIiwicGFyc2VGbG9hdCIsImZsb2F0VmFsdWVTdHIiLCJ0b0ZpeGVkIiwicm91bmRlZERlY2ltYWxQYXJ0cyIsImludFBhcnQiLCJyZXZlcnNlIiwicmVkdWNlIiwicm91bmRlZFN0ciIsImlkeCIsInRvU3RyaW5nIiwiZGVjaW1hbFBhcnQiLCJuZWdhdGlvbiIsImRlY2ltYWxTZXBhcmF0b3IiLCJzZXRDYXJldFBvc2l0aW9uIiwiZWwiLCJjYXJldFBvcyIsInZhbHVlIiwiY3JlYXRlVGV4dFJhbmdlIiwicmFuZ2UiLCJtb3ZlIiwic2VsZWN0Iiwic2VsZWN0aW9uU3RhcnQiLCJmb2N1cyIsInNldFNlbGVjdGlvblJhbmdlIiwiZmluZENoYW5nZVJhbmdlIiwicHJldlZhbHVlIiwibmV3VmFsdWUiLCJqIiwicHJldkxlbmd0aCIsIm5ld0xlbmd0aCIsImZyb20iLCJzdGFydCIsImVuZCIsInRvIiwiY2xhbXAiLCJtaW4iLCJtYXgiLCJnZUlucHV0Q2FyZXRQb3NpdGlvbiIsInNlbGVjdGlvbkVuZCIsImFkZElucHV0TW9kZSIsIm5hdmlnYXRvciIsInBsYXRmb3JtIiwidGVzdCIsImdldERlZmF1bHRDaGFuZ2VNZXRhIiwibGFzdFZhbHVlIiwiZ2V0TWFza0F0SW5kZXgiLCJtYXNrIiwiZ2V0Q2FyZXRQb3NpdGlvbiIsIm5ld0Zvcm1hdHRlZFZhbHVlIiwibGFzdEZvcm1hdHRlZFZhbHVlIiwiY3VyVmFsdWUiLCJjdXJDYXJldFBvcyIsImJvdW5kYXJ5IiwiaXNWYWxpZElucHV0Q2hhcmFjdGVyIiwiZmlyc3RBbGxvd2VkUG9zaXRpb24iLCJmaW5kSW5kZXgiLCJiIiwicHJlZml4Rm9ybWF0Iiwic2xpY2UiLCJzdGFydHNXaXRoIiwiY3VyVmFsTG4iLCJmb3JtYXR0ZWRWYWx1ZUxuIiwiYWRkZWRJbmRleE1hcCIsImluZGV4TWFwIiwiakxuIiwicG9zIiwiZW5kSW5kZXgiLCJzdGFydEluZGV4IiwiZ2V0Q2FyZXRQb3NJbkJvdW5kYXJ5IiwiZGlyZWN0aW9uIiwidmFsTG4iLCJsYXN0SW5kZXhPZiIsImNhcmV0VW5rbm93bkZvcm1hdEJvdW5kYXJ5IiwiZm9ybWF0dGVkVmFsdWUiLCJib3VuZGFyeUFyeSIsIm1hcCIsImxuIiwiQm9vbGVhbiIsInVzZUludGVybmFsVmFsdWVzIiwiZGVmYXVsdFZhbHVlIiwidmFsdWVJc051bWVyaWNTdHJpbmciLCJmb3JtYXQiLCJyZW1vdmVGb3JtYXR0aW5nIiwib25WYWx1ZUNoYW5nZSIsInByb3BWYWx1ZXMiLCJnZXRWYWx1ZXMiLCJudW1Bc1N0cmluZyIsInZhbHVlcyIsInNldFZhbHVlcyIsIl9vblZhbHVlQ2hhbmdlIiwic291cmNlSW5mbyIsImRlZmF1bHRSZW1vdmVGb3JtYXR0aW5nIiwiZGVmYXVsdEZvcm1hdCIsIk51bWJlckZvcm1hdEJhc2UiLCJwcm9wcyIsInR5cGUiLCJkaXNwbGF5VHlwZSIsImN1c3RvbUlucHV0IiwicmVuZGVyVGV4dCIsImdldElucHV0UmVmIiwiaXNBbGxvd2VkIiwib25DaGFuZ2UiLCJvbktleURvd24iLCJvbk1vdXNlVXAiLCJvbkZvY3VzIiwib25CbHVyIiwicHJvcFZhbHVlIiwiZ2V0Q2FyZXRCb3VuZGFyeSIsIm90aGVyUHJvcHMiLCJyZWZfMCIsIm9uRm9ybWF0dGVkVmFsdWVDaGFuZ2UiLCJsYXN0VXBkYXRlZFZhbHVlIiwic291cmNlIiwiaW5wdXQiLCJmb2N1c2VkRWxtIiwiX251bUFzU3RyaW5nIiwidXBkYXRlVmFsdWUiLCJldmVudCIsInJlZiQxIiwibW91bnRlZCIsInNldE1vdW50ZWQiLCJ0aW1lb3V0Iiwic2V0Q2FyZXRUaW1lb3V0IiwiZm9jdXNUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiX2Zvcm1hdCIsImdldFZhbHVlT2JqZWN0Iiwic2V0UGF0Y2hlZENhcmV0UG9zaXRpb24iLCJjdXJyZW50VmFsdWUiLCJzZXRUaW1lb3V0IiwiY29ycmVjdENhcmV0UG9zaXRpb24iLCJnZXROZXdDYXJldFBvc2l0aW9uIiwiaW5wdXRWYWx1ZSIsImNhcmV0Qm91bmRhcnkiLCJ1cGRhdGVkQ2FyZXRQb3MiLCJwYXJhbXMiLCJjdXJyZW50Q2FyZXRQb3NpdGlvbiIsImZvcm1hdElucHV0VmFsdWUiLCJjaGFuZ2VSYW5nZSIsImNoYW5nZU1ldGEiLCJhc3NpZ24iLCJfZm9ybWF0dGVkVmFsdWUiLCJ0YXJnZXQiLCJfb25DaGFuZ2UiLCJjaGFuZ2VkIiwiX29uS2V5RG93biIsImtleSIsImV4cGVjdGVkQ2FyZXRQb3NpdGlvbiIsIm5ld0NhcmV0UG9zaXRpb24iLCJpc1VuaXRUZXN0UnVuIiwiX29uTW91c2VVcCIsImNhcmV0UG9zaXRpb24iLCJfb25Gb2N1cyIsInBlcnNpc3QiLCJfb25CbHVyIiwiaW5wdXRNb2RlIiwiaW5wdXRQcm9wcyIsImNyZWF0ZUVsZW1lbnQiLCJGcmFnbWVudCIsIkN1c3RvbUlucHV0IiwiZGVjaW1hbFNjYWxlIiwicHJlZml4Iiwic3VmZml4IiwiZ2V0U2VwYXJhdG9ycyIsImhhc0RlY2ltYWxTZXBhcmF0b3IiLCJhbGxvd2VkRGVjaW1hbFNlcGFyYXRvcnMiLCJoYW5kbGVOZWdhdGlvbiIsIm5lZ2F0aW9uUmVnZXgiLCJSZWdFeHAiLCJkb3VibGVOZWdhdGlvblJlZ2V4IiwicmVtb3ZlTmVnYXRpb24iLCJnZXROdW1iZXJSZWdleCIsImdsb2JhbCIsImlzQmVmb3JlRGVjaW1hbFNlcGFyYXRvciIsInNlcGFyYXRvciIsInN0cmlwTmVnYXRpb24iLCJoYXNEb3VibGVOZWdhdGlvbiIsImNoYXJzVG9SZW1vdmUiLCJ0b01ldGFkYXRhIiwiZnJvbVN0YXJ0IiwiZnJvbUVuZCIsInVwZGF0ZWRTdWZmaXhQYXJ0Iiwic3VmZml4U3RhcnRJbmRleCIsImVuZHNXaXRoIiwiZmlyc3RJbmRleCIsInJlZiQyIiwiZmlsbCIsInZhbGlkYXRlQW5kVXBkYXRlUHJvcHMiLCJFcnJvciIsImNvbnNvbGUiLCJlcnJvciIsInVzZU51bWVyaWNGb3JtYXQiLCJhbGxvd0xlYWRpbmdaZXJvcyIsInJlc3RQcm9wcyIsIl9yZW1vdmVGb3JtYXR0aW5nIiwiX3ZhbHVlSXNOdW1lcmljU3RyaW5nIiwicm91bmRJbmNvbWluZ1ZhbHVlVG9QcmVjaXNpb24iLCJwcmV2ZW50RGVmYXVsdCIsImluY2x1ZGVzIiwiX3Rob3VzYW5kU2VwYXJhdG9yIiwiX3ZhbHVlIiwiaW5wdXRDaGFyIiwiTnVtZXJpY0Zvcm1hdCIsIm51bWVyaWNGb3JtYXRQcm9wcyIsImZvcm1hdCQxIiwiYWxsb3dFbXB0eUZvcm1hdHRpbmciLCJwYXR0ZXJuQ2hhciIsImhhc2hDb3VudCIsImZvcm1hdHRlZE51bWJlckFyeSIsInJlbW92ZUZvcm1hdHRpbmckMSIsImlzTnVtZXJpY1Nsb3QiLCJyZW1vdmVGb3JtYXRDaGFyIiwic3RyaW5nIiwiZXh0cmFjdE51bWJlcnMiLCJmaXJzdFNlY3Rpb24iLCJtaWRkbGVTZWN0aW9uIiwibGFzdFNlY3Rpb24iLCJnZXRDYXJldEJvdW5kYXJ5JDEiLCJmaXJzdEVtcHR5U2xvdCIsIm1hc2tBbmRJbmRleE1hcCIsImZvckVhY2giLCJtYXNrQXRJbmRleCIsImlzUG9zQWxsb3dlZCIsInZhbGlkYXRlUHJvcHMiLCJtYXNrQXNTdHIiLCJ1c2VQYXR0ZXJuRm9ybWF0IiwiZm9ybWF0UHJvcCIsIl9nZXRDYXJldEJvdW5kYXJ5IiwiZm9ybWF0TG4iLCJQYXR0ZXJuRm9ybWF0IiwicGF0dGVybkZvcm1hdFByb3BzIiwiZ2V0TnVtZXJpY0NhcmV0Qm91bmRhcnkiLCJnZXRQYXR0ZXJuQ2FyZXRCb3VuZGFyeSIsIm51bWVyaWNGb3JtYXR0ZXIiLCJwYXR0ZXJuRm9ybWF0dGVyIiwicmVtb3ZlTnVtZXJpY0Zvcm1hdCIsInJlbW92ZVBhdHRlcm5Gb3JtYXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-number-format/dist/react-number-format.es.js\n");

/***/ })

};
;